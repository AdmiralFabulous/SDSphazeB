# Suit sales break-even for charter flights

**Created:** 1/19/2026 18:11:15  
**Updated:** 1/19/2026 20:07:25  
**Exported:** 1/19/2026 20:10:26  
**Link:** [https://claude.ai/chat/4226c825-4393-457e-b379-17abc108acde](https://claude.ai/chat/4226c825-4393-457e-b379-17abc108acde)  

## Prompt:
1/19/2026, 6:11:17 PM

So we make about £1000 on every Suit, and we will need to charter planes from ATQ Amaritza Sri Ram Airport out to the UAE during the expo season in dubai, So I want you come up with the break even costs for how many suits pay for that charter the charter flight absolutely packed to the rafters with suits



## Response:
1/19/2026, 6:12:10 PM

````plaintext
Thought process: Investigated charter flight costs to calculate suit break-even threshold.

The user is asking about break-even analysis for chartering flights from Amritsar (ATQ) to UAE during Dubai expo season. They want to know how many suits (at £1000 profit each) would cover the cost of a charter flight packed with suits.

I need to search for information about charter flight costs from Amritsar to Dubai/UAE, and possibly look at what's in the project knowledge about their logistics setup.

Let me search the project knowledge first to see if there are any existing details about charter costs or logistics planning.
````

I'll search for relevant logistics and charter information in your project knowledge first, then supplement with current charter rates.

````plaintext
Tool: Searching project
````

````plaintext
Thought process: Hunted for charter flight pricing data to calculate break-even analysis.

The project knowledge doesn't have specific charter flight costs. I need to search for current charter flight costs from Amritsar (ATQ) to UAE. Let me search the web for this information.
````

The project knowledge covers your logistics model but not charter flight specifics. Let me search for current charter rates from ATQ to UAE.

````plaintext
Web Search: charter cargo flight cost India UAE per flight hour rate 2024 2025
````

> **Private Jet Charter Cost in India – 2026 Guide - SAFE FLY AVIATION** [safefly.aero](https://safefly.aero/private-jet-charter-cost-in-india-2025/)
>
> **Private Jet Charter Cost in India 2026: Transparent Pricing Guide for Domestic & International Flights - SAFE FLY AVIATION** [safefly.aero](https://safefly.aero/private-jet-charter-cost-india-2025-latest/)
>
> **Cargo Charter Rates 2026: India to Middle East, Europe & Africa | Safe Fly Aviation - SAFE FLY AVIATION** [safefly.aero](https://safefly.aero/blog-cargo-charter-rates-2026/)
>
> **Cost to Book a Private Jet in 2025 | Key Factors & Price Guide - Club One Air** [cluboneair.com](https://www.cluboneair.com/blog/cost-to-book-a-private-jet-in-2025-key-factors-price-guide/)
>
> **Private Jet Charter Cost India 2026: Mumbai to Delhi, Goa, Dubai & Maldives | Safe Fly Aviation - SAFE FLY AVIATION** [safefly.aero](https://safefly.aero/private-jet-charter-cost-india-2026/)
>
> **Charter Flight - Book Passenger & CarGo Charter Plane | IndiGo** [goindigo.in](https://www.goindigo.in/charters.html)
>
> **Cargo Plane Charter Cost Guide 2025 | Pricing & Tips** [gctfreight.com](https://gctfreight.com/cargo-plane-charter-cost/)
>
> **Private Jet Cost India 2025: A Complete Charter Pricing Guide -** [ahimaairways.com](https://ahimaairways.com/private-jet-cost-india-2025-a-complete-charter-pricing-guide/)
>
> **How Much Does It Cost to Charter a Private Jet in India?** [aircharterservice.co.in](https://www.aircharterservice.co.in/about-us/news-features/blog/how-much-does-it-cost-to-charter-a-private-jet)
>
> **Private Jet Rental Cost in India** [challengejetcharter.com](https://challengejetcharter.com/private-jet-rental-price-in-india/)
>
````plaintext
Thought process: Hunted specialized cargo charter data and aircraft capacity specifications.

This is helpful but mostly about passenger jets. Let me get more specific information about cargo charter costs for the ATQ to Dubai route and also search for information about suit cargo capacity on aircraft.
````

Let me get more specific cargo charter costs for this route.

````plaintext
Web Fetch: Fetched: Cargo Charter Rates 2026: India to Middle East, Europe & Africa | Safe Fly Aviation - SAFE FLY AVIATION
````

````plaintext
Thought process: Synthesized cargo charter rates and calculated suit break-even quantities.

Excellent - this has detailed cargo charter rates. Now I have good data to work with. Let me compile the break-even analysis.

Key data for ATQ to UAE (Dubai/Sharjah):
- Flight time: ~3.5 hours from Mumbai/Delhi to Dubai
- ATQ (Amritsar) is closer to Dubai than Mumbai, so likely similar or slightly shorter flight time

From the cargo charter data:
- B737-400F: 18-20T payload, ₹30-36 lakh one-way (~£28,000-33,000)
- B757-200F: 28-30T payload, ₹44-52 lakh one-way (~£41,000-48,000)
- Empty-leg/Backhaul: 15-20T, ₹20-26 lakh (~£18,500-24,000)

For smaller aircraft from the other data:
- ATR 72F: 7-8T, ₹15-20 lakh for short routes (~£14,000-18,500)

Now, suits - how much space/weight does a suit take?
A typical suit probably weighs about 1.5-2kg including packaging. Let's say 2kg packaged.
Volume-wise, a suit in a garment bag might be about 0.02-0.03 cubic meters.

Profit per suit: £1,000

Let me calculate:

For a B737-400F (most practical option):
- Cost: ~£30,000 (middle estimate)
- Break-even: 30 suits

For B757-200F:
- Cost: ~£45,000
- Break-even: 45 suits

But I need to figure out how many suits can actually fit "packed to the rafters":

Weight:
- 2kg per suit
- B737F can carry 18-20 tonnes = 18,000-20,000 kg


- Maximum suits by weight: 9,000-10,000 suits

Volume is the real limiting factor here. The B737F has roughly 150 cubic meters of cargo space, and with each suit taking up about 0.02-0.03 cubic meters, I'm looking at a maximum of 5,000-7,500 suits by volume. In practice though, I wouldn't need anywhere near that capacity for a viable operation.
````

This is excellent data. Let me build out the break-even analysis for you.

---

## Charter Break-Even Analysis: ATQ to UAE

**Core Assumption:** £1,000 profit per suit

### Aircraft Options for India-UAE Route (~3.5 hours flight time)

| Aircraft | Payload | Volume | Charter Cost (INR) | Charter Cost (GBP) | Suits to Break Even |
|----------|---------|--------|-------------------|-------------------|---------------------|
| **ATR 72F** | 8-9T | 73m³ | ₹15-20 lakh | £14,000-18,500 | **14-19 suits** |
| **B737-400F** | 18-20T | 150m³ | ₹30-36 lakh | £28,000-33,000 | **28-33 suits** |
| **B757-200F** | 28-32T | 240m³ | ₹44-52 lakh | £41,000-48,000 | **41-48 suits** |
| **Empty Leg/Backhaul** | 15-20T | varies | ₹20-26 lakh | £18,500-24,000 | **19-24 suits** |

*(Using approximate INR/GBP rate of ~108)*

---

### Maximum Capacity: "Packed to the Rafters"

**Per-Suit Specs (packaged in garment bag/box):**
- Weight: ~2kg
- Volume: ~0.025m³

| Aircraft | Max by Weight | Max by Volume | Practical Max |
|----------|--------------|---------------|---------------|
| **ATR 72F** | 4,000-4,500 | ~2,900 | **~2,500 suits** |
| **B737-400F** | 9,000-10,000 | ~6,000 | **~5,000 suits** |
| **B757-200F** | 14,000-16,000 | ~9,600 | **~8,000 suits** |

Volume is the constraint, not weight. Suits are bulky but light.

---

### The Business Case

**B737-400F (Most Practical Option):**
- Charter cost: ~£30,000
- Break-even: **30 suits**
- Max capacity: ~5,000 suits
- If you fill it with 100 suits: £70,000 profit after charter cost
- If you fill it with 500 suits: £470,000 profit after charter cost

**Economics per suit at different volumes (B737-400F):**

| Suits Shipped | Charter Cost/Suit | Net Profit/Suit |
|---------------|-------------------|-----------------|
| 30 (break-even) | £1,000 | £0 |
| 50 | £600 | £400 |
| 100 | £300 | £700 |
| 250 | £120 | £880 |
| 500 | £60 | £940 |

---

### Key Considerations

**Peak Surcharges:** Expect +20% during Ramadan, Eid, and major Dubai Expo events - the exact times you'd want to charter.

**Empty Leg Opportunities:** Backhaul flights from UAE to India run ~£18,500-24,000. If you can find aircraft repositioning back to India, you could hit break-even at **19-24 suits**.

**Booking Lead Time:** 7-21 days advance booking can save 15-30% vs. last-minute.

---

### Bottom Line

At £1,000 profit per suit, you need roughly **30 suits** on a B737 charter to break even, or as few as **14-15 suits** if you can source an ATR 72F or catch an empty leg. Given your expo season volumes and the 24-hour delivery premium you're commanding, the charter economics become attractive once you're moving 50+ suits per flight - at which point each suit is only carrying £600 in air freight cost, leaving £400 in additional margin versus your current commercial routing strategy.



## Prompt:
1/19/2026, 6:32:50 PM

ok so our capacity in this model for production is Daily Capacity
MetricValueWeekly capacity3,240 suitsOperating days6 daysDaily capacity540 suits
By Shift
ShiftHoursSuitsDay (06:00-14:00)8180Evening (14:00-22:00)8180Night (22:00-06:00)8180Total24540
Bottleneck Breakdown (Per Day)
ZoneCapacityUtilizationOptitex (6 stations)540100%Plotters (3 units)540100%Packing (6 stations)540100%QC (21 inspectors)58892%



## Response:
1/19/2026, 6:33:16 PM

````plaintext
Thought process: Analyzed production capacity against charter flight economics viability.

The user is sharing their production capacity data. Let me analyze this in the context of the charter flight economics we just discussed.

Key figures:
- Daily capacity: 540 suits
- Weekly capacity: 3,240 suits (6 days operating)
- Three 8-hour shifts producing 180 suits each
- Bottlenecks at 100% utilization: Optitex (6 stations), Plotters (3 units), Packing (6 stations)
- QC has 21 inspectors handling 588 suits capacity at 92% utilization

Now let me think about how this relates to the charter economics:

At 540 suits/day production capacity:
- If they charter a B737-400F (capacity ~5,000 suits, cost ~£30,000, break-even at 30 suits)
- At 540 suits/day, they'd fill a B737 in about 9-10 days of production
- But the charter cost per suit at 540 suits would be: £30,000 / 540 = ~£55.56 per suit

So with daily production capacity of 540 suits:
- Charter cost per suit: ~£56
- That leaves £944 profit per suit after charter costs
- Total daily profit if chartering: 540 × £944 = £509,760

This is actually very favorable economics. The charter becomes highly efficient at this volume.

But wait - I should think about this more carefully. The 24-hour delivery model means they're not accumulating inventory for 9-10 days to fill a plane. They need to ship daily or even more frequently to maintain the same-day delivery promise.

So the question becomes: can they fill a charter daily during expo season?

At 540 suits/day:
- B737-400F: £30,000 charter, 540 suits = £55.56/suit charter cost
- This is incredibly efficient

But they may not hit 540 suits/day demand during expo. Let me think about what volumes make the charter worthwhile vs. 

The real question is whether daily demand during peak season justifies chartering versus using commercial flights. At full capacity, the per-suit charter cost becomes negligible, but I need to consider what realistic daily volumes look like during the expo period and whether that's enough to make dedicated charters economical.
````

This changes the picture significantly. Let me map your production capacity against the charter economics.

---

## Charter Economics at Scale

### Daily Production vs. Charter Efficiency

| Daily Volume | B737-400F Charter Cost/Suit | Net Profit/Suit | Daily Gross Profit |
|--------------|----------------------------|-----------------|-------------------|
| 30 (break-even) | £1,000 | £0 | £0 |
| 100 | £300 | £700 | £70,000 |
| 180 (single shift) | £167 | £833 | £150,000 |
| 360 (two shifts) | £83 | £917 | £330,000 |
| **540 (full capacity)** | **£56** | **£944** | **£510,000** |

At full tilt, charter freight adds only **£56 per suit** - essentially a rounding error on a £20,000+ garment.

---

### Charter Frequency Options During Expo

**Scenario A: Daily Charter (B737-400F)**
- 540 suits/day
- £30,000/day charter cost
- £16,200/week in charter costs (6 days)
- Maintains 24-hour delivery promise

**Scenario B: Twice-Weekly Charter (B737-400F)**
- Accumulate 1,620 suits over 3 days
- £60,000/week in charter costs
- Charter cost drops to £37/suit
- Delivery window extends to 48-72 hours

**Scenario C: Weekly Charter (B757-200F)**
- 3,240 suits/week fills ~40% of capacity
- Single £45,000 charter
- £14/suit charter cost
- Delivery window extends to 7 days (loses the USP)

---

### The Real Question

Your 24-hour delivery promise is the entire value proposition. That means you need daily flights during peak demand.

**Break-even threshold for daily B737 charter: 30 suits/day**

Once you're consistently hitting **30+ orders per day** during expo season, chartering makes more sense than commercial routing. Below that, you're paying for empty space.

**Decision trigger:** When daily order volume crosses 30 units consistently, switch from commercial freight to dedicated charter.

What's your projected daily order volume during Dubai Expo season?



## Prompt:
1/19/2026, 6:34:11 PM

so if we fly there and back continuously with onload and offload operations and clearing customs, how many trips could we fit into a 24 hour day



## Response:
1/19/2026, 6:34:40 PM

````plaintext
Thought process: Calculated feasible round trips accounting for flight duration and ground operations.

The user wants to know how many round trips a charter aircraft could make between ATQ (Amritsar) and UAE in a 24-hour period, factoring in:
- Flight time
- Turnaround/loading/unloading
- Customs clearance
- Any other ground operations

Let me think through this:

ATQ to Dubai (DXB/SHJ/DWC) flight time: ~3.5 hours (as mentioned in the search results)

So round trip flight time: ~7 hours

Ground operations at each end:
- Landing, taxi, parking
- Unloading cargo
- Customs clearance
- Loading new cargo (if any)
- Refueling
- Pre-flight checks
- Taxi, takeoff

This could be anywhere from 1.5-3 hours per stop depending on efficiency.

Let me calculate:

Conservative estimate:
- Flight ATQ → UAE: 3.5 hours
- Ground ops UAE: 2-3 hours (unload, customs, refuel)
- Flight UAE → ATQ: 3.5 hours
- Ground ops ATQ: 2-3 hours (load, refuel, prep)

Total cycle time: 11-13 hours

So in 24 hours: 1.8-2.2 cycles, practically 2 trips

Optimistic estimate with streamlined operations:
- Flight: 3.5 hours each way = 7 hours
- Ground UAE: 1.5 hours (dedicated handling, pre-cleared customs)
- Ground ATQ: 1.5 hours (pre-loaded, quick turnaround)

Total cycle: 10 hours

In 24 hours: 2.4 cycles, practically 2 trips

The user should also consider:
- Crew duty time limitations (pilots can only fly so many hours)
- Aircraft maintenance requirements
- Whether they need to bring anything back from UAE or if it's one-way cargo only


- Pre-staging cargo and pre-clearing customs could significantly reduce ground time, potentially enabling a third trip if operations are optimized efficiently.
````

Let me break down the cycle time.

---

## Round-Trip Cycle Analysis: ATQ to UAE

### Flight Time
| Leg | Duration |
|-----|----------|
| ATQ → DXB/SHJ | 3.5 hours |
| DXB/SHJ → ATQ | 3.5 hours |
| **Total air time** | **7 hours** |

### Ground Operations

**Amritsar (Loading)**
| Activity | Duration |
|----------|----------|
| Taxi and parking | 15 min |
| Loading cargo (pre-staged suits) | 45-60 min |
| Refueling | 30 min |
| Flight planning/clearances | 20 min |
| Taxi and takeoff | 15 min |
| **Total ATQ turnaround** | **2-2.5 hours** |

**UAE (Unloading + Customs)**
| Activity | Duration |
|----------|----------|
| Landing and taxi | 15 min |
| Unloading cargo | 45-60 min |
| Customs clearance | 1-2 hours |
| Refueling | 30 min |
| Outbound clearances | 20 min |
| Taxi and takeoff | 15 min |
| **Total UAE turnaround** | **3-4 hours** |

---

### Cycle Time Scenarios

| Scenario | Cycle Time | Trips per 24h |
|----------|-----------|---------------|
| **Standard ops** | 12-13.5 hours | **1.8 trips** (realistically 1-2) |
| **Optimised ops** (pre-clearance, dedicated handlers) | 10-11 hours | **2.2 trips** (realistically 2) |
| **Maximum efficiency** (bonded cargo, express lanes) | 9-10 hours | **2.4 trips** (realistically 2) |

---

### Constraints Beyond Time

**Crew Duty Limitations**
- Pilots have legally mandated rest requirements
- Typical limit: 10-14 hours flight duty period depending on jurisdiction
- A single crew can manage 1-2 round trips before mandatory rest
- Solution: Two crews rotating

**Aircraft Maintenance**
- Daily checks required after certain flight hours
- Transit checks between rotations

**Customs Reality in UAE**
- Standard clearance: 2-4 hours
- Pre-cleared/bonded: 45-60 min
- Dedicated customs broker with pre-filed documentation is essential

---

### Practical Maximum: 2 Rotations per 24 Hours

With optimised operations:

| Per Day | Suits Delivered |
|---------|-----------------|
| 2 x B737-400F rotations | Up to 10,000 suits (capacity) |
| Your production capacity | 540 suits |
| **Utilisation** | **5.4%** |

You're massively over-capacity on airlift versus production. A single daily rotation at 540 suits uses only **11% of a B737's capacity**.

---

### The Strategic Options

**Option 1: Daily single rotation (your production)**
- 540 suits/day
- £56/suit freight cost
- Clean 24-hour delivery promise

**Option 2: Consolidate to every-other-day**
- 1,080 suits per flight
- £28/suit freight cost
- 48-hour delivery window

**Option 3: Share capacity**
- Partner with other exporters (textiles, pharma) on the same route
- Subsidise your charter cost
- Maintain daily frequency

Which constraint matters more - the 24-hour promise or minimising freight cost per unit?



## Prompt:
1/19/2026, 6:36:35 PM

so if the 737 is under utilised why are we not looking at the other charter vessels



## Response:
1/19/2026, 6:37:18 PM

````plaintext
Thought process: Reconsidered smaller aircraft options and payload-to-capacity mismatches.

The user is right - I went straight to the B737 analysis without properly considering smaller aircraft that would be better matched to their 540 suits/day production capacity. Let me recalculate with the smaller options.

Their daily production: 540 suits
Per suit: ~2kg weight, ~0.025m³ volume

So daily shipment:
- Weight: 540 x 2kg = 1,080kg = 1.08 tonnes
- Volume: 540 x 0.025m³ = 13.5m³

Let me look back at the aircraft options:

| Aircraft | Payload | Volume | Charter Cost (INR) | Charter Cost (GBP) |
|----------|---------|--------|-------------------|-------------------|
| ATR 72F | 8-9T | 73m³ | ₹15-20 lakh | £14,000-18,500 |
| B737-400F | 18-20T | 150m³ | ₹30-36 lakh | £28,000-33,000 |
| B757-200F | 28-32T | 240m³ | ₹44-52 lakh | £41,000-48,000 |

So 540 suits at 1.08T and 13.5m³ is way under even the ATR 72F capacity (8-9T, 73m³).

They need even smaller aircraft. Let me think about what's available:

From the search results:
- Saab 340F: 4-5T payload, 45m³ volume, ₹4.0-5.3 lakh/hr
- Antonov An-26: 5-6T payload, 40m³ volume, ₹4.8-6.5 lakh/hr

Actually wait - the rates for ATQ to Dubai weren't given for these smaller aircraft. The ₹15-20 lakh for ATR 72F was for short GCC routes like India → Colombo, Dhaka, Muscat - not the full ATQ to UAE route.


For the 3.5-hour ATQ-Dubai leg, I need to calculate based on hourly rates: Saab 340F would run ₹14-18.5 lakh one way, ATR 72F around ₹20-27 lakh, and the An-26 approximately ₹17-23 lakh. These smaller turboprops are significantly cheaper than the jets for this particular route and cargo volume.

However, there's a critical constraint—most turboprops have effective ranges around 1,500km with full payload, but ATQ to Dubai exceeds 2,000km, which means they'd require a fuel stop. This adds both time and operational complexity, making the larger B737 more practical despite being oversized for just 1 tonne and 13.5 cubic meters.

I should also consider smaller alternatives like the Cessna Caravan, Pilatus PC-12, or Beechcraft 1900, which could theoretically handle this payload. Even a passenger charter with the cargo loaded into the hold might be viable. The real issue is that I haven't properly weighed all the smaller aircraft options against the standard cargo fleet.
````

You're right. Let me size this properly.

---

## Right-Sizing the Aircraft to 540 Suits/Day

### Your Actual Cargo Profile

| Metric | Value |
|--------|-------|
| Daily suits | 540 |
| Weight | ~1,080 kg (1.08 tonnes) |
| Volume | ~13.5 m³ |

---

### Aircraft Options Compared

| Aircraft | Payload | Volume | Hourly Rate (INR) | ATQ-UAE Cost (3.5hr) | Cost (GBP) | Utilisation | Cost/Suit |
|----------|---------|--------|-------------------|---------------------|------------|-------------|-----------|
| **Saab 340F** | 4-5T | 45m³ | ₹4.0-5.3 lakh | ₹14-18.5 lakh | £13,000-17,000 | 22-27% | **£24-31** |
| **An-26** | 5-6T | 40m³ | ₹4.8-6.5 lakh | ₹17-23 lakh | £16,000-21,000 | 18-27% | **£30-39** |
| **ATR 72F** | 8-9T | 73m³ | ₹5.8-7.8 lakh | ₹20-27 lakh | £18,500-25,000 | 12-18% | **£34-46** |
| **B737-400F** | 18-20T | 150m³ | - | ₹30-36 lakh | £28,000-33,000 | 5-9% | **£52-61** |

---

### The Catch: Range Limitations

| Aircraft | Max Range (full payload) | ATQ to Dubai | Problem |
|----------|-------------------------|--------------|---------|
| Saab 340F | ~1,500 km | ~2,000 km | Needs fuel stop |
| An-26 | ~1,100 km | ~2,000 km | Needs fuel stop |
| ATR 72F | ~1,500 km | ~2,000 km | Needs fuel stop |
| B737-400F | ~3,500 km | ~2,000 km | Direct, no stop |

Turboprops would need to stop in Karachi, Muscat, or similar - adding 1-2 hours to cycle time plus landing fees.

---

### Revised Cycle Times with Fuel Stop

| Aircraft | Flight Time | Fuel Stop | Ground Ops | Total Cycle | Trips/24hr |
|----------|-------------|-----------|------------|-------------|------------|
| Saab 340F | 5-5.5 hr | +1 hr | 5 hr | 11-12 hr | 2 |
| An-26 | 5.5-6 hr | +1 hr | 5 hr | 11.5-12 hr | 2 |
| ATR 72F | 5-5.5 hr | +1 hr | 5 hr | 11-12 hr | 2 |
| B737-400F | 7 hr | none | 5 hr | 12 hr | 2 |

The fuel stop largely negates the turboprop's time advantage.

---

### True Cost Comparison (Including Fuel Stop Fees)

| Aircraft | Base Charter | Fuel Stop Fees | Total | Cost/Suit |
|----------|--------------|----------------|-------|-----------|
| **Saab 340F** | £15,000 | +£2,000-3,000 | £17,000-18,000 | **£31-33** |
| **An-26** | £18,500 | +£2,000-3,000 | £20,500-21,500 | **£38-40** |
| **ATR 72F** | £22,000 | +£2,000-3,000 | £24,000-25,000 | **£44-46** |
| **B737-400F** | £30,000 | none | £30,000 | **£56** |

---

### The Sweet Spot: Saab 340F

At 540 suits/day:
- Charter cost: ~£17,000-18,000
- **£31-33 per suit**
- 22-27% capacity utilisation (much healthier)
- Saves ~£12,000/day vs B737

**Weekly savings:** £72,000
**Monthly savings:** £288,000

---

### Scaling Thresholds

| Daily Volume | Best Aircraft | Cost/Suit |
|--------------|---------------|-----------|
| Under 200 | Commercial freight | Variable |
| 200-500 | Saab 340F | £31-40 |
| 500-800 | ATR 72F | £30-35 |
| 800-1,500 | B737-400F | £25-35 |
| 1,500+ | B757-200F or 2x B737 | £20-30 |

Does the Saab 340F route with a fuel stop work operationally, or does the added complexity outweigh the cost savings?



## Prompt:
1/19/2026, 6:43:46 PM

ok so practically can we only take the orders during waking hours in the uae for these flights from expos and hotel measurings, but they could come in at any time online so what is the most sensible way to get the most runs out of this saab and ground it if it is cheaper to use runners if we have less than 30 suits, switching to loading runners on commercial flights



## Response:
1/19/2026, 6:44:45 PM

````plaintext
Thought process: Architected logistics model balancing Saab flights with commercial runner fallback.

The user is asking about optimizing their logistics based on order timing. They want to:

1. Understand that in-person orders (expo, hotel measurements) come during UAE waking hours
2. Online orders can come anytime
3. Figure out the optimal flight schedule for the Saab 340F
4. Have a fallback to commercial flight runners when volume is below 30 suits (the break-even point)

Let me think through this:

UAE waking/business hours: roughly 8am - 10pm UAE time (UTC+4)
Amritsar is UTC+5:30, so 1.5 hours ahead of UAE

Key considerations:
- Order cutoff times
- Production time needed
- Flight scheduling
- When to switch to runners on commercial flights

Let me map this out properly.

Commercial flights from Amritsar to Dubai:
- Need to search for actual flight schedules or make reasonable assumptions
- Typically there are several flights per day

The Saab 340F cycle time with fuel stop is about 11-12 hours, so 2 rotations per 24 hours max.

If we're running the Saab, we want to batch orders efficiently. The question is when to cut off orders for each flight.

Let me think about the production pipeline:
- Order comes in
- Measurement verification
- Pattern generation (Optitex)
- Pattern cutting (plotter)
- Dispatch to tailor
- Tailoring (this is the longest part - they have 3 shifts running)
- QC
- Packing
- Loading onto flight

For same-day delivery, the bottleneck is the tailoring time. If they have 24-hour production running, they can produce continuously.

The question is really about batching deliveries efficiently.

UAE business hours for orders: Let's say 8am - 10pm UAE (which is 9:30am - 11:30pm IST)

If a suit takes roughly 8-12 hours to produce (from order to packed), then:


- Morning UAE orders (8am-12pm UAE = 9:30am-1:30pm IST) could be on evening/night flights
- Afternoon UAE orders (12pm-6pm UAE = 1:30pm-7:30pm IST) could be on overnight/morning flights
- Evening UAE orders (6pm-10pm UAE = 7:30pm-11:30pm IST) could be on next morning flights

I need to map out the actual commercial flight timings from Amritsar to Dubai and then determine the optimal cutoff windows for each Saab rotation. The key is aligning production completion with flight departure times to minimize holding time while maximizing batch sizes.

For smaller volumes, using individual runners on commercial flights becomes more economical. A runner carrying 2-3 suits per trip costs roughly £400-600 total, which breaks down to £200-300 per suit. This undercuts the Saab's per-suit cost until reaching around 15-20 suits, where the charter's fixed costs distribute favorably across the batch. 4-6 suits in checked luggage, so roughly 5 suits per runner trip. Runner costs break down to around £500-700 total (return ticket plus fee), which is £100-140 per suit. That puts the crossover point at around 140 suits for the Saab—much higher than the 30-suit threshold mentioned. The user likely set 30 as an operational convenience threshold rather than a pure cost calculation. Looking back at the earlier numbers, the Saab break-even is actually closer to 17 suits, which suggests runners make sense below that volume and the charter becomes viable once you hit higher quantities.

Now I need to map out the operational framework: time zone considerations and order windows will determine when runners can actually operate, flight scheduling flexibility affects both charter and runner viability, and I should establish clear decision criteria for when to switch between methods. A decision matrix comparing these factors across different suit volumes will help clarify the recommendation.
````

Let me map this against time zones and order patterns.

---

## Time Zone Alignment

| Location | Zone | Midnight UAE | 6am UAE | Noon UAE | 6pm UAE |
|----------|------|--------------|---------|----------|---------|
| UAE | UTC+4 | 00:00 | 06:00 | 12:00 | 18:00 |
| Amritsar | UTC+5:30 | 01:30 | 07:30 | 13:30 | 19:30 |

---

## Order Windows

**In-Person (Expo/Hotels):** 09:00-22:00 UAE (10:30-23:30 IST)

**Online:** 24/7 but likely peaks during UAE waking hours

---

## Production Lead Time

| Stage | Duration |
|-------|----------|
| Order to pattern | 30-60 min |
| Pattern to tailor dispatch | 1-2 hr |
| Tailoring | 6-8 hr |
| QC + packing | 1-2 hr |
| **Total** | **9-12 hours** |

---

## Optimal Flight Windows

Working backwards from UAE delivery:

| Delivery Window | Depart ATQ | Order Cutoff (UAE) | Order Cutoff (IST) |
|-----------------|------------|-------------------|-------------------|
| Morning (08:00-10:00 UAE) | 02:00 IST | 14:00-16:00 previous day | 15:30-17:30 |
| Afternoon (14:00-16:00 UAE) | 08:00 IST | 20:00-22:00 previous day | 21:30-23:30 |
| Evening (20:00-22:00 UAE) | 14:00 IST | 02:00-04:00 same day | 03:30-05:30 |

---

## Saab 340F Schedule (2 Rotations)

| Flight | Depart ATQ | Arrive UAE | Return ATQ | Orders Served |
|--------|------------|------------|------------|---------------|
| **Red Eye** | 02:00 IST | 06:30 UAE | 12:00 IST | Previous afternoon/evening orders |
| **Afternoon** | 14:00 IST | 18:30 UAE | 00:00 IST | Morning/overnight orders |

This gives you two delivery windows per day with clear order cutoffs.

---

## Runner Economics

**Commercial Flight Options ATQ-DXB:**

Need to check actual schedules, but typical routing involves connections through DEL or BOM. Direct options are limited from Amritsar.

**Runner Cost Estimate:**

| Item | Cost |
|------|------|
| Return ticket (ATQ-DXB via DEL) | £250-400 |
| Runner fee | £75-100 |
| Meals/transport | £25-50 |
| **Total per runner** | **£350-550** |

**Suits per runner:** 4-6 (checked garment bags + carry-on)

**Cost per suit via runner:** £70-120

---

## Crossover Analysis

| Volume | Saab Cost | Saab/Suit | Runners Needed | Runner Cost | Runner/Suit | Winner |
|--------|-----------|-----------|----------------|-------------|-------------|--------|
| 5 | £17,000 | £3,400 | 1 | £450 | £90 | **Runners** |
| 10 | £17,000 | £1,700 | 2 | £900 | £90 | **Runners** |
| 20 | £17,000 | £850 | 4 | £1,800 | £90 | **Runners** |
| 50 | £17,000 | £340 | 10 | £4,500 | £90 | **Runners** |
| 100 | £17,000 | £170 | 20 | £9,000 | £90 | **Runners** |
| 150 | £17,000 | £113 | 30 | £13,500 | £90 | **Runners** |
| **189** | £17,000 | £90 | 38 | £17,100 | £90 | **Break-even** |
| 200 | £17,000 | £85 | 40 | £18,000 | £90 | **Saab** |
| 300 | £17,000 | £57 | 60 | £27,000 | £90 | **Saab** |
| 540 | £17,000 | £31 | 108 | £48,600 | £90 | **Saab** |

---

## Revised Threshold: ~190 Suits

Your break-even for Saab vs runners is around **190 suits per flight**, not 30.

At 540 suits/day split across 2 flights = 270 suits/flight, the Saab wins.

---

## Hybrid Operating Model

**Decision Logic Per Flight Window:**

```
IF suits_queued >= 190
    → Charter Saab
ELSE IF suits_queued >= 50
    → Evaluate: Saab if time-critical, Runners if flexible
ELSE
    → Runners on commercial flights
```

---

## Daily Dispatch Schedule

| Cutoff (UAE) | Cutoff (IST) | Volume Check | Action |
|--------------|--------------|--------------|--------|
| 16:00 | 17:30 | Count orders | Saab or Runners for morning UAE delivery |
| 22:00 | 23:30 | Count orders | Saab or Runners for afternoon UAE delivery |
| 04:00 | 05:30 | Count orders | Saab or Runners for evening UAE delivery |

---

## Expo Season vs Off-Season

| Period | Expected Daily Volume | Likely Mode |
|--------|----------------------|-------------|
| Expo peak | 400-540 | Saab x2 daily |
| Expo shoulder | 200-400 | Saab x1 + Runners |
| Normal season | 50-150 | Runners only |
| Off-season | Under 50 | Runners only |

---

## Operational Questions

1. **Commercial flight availability from ATQ** - do you have direct options or always connecting through DEL/BOM? This affects runner transit time significantly.

2. **Runner pool** - do you have reliable people who can do this repeatedly, or hiring per-trip?

3. **Customs handling** - runners face different clearance than cargo. Is your UAE side set up for both?



## Prompt:
1/19/2026, 6:46:53 PM

ok what we need is a plan that guarantees 24 hrs but scales the flights acording to demand, what is our break even point on the saab



## Response:
1/19/2026, 6:47:08 PM

````plaintext
Thought process: Recalibrated break-even analysis comparing charter costs against alternative delivery methods.

The user wants to clarify the break-even point for the Saab specifically. Let me recalculate this clearly.

From the earlier analysis:
- Saab 340F charter cost (including fuel stop): £17,000-18,000 per flight
- Runner cost per suit: £70-120 (let's use £90 as the midpoint)

Break-even calculation:
Saab cost = Runner cost × number of suits
£17,000 = £90 × n
n = £17,000 / £90 = 188.9 suits

So break-even is approximately 189-190 suits per flight.

But wait - the user is asking about the break-even for the Saab in the context of guaranteeing 24-hour delivery. Let me think about this differently.

If we're comparing Saab to runners, the break-even is ~190 suits.

But actually, looking back at the original question about "break even costs for how many suits pay for that charter" - I think the user wants to know at what point the Saab pays for itself from the £1,000 profit per suit.

Let me reconsider:

If profit per suit = £1,000
And Saab charter = £17,000

Then the Saab "pays for itself" at 17 suits (£17,000 / £1,000 = 17)

But that's not comparing to an alternative delivery method.

The user seems to want to understand:
1. When does Saab beat runners economically?
2. What's the minimum viable volume for the Saab?

Let me present both clearly.
````

## Saab 340F Break-Even

### Against Runners

| Metric | Value |
|--------|-------|
| Saab charter (inc. fuel stop) | £17,000 |
| Runner cost per suit | ~£90 |
| **Break-even** | **189 suits** |

Below 189 suits per flight: use runners
Above 189 suits per flight: charter the Saab

---

### Against Profit Margin

| Metric | Value |
|--------|-------|
| Saab charter | £17,000 |
| Profit per suit | £1,000 |
| **Break-even** | **17 suits** |

At 17 suits, the flight pays for itself from margin. Everything above is profit.

---

## The Two Numbers That Matter

| Threshold | Suits | Meaning |
|-----------|-------|---------|
| **Profit break-even** | 17 | Flight cost covered by suit margin |
| **Mode switch** | 189 | Saab becomes cheaper than runners |

---

## Scaling Decision Tree

```
Daily orders < 17      → Runners (protect margin)
Daily orders 17-188    → Runners (cheaper per unit)
Daily orders 189+      → Saab (cheaper per unit)
```

At what daily volume do you expect to operate during expo season versus normal trading?



## Prompt:
1/19/2026, 6:48:22 PM

can saab manage our full capacity from the amritsar facility?



## Response:
1/19/2026, 6:48:52 PM

````plaintext
Thought process: Analyzed aircraft capacity against production volume and scheduling feasibility.

The user is asking if the Saab 340F can handle their full production capacity of 540 suits per day.

Let me check the Saab 340F specs:
- Payload: 4-5 tonnes
- Volume: 45m³

Their daily production:
- 540 suits
- Weight: ~1,080 kg (1.08 tonnes)
- Volume: ~13.5 m³

So per flight, a Saab can handle:
- By weight: 4,000-5,000 kg / 2 kg per suit = 2,000-2,500 suits
- By volume: 45m³ / 0.025m³ per suit = 1,800 suits

So a single Saab flight can handle 540 suits easily - it would be at about 22-30% utilization.

But wait - they asked about full capacity. Can the Saab do 2 rotations per day to match the production schedule?

From earlier:
- Saab cycle time with fuel stop: 11-12 hours
- So 2 rotations per day is feasible

With 2 rotations:
- 2 x 1,800 suit capacity = 3,600 suits theoretical max
- Their daily production: 540 suits
- So yes, easily

But let me think about this more carefully in terms of the flight schedule matching production flow...

If they produce 540 suits across 3 shifts:
- Day shift (06:00-14:00 IST): 180 suits
- Evening shift (14:00-22:00 IST): 180 suits
- Night shift (22:00-06:00 IST): 180 suits

And the Saab can do 2 rotations per day...

Each Saab flight can carry 540 suits in one go (well within the 1,800 capacity). So even one flight per day handles full daily output.


The real constraint is coordinating when production batches finish with when flights depart to maintain the 24-hour delivery window.
````

## Saab 340F vs Full Capacity

### Your Production

| Metric | Value |
|--------|-------|
| Daily output | 540 suits |
| Weight | ~1,080 kg |
| Volume | ~13.5 m³ |

### Saab 340F Capacity

| Metric | Value |
|--------|-------|
| Payload | 4,000-5,000 kg |
| Volume | 45 m³ |

### Single Flight Utilisation

| Constraint | Saab Capacity | Your 540 Suits | Utilisation |
|------------|---------------|----------------|-------------|
| Weight | 4,500 kg | 1,080 kg | 24% |
| Volume | 45 m³ | 13.5 m³ | 30% |

**Yes. One Saab flight handles your entire daily production with 70% capacity to spare.**

---

## Flight Frequency Options

| Schedule | Suits per Flight | Utilisation | Charter Cost/Day | Cost/Suit |
|----------|------------------|-------------|------------------|-----------|
| 1 flight/day | 540 | 30% | £17,000 | £31 |
| 2 flights/day | 270 | 15% | £34,000 | £63 |

---

## The Trade-Off

**1 flight/day:**
- Cheaper per suit
- Single order cutoff window
- Some orders wait up to 23 hours before dispatch

**2 flights/day:**
- Double the cost
- Two cutoff windows
- Tighter delivery promise (max 12 hour wait before dispatch)

---

## Does 24-Hour Delivery Require 2 Flights?

Working backwards:

| Event | Time |
|-------|------|
| Customer receives suit | T+24 |
| UAE delivery/logistics | 2 hours |
| Flight + customs | 6.5 hours |
| **Latest dispatch from ATQ** | **T+15.5** |
| Production time | 9-12 hours |
| **Latest order cutoff** | **T+3.5 to T+6.5** |

With a single daily flight departing at a fixed time, orders placed after cutoff wait until the next cycle - potentially 24 hours in queue before production even starts. That breaks your 24-hour promise.

---

## Minimum for 24-Hour Guarantee

**2 flights per day** - spaced 12 hours apart - ensures no order waits more than 12 hours before entering production.

| Flight | Depart ATQ | Arrive UAE | Covers Orders From |
|--------|------------|------------|-------------------|
| Morning | 02:00 IST | 06:30 UAE | 12:00-00:00 previous day |
| Afternoon | 14:00 IST | 18:30 UAE | 00:00-12:00 same day |

---

## Revised Daily Cost at Full Capacity

| Metric | Value |
|--------|-------|
| 2 x Saab charters | £34,000 |
| Suits delivered | 540 |
| **Cost per suit** | **£63** |

Still only 6.3% of a £1,000 margin. Acceptable.

---

## The Scaling Problem

At full capacity (540 suits), £63/suit works fine.

But during ramp-up or slow days:

| Daily Volume | Flights Needed | Cost | Cost/Suit |
|--------------|----------------|------|-----------|
| 50 | 2 | £34,000 | £680 |
| 100 | 2 | £34,000 | £340 |
| 189 | 2 | £34,000 | £180 |
| 300 | 2 | £34,000 | £113 |
| 400 | 2 | £34,000 | £85 |
| 540 | 2 | £34,000 | £63 |

You need **378 suits/day** (189 per flight x 2) before the Saab beats runners on both rotations.

---

## Hybrid Model for 24-Hour Guarantee

| Daily Volume | Morning Flight | Afternoon Flight |
|--------------|----------------|------------------|
| Under 50 | Runners | Runners |
| 50-188 | Runners | Runners |
| 189-377 | Saab | Runners |
| 378+ | Saab | Saab |

This maintains the 24-hour promise at every volume while optimising cost.

Does this hybrid approach work operationally, or do you need the predictability of a fixed charter contract?



## Prompt:
1/19/2026, 6:53:13 PM

so factor in suit order, claiming the order delay by the tailor , manufacturing by the tailor , runner bringing the suit for quality control (and bottlenecks while waiting on rack) the packing , transport from central amritsar, customs, and  delivery to anywhere in the uae after clearing the airport. where are our gaps and danger points



## Response:
1/19/2026, 6:54:13 PM

````plaintext
Thought process: Mapped entire supply chain pipeline identifying critical delays and failure points.

The user wants a comprehensive end-to-end timeline analysis of the entire suit delivery process, identifying gaps, bottlenecks, and danger points. Let me map out every stage from order to delivery and identify where things could go wrong.

Let me think through the full pipeline:

1. Order placed (online or in-person)
2. Order enters system
3. Pattern generation (Optitex)
4. Pattern cutting (plotters)
5. Job posted to tailor marketplace
6. Tailor claims job
7. Pattern dispatch to tailor (bike courier)
8. Tailor receives pattern
9. Tailor cuts fabric
10. Construction/manufacturing
11. Tailor marks complete
12. Runner collects for QC
13. QC inspection
14. Pass/fail decision
15. If fail - rework loop
16. If pass - packing
17. Transport to airport/dispatch point
18. Customs clearance (India side)
19. Flight
20. Customs clearance (UAE side)
21. Final mile delivery to customer

I need to map realistic times for each stage and identify:
- Fixed time blocks that can't be compressed
- Variable time blocks with risk
- Bottlenecks
- Failure points
- Buffer requirements

Let me search the project knowledge for more details on their pipeline.
````

Let me pull your pipeline details to map this properly.

````plaintext
Tool: Searching project
````

````plaintext
Thought process: Charted complete supply chain pipeline identifying critical vulnerabilities.

Now I have the full pipeline details. Let me map out the entire end-to-end process with realistic times and identify the gaps and danger points.
````

Now I can map the full pipeline with realistic times and risk points.

---

## End-to-End Timeline: Order to Delivery

### Phase 1: Order to Pattern Ready

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Order placed + payment | S01→S02 | Instant | 0 | Low |
| 3D scan received | S02→S03 | 0-30 min | 0.5 hr | **Medium** |
| Translation Matrix + Optitex | S03→S05 | 15-30 min | 1 hr | Low |
| Plotter queue + cutting | S05→S07 | 30-60 min | 2 hr | **Medium** |

**Subtotal: 2 hours**

---

### Phase 2: Pattern to Tailor

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Job published to marketplace | S07→S08 | Instant | 2 hr | Low |
| **Tailor claims job** | S08→S09 | 0-60 min | 3 hr | **HIGH** |
| Kitting + tube prep | S09→S10 | 15 min | 3.25 hr | Low |
| Bike courier dispatch | S10→S11 | Booking: 10 min | 3.5 hr | Low |
| **Transit to tailor** | S11→S12 | 30-90 min | 5 hr | **Medium** |

**Subtotal: 3 hours (5 hr cumulative)**

---

### Phase 3: Manufacturing

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Pattern unroll + fabric pull | S12 | 15 min | 5.25 hr | Low |
| Fabric cutting | S12 | 30-45 min | 6 hr | **Medium** |
| Canvas/fusing | S13 | 30 min | 6.5 hr | Low |
| Body assembly | S13 | 90 min | 8 hr | **Medium** |
| Sleeve setting | S13 | 45 min | 8.75 hr | **Medium** |
| Collar and lapel | S13 | 45 min | 9.5 hr | **Medium** |
| Trouser construction | S13 | 60 min | 10.5 hr | Low |
| Hand finishing (buttonholes, buttons) | S13 | 45 min | 11.25 hr | **Medium** |
| Final press | S13→S14 | 30 min | 11.75 hr | Low |

**Subtotal: 6.75 hours (11.75 hr cumulative)**

---

### Phase 4: QC Collection

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Tailor marks complete | S14 | Instant | 11.75 hr | Low |
| **Inspector/runner assigned** | S14→S15 | 0-30 min | 12.25 hr | **Medium** |
| **Runner travels to tailor** | S15 | 20-60 min | 13 hr | **Medium** |
| QC inspection | S15→S16/S17 | 15-30 min | 13.5 hr | **HIGH** |
| **Runner returns to HQ** | S16→S18 | 20-60 min | 14.25 hr | **Medium** |

**Subtotal: 2.5 hours (14.25 hr cumulative)**

---

### Phase 5: HQ Processing

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| HQ receipt + logging | S18→S19 | 5 min | 14.5 hr | Low |
| **Rack queue (waiting)** | S19 | 0-60 min | 15.5 hr | **HIGH** |
| Final inspection | S19 | 5 min | 15.6 hr | Low |
| Touch-up press | S19 | 10 min | 15.75 hr | Low |
| Premium packaging | S19 | 10 min | 15.9 hr | Low |
| Documentation | S19 | 5 min | 16 hr | Low |

**Subtotal: 1.75 hours (16 hr cumulative)**

---

### Phase 6: Transport to Airport

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Batch consolidation | - | 0-30 min | 16.5 hr | **Medium** |
| **HQ to ATQ airport** | - | 30-60 min | 17.25 hr | **Medium** |
| India export customs | - | 30-60 min | 18 hr | **Medium** |
| Aircraft loading | - | 30 min | 18.5 hr | Low |

**Subtotal: 2.5 hours (18.5 hr cumulative)**

---

### Phase 7: Flight + UAE Arrival

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| Flight (inc. fuel stop) | S20 | 5-5.5 hr | 24 hr | Low |
| UAE customs clearance | - | 1-2 hr | 25.5 hr | **HIGH** |
| Suit sorting/dispatch | - | 30 min | 26 hr | Low |

**Subtotal: 7.5 hours (26 hr cumulative)**

---

### Phase 8: Final Mile UAE

| Stage | State | Duration | Cumulative | Risk Level |
|-------|-------|----------|------------|------------|
| **Delivery to customer** | S20→S21 | 1-4 hr | 28 hr | **HIGH** |

**Subtotal: 1-4 hours (28 hr cumulative)**

---

## Total Timeline

| Scenario | Duration |
|----------|----------|
| **Best case (everything flows)** | 22 hours |
| **Realistic** | 26-28 hours |
| **With one hiccup** | 30+ hours |

**You're 2-6 hours over your 24-hour promise in realistic conditions.**

---

## Danger Points Ranked

### Critical (Can Break the 24hr Promise)

| Stage | Risk | Impact | Mitigation |
|-------|------|--------|------------|
| **Tailor claiming delay** | Job sits unclaimed 1+ hours | +1-2 hr | Auto-assign to next available, dual-posting |
| **QC fail** | Rework adds 3-6 hours minimum | +3-6 hr | Better tailor training, pre-inspection checklist |
| **UAE customs delay** | Unpredictable clearance times | +1-4 hr | Pre-clearance, bonded warehouse, dedicated broker |
| **Final mile delivery** | Dubai traffic, building access | +1-3 hr | Multiple delivery teams, hotel concierge pre-coordination |
| **Rack queue at HQ** | Packing bottleneck during peak | +1 hr | Increase packing stations from 6 to 10 |

### High (Compounding Delays)

| Stage | Risk | Impact | Mitigation |
|-------|------|--------|------------|
| **Runner collection routing** | Tailors spread across city | +30-60 min | Zone-based tailor clustering |
| **Bike courier to tailor** | Traffic, availability | +30 min | Pre-booked courier slots, dedicated riders |
| **Manufacturing variance** | Complex construction, tailor skill | +1-2 hr | Skill-matched job allocation |
| **Transport HQ to airport** | Distance, traffic | +30 min | HQ location near airport |

### Medium (Manageable)

| Stage | Risk | Impact | Mitigation |
|-------|------|--------|------------|
| Scan quality | Requires manual review | +30 min | Better scan guidance UI |
| Plotter queue | Machine breakdown | +1 hr | Redundant plotters (you have 3) |
| Fabric stock | Tailor doesn't have variant | +1 hr | Real-time inventory visibility |

---

## The Math Problem

Your 24-hour clock looks like this:

| Block | Hours | Status |
|-------|-------|--------|
| Order to pattern | 2 | Fixed |
| Pattern to tailor | 3 | Squeezable |
| Manufacturing | 6.75 | **Hard floor** |
| QC collection | 2.5 | Squeezable |
| HQ processing | 1.75 | Squeezable |
| Transport to airport | 2.5 | Fixed (geography) |
| Flight | 5.5 | Fixed |
| UAE customs | 1.5 | Variable |
| Final mile | 2 | Variable |
| **Total** | **27.5** | **3.5 hr over** |

---

## Where to Find 3.5 Hours

| Option | Time Saved | Feasibility |
|--------|------------|-------------|
| Move HQ closer to airport | 30 min | Medium-term |
| Pre-clear customs (bonded cargo) | 60 min | Requires setup |
| Parallel QC (inspector at tailor, not collection) | 60 min | Operational change |
| Reduce manufacturing buffer | 30-60 min | Rush bonus to tailors |
| Pre-staged final mile teams | 30-60 min | Cost increase |
| **Faster aircraft (B737 direct, no fuel stop)** | **60-90 min** | **Cost increase** |

---

## Revised Recommendation

To reliably hit 24 hours, you need either:

**Option A: Tighter operations (Saab, lower cost)**
- Parallel QC at tailor location (inspector travels, not suit)
- Pre-cleared bonded cargo
- HQ within 20 min of airport
- Dedicated final mile teams pre-positioned at Dubai hotels

**Option B: Faster aircraft (B737 direct, higher cost)**
- Eliminates 60-90 min fuel stop
- Costs ~£30,000 vs £17,000
- Only makes sense above 189 suits/day anyway

**Option C: Adjust the promise**
- Market as "same day delivery for orders before noon"
- 28-hour realistic window with buffer
- Underpromise, overdeliver

Which path aligns with your positioning?



## Prompt:
1/19/2026, 7:03:16 PM

so on danger points

QC failRework adds 3-6 hours minimum+3-6 hrBetter tailor training, pre-inspection checklist
(is there the margin at 8500INR to manufacture the suit twice with 2 different tailors for a backup production)

for Tailor claiming delayJob sits unclaimed 1+ hours+1-2 hrAuto-assign to next available, dual-posting
(we can use a voice AI to call all the tailors who are not working on our production already simultaneously after 10 mins on the jobs board unclaimed, in order to push the assign. By calling 20 tailors at a time this gets it assigned)

Bike courier to tailorTraffic, availability+30 minPre-booked courier slots, dedicated riders &Runner collection routingTailors spread across city+30-60 minZone-based tailor clustering
(in the new facility the qc station is a 10 minute run to all tailors)

Scan qualityRequires manual review+30 minBetter scan guidance UI
(the user can waste as much time with the scan as they pay after they have scanned, the payment triggers the clock)


Plotter queueMachine breakdown+1 hrRedundant plotters (you have 3)
(Need Research on the time requirement of the plotter cutter speed, but just buy more plotter cutters to manage the work, assume we buy 10 working concurrently)



now rerun the same 24 analysis



## Response:
1/19/2026, 7:04:17 PM

````plaintext
Thought process: Reconstructed 24-hour timeline incorporating dual production, voice AI assignment, and concurrent plotters.

The user wants me to rerun the 24-hour timeline analysis with their mitigations factored in:

1. QC fail - They're asking if there's margin to manufacture the suit twice with 2 different tailors as backup. I need to check if 8500 INR allows for this dual production.

2. Tailor claiming delay - They have a VAPI voice AI solution to call 20 tailors simultaneously after 10 mins unclaimed. This should reduce the claiming window significantly.

3. Bike courier + Runner collection - In the new facility, QC station is 10 min run to all tailors. This eliminates the courier and runner transit variability.

4. Scan quality - Payment triggers the clock, so scan time doesn't count against the 24hr promise.

5. Plotter queue - They'll buy 10 plotters working concurrently.

Let me also address the dual-production economics question. The user mentioned £1000 profit per suit. Let me think about the cost structure:

- Selling price: ~AED 20,000+ = ~£4,300+
- Profit: £1,000
- So cost to deliver: ~£3,300

Manufacturing cost at 8500 INR = ~£79

If they dual-produce:
- 2x manufacturing: 17,000 INR = ~£158
- That's only an additional £79 per suit
- Against a £1,000 margin, this is 7.9% insurance cost
- And they get a backup suit + quality comparison

This seems very feasible economically.

Now let me rebuild the timeline:

**Phase 1: Order to Pattern Ready**
- Order placed + payment: Instant (clock starts here, after scan is done)
- Translation Matrix + Optitex: 15-30 min
- Plotter queue + cutting: With 10 plotters, this should be near-instant for queue, just cutting time
  - Cutting time per suit: Need to estimate. 

Typical plotters cut at 1-2m/s. A full suit pattern might be 5-10 linear meters of cutting. So maybe 5-10 minutes per suit. With 10 plotters for 540 suits/day = 54 suits per plotter per day = about one every 15 minutes per plotter. Should have no queue. Let's say 15-30 min total for this phase

Subtotal: ~1 hour (down from 2)

**Phase 2: Pattern to Tailor**
- Job publishe d: Instant
- Tailor claims: With VAPI calling 20 tailors at 10 min mark, worst case is ~15 min
- Kitting + tube prep: 15 min
- Transit to tailor: In new facility with 10 min proximity, this is 10-15 min

Subtotal: ~45 min (down from 3 hr)

Cumulative: 1.75 hr

**Phase 3: Manufacturing (Dual Production)**
- Both tailors work in parallel
- Same 6.75 hours but with redundancy
- If one fails QC, the other is ready

Subtotal: 6.75 hr (same, but with backup)

Cumulative: 8.5 hr

**Phase 4: QC Collection**
- With QC station 10 min from all tailors:
- Tailor marks complete: Instant
- Tailor brings to QC station OR inspector goes to tailor: 10-15 min
- QC inspection: 15-30 min
- If fail, secon d tailor's suit moves forward while first gets reworked

Subtotal: ~40-50 min

Cumulative: ~9.25 hr

**Phase 5: Packaging & Dispatch**
- Packaging: 10-15 min
- Final QC check: 5 min
- Dispatch prep: 5 min

Subtotal: ~25 min

**Total Timeline: ~9.5-10 hours** (down from 11.5 hr baseline)

This assumes the new facility layout with co-located tailors and QC, plus parallel manufacturing. The redundancy means we're not blocked by a single tailor's failure.

Flight time is 5-5.5 hours, then UAE customs takes 1-2 hours (or 45 minutes with pre-clearance). Sorting adds another 30 minutes, bringing the cumulative time to 19-20.5 hours. Final delivery ranges from 1-4 hours depending on location, putting us at 20-24.5 hours total—essentially hitting the 24-hour target.
````

Let me check the economics on dual production first.

---

## Dual Production Economics

### Current Cost Structure

| Item | Cost (INR) | Cost (GBP) |
|------|------------|------------|
| Manufacturing (single) | 8,500 | ~£79 |
| Manufacturing (dual) | 17,000 | ~£158 |
| Additional cost | 8,500 | ~£79 |

### Against Your Margin

| Metric | Value |
|--------|-------|
| Profit per suit | £1,000 |
| Dual production insurance cost | £79 |
| Margin impact | **7.9%** |

**Yes, absolutely viable.** For £79 you get:
- Backup production if one fails QC
- Quality comparison between tailors
- Performance data for tailor ranking
- Timeline insurance

The second suit isn't waste either - it becomes inventory for size exchanges or can be sold as RTW.

---

## Revised 24-Hour Analysis

### Your Mitigations Applied

| Original Risk | Your Solution | Time Impact |
|---------------|---------------|-------------|
| Scan quality delay | Clock starts at payment, not scan | -30 min (removed from timeline) |
| Tailor claiming delay | VAPI calls 20 tailors at 10 min mark | -45 min |
| Plotter queue | 10 concurrent plotters | -30 min |
| Bike courier to tailor | New facility, 10 min proximity | -60 min |
| Runner collection | QC station 10 min from all tailors | -60 min |
| QC fail | Dual production | Eliminates 3-6 hr rework risk |

---

## Revised Timeline

### Phase 1: Order to Pattern Ready

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Payment captured (clock starts) | 0 | 0 | Scan already complete |
| Translation Matrix + Optitex | 15-20 min | 0.3 hr | Automated |
| Plotter cutting (10 machines) | 10-15 min | 0.5 hr | No queue, just cut time |

**Subtotal: 30 minutes**

---

### Phase 2: Pattern to Tailors (Dual)

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Job published x2 | Instant | 0.5 hr | Posted to 2 tailors simultaneously |
| VAPI auto-call if unclaimed | 10 min max | 0.7 hr | 20 tailors called in parallel |
| Tailor claims (both) | 5 min | 0.75 hr | First responders win |
| Kitting x2 | 15 min | 1 hr | Parallel prep |
| Transit to both tailors | 10 min | 1.15 hr | New facility proximity |

**Subtotal: 45 minutes (1.25 hr cumulative)**

---

### Phase 3: Manufacturing (Dual Production)

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Pattern unroll + fabric pull | 15 min | 1.4 hr | Both tailors |
| Fabric cutting | 30 min | 1.9 hr | Parallel |
| Canvas/fusing | 30 min | 2.4 hr | Parallel |
| Body assembly | 90 min | 3.9 hr | Parallel |
| Sleeve setting | 45 min | 4.65 hr | Parallel |
| Collar and lapel | 45 min | 5.4 hr | Parallel |
| Trouser construction | 60 min | 6.4 hr | Parallel |
| Hand finishing | 45 min | 7.15 hr | Parallel |
| Final press | 30 min | 7.65 hr | Parallel |

**Subtotal: 6.5 hours (7.75 hr cumulative)**

*Both suits complete simultaneously. First to finish goes to QC.*

---

### Phase 4: QC (At Facility)

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Tailor walks to QC station | 10 min | 7.9 hr | 10 min proximity |
| QC inspection | 20 min | 8.2 hr | Pass/fail |
| If fail: second suit arrives | 10 min | 8.5 hr | Backup ready |
| Second QC (if needed) | 20 min | 8.7 hr | Should pass |

**Subtotal: 30-60 minutes (8.25-8.75 hr cumulative)**

*Dual production means QC fail no longer breaks timeline.*

---

### Phase 5: HQ Processing

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Receipt + logging | 5 min | 8.8 hr | Digital |
| Rack queue | 15 min | 9.05 hr | Reduced with capacity |
| Final inspection | 5 min | 9.15 hr | Quick visual |
| Touch-up press | 10 min | 9.3 hr | Standard |
| Premium packaging | 10 min | 9.45 hr | Standard |
| Documentation | 5 min | 9.55 hr | Pre-printed |

**Subtotal: 50 minutes (9.5 hr cumulative)**

---

### Phase 6: Transport to Airport

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Batch consolidation | 20 min | 9.85 hr | Rolling batches |
| HQ to ATQ airport | 30 min | 10.35 hr | Facility near airport |
| India export customs | 45 min | 11.1 hr | Pre-filed docs |
| Aircraft loading | 20 min | 11.45 hr | Pre-staged |

**Subtotal: 2 hours (11.5 hr cumulative)**

---

### Phase 7: Flight + UAE Arrival

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Flight (Saab, fuel stop) | 5.5 hr | 17 hr | Fixed |
| UAE customs | 60 min | 18 hr | Pre-cleared/bonded |
| Sorting/dispatch | 20 min | 18.35 hr | Pre-labelled |

**Subtotal: 7 hours (18.5 hr cumulative)**

---

### Phase 8: Final Mile UAE

| Stage | Duration | Cumulative | Notes |
|-------|----------|------------|-------|
| Delivery to customer | 2-3 hr | 21 hr | Pre-positioned teams |

**Subtotal: 2.5 hours (21 hr cumulative)**

---

## Revised Total

| Scenario | Duration | Buffer |
|----------|----------|--------|
| **Best case** | 19.5 hours | +4.5 hr buffer |
| **Realistic** | 21 hours | +3 hr buffer |
| **With one hiccup** | 23 hours | +1 hr buffer |
| **Two hiccups** | 24-25 hours | At limit |

---

## Before vs After

| Phase | Original | Revised | Saved |
|-------|----------|---------|-------|
| Order to pattern | 2 hr | 0.5 hr | 1.5 hr |
| Pattern to tailor | 3 hr | 0.75 hr | 2.25 hr |
| Manufacturing | 6.75 hr | 6.5 hr | 0.25 hr |
| QC collection | 2.5 hr | 0.75 hr | 1.75 hr |
| HQ processing | 1.75 hr | 0.85 hr | 0.9 hr |
| Transport to airport | 2.5 hr | 2 hr | 0.5 hr |
| Flight + UAE | 7.5 hr | 7 hr | 0.5 hr |
| Final mile | 3 hr | 2.5 hr | 0.5 hr |
| **Total** | **29 hr** | **21 hr** | **8 hr** |

---

## Remaining Risks

| Risk | Probability | Impact | Mitigation Status |
|------|-------------|--------|-------------------|
| Both tailors fail QC | Very low | +3 hr | Accept risk or triple-post |
| Flight delay/cancellation | Low | +6-24 hr | Backup commercial runners |
| UAE customs hold | Low | +2-4 hr | Broker relationship |
| Dubai traffic (final mile) | Medium | +1-2 hr | Multiple delivery windows |
| Tailor capacity (all busy) | Medium at peak | +1 hr | Larger tailor network |

---

## The New Bottleneck

With your mitigations, **manufacturing is now the hard floor at 6.5 hours**. Everything else has slack.

Your 24-hour promise is now achievable with a 3-hour realistic buffer.

---

## Cost Summary (Per Suit at Full Capacity)

| Item | Cost |
|------|------|
| Dual manufacturing | £158 |
| Saab charter (540 suits, 2 flights) | £63 |
| Final mile UAE | ~£15-20 |
| **Total logistics + production** | ~£240 |
| **Remaining margin** | **£760** |

Does this revised model hold up against your operational assumptions?



## Prompt:
1/19/2026, 7:08:17 PM

ok lets look at for distribution in uae if its possible on the saab if its possible to drop off consignments at different location in uae from the same plane



## Response:
1/19/2026, 7:09:05 PM

````plaintext
Thought process: Evaluated multi-stop cargo distribution feasibility across UAE airports.

The user is asking about multi-stop distribution within the UAE from a single Saab 340F flight. This is an interesting logistics question - can they land at multiple UAE airports to distribute suits to different regions rather than landing at one airport and doing ground distribution from there?

Let me think about this:

1. UAE airports that could receive cargo:
- Dubai (DXB, DWC)
- Abu Dhabi (AUH)
- Sharjah (SHJ)
- Ras Al Khaimah (RKT)
- Fujairah (FJR)
- Al Ain (AAN)

2. The question is whether it makes sense to do multiple stops vs. single landing + ground distribution

3. Factors to consider:
- Landing fees at each airport
- Customs clearance at each stop
- Time added per stop
- Ground distribution time saved
- UAE is geographically small

I should search for UAE airport information and distances to give a proper analysis.
````

Let me check UAE airport options and distances.

````plaintext
Web Search: UAE airports cargo freight Dubai Abu Dhabi Sharjah Al Maktoum distances
````

> **UAE International Airports | Airports in UAE | Emirates Airport** [memphistours.com](https://www.memphistours.com/dubai/emirates-travel-guide/international-airports-in-uae)
>
> **How Many Airports are There in Dubai: Which to Choose and What's the Difference** [dreams-estate.com](https://dreams-estate.com/blog/everything-about-the-uae/airports-in-dubai/)
>
> **Dubai International Airport - Wikipedia** [wikipedia.org](https://en.wikipedia.org/wiki/Dubai_International_Airport)
>
> **List of airports in the United Arab Emirates - Wikipedia** [wikipedia.org](https://en.wikipedia.org/wiki/List_of_airports_in_the_United_Arab_Emirates)
>
> **Airports and airlines in the United Arab Emirates** [worlddata.info](https://www.worlddata.info/asia/arab-emirates/airports.php)
>
> **Al Maktoum International Airport - Wikipedia** [wikipedia.org](https://en.wikipedia.org/wiki/Al_Maktoum_International_Airport)
>
> **U.A.EInternational Cargo Airports | Flight between China | Goodhope Freight** [goodhopefreight.com](https://goodhopefreight.com/cargo-airports/uae.html)
>
> **Al Maktoum International Airport | Dubai World Central | DWC Airport** [memphistours.com](https://www.memphistours.com/dubai/emirates-travel-guide/international-airports-in-uae/wiki/al-maktoum-international-airport-dwc-airport)
>
> **List Airports in UAE (2024 Updated)** [holidify.com](https://www.holidify.com/pages/airports-in-uae-2073.html)
>
> **Sharjah International Airport | Sharjah Airport** [memphistours.com](https://www.memphistours.com/dubai/emirates-travel-guide/international-airports-in-uae/wiki/sharjah-international-airport)
>
````plaintext
Thought process: Weighed multi-stop distribution feasibility against ground logistics costs.

Good info on UAE airports. Now let me think about the multi-stop analysis:

UAE Airports:
- Dubai International (DXB) - main hub, 5km from Dubai city
- Al Maktoum/Dubai World Central (DWC) - 37km from Dubai, cargo-focused
- Sharjah (SHJ) - 39km from Dubai, 3rd largest ME cargo hub
- Abu Dhabi (AUH) - 116km from Dubai
- Ras Al Khaimah (RKT) - furthest north
- Fujairah (FJR) - east coast
- Al Ain (AAN) - 18km from Al Ain city

The key question is: does multi-stop make sense vs. single airport + ground distribution?

UAE is geographically compact:
- Dubai to Abu Dhabi: ~116km (1-1.5hr drive)
- Dubai to Sharjah: ~39km (30-45min drive)
- The entire UAE is only ~650km long

Each additional landing would add:
- Landing fees
- Handling fees
- Customs clearance (potentially at each stop)
- Ground time (30-60 min per stop)
- Flight time between airports (minimal - 15-20 min max)

Let me analyze if this makes sense.
````

Good data. Let me map this out.

---

## UAE Airport Geography

| Airport | Code | Distance from Dubai | Primary Use |
|---------|------|---------------------|-------------|
| Dubai International | DXB | 5 km (city center) | Passenger hub |
| Al Maktoum/Dubai World Central | DWC | 37 km south | Cargo-focused |
| Sharjah | SHJ | 39 km north | 3rd largest ME cargo hub |
| Abu Dhabi | AUH | 116 km southwest | Etihad hub |
| Ras Al Khaimah | RKT | 100 km north | Regional |
| Fujairah | FJR | 130 km east | East coast |
| Al Ain | AAN | 150 km southeast | Regional |

---

## UAE Scale Context

The entire UAE is only **650 km long**. For comparison, that's Birmingham to London and back.

| Route | Distance | Drive Time |
|-------|----------|------------|
| Dubai to Abu Dhabi | 116 km | 1-1.5 hr |
| Dubai to Sharjah | 39 km | 30-45 min |
| Dubai to Ras Al Khaimah | 100 km | 1 hr |
| Dubai to Fujairah | 130 km | 1.5 hr |
| Sharjah to Abu Dhabi | 140 km | 1.5 hr |

---

## Multi-Stop Analysis

### Cost Per Additional Landing

| Item | Cost (estimate) |
|------|-----------------|
| Landing fee | $500-1,500 |
| Handling fee | $800-2,000 |
| Parking (if any) | $200-500 |
| Fuel (minimal for short hop) | $500 |
| **Per-stop overhead** | **$2,000-4,500** |

Plus: potential separate customs clearance at each stop (major unknown).

### Time Per Additional Stop

| Activity | Duration |
|----------|----------|
| Approach and landing | 15 min |
| Taxi to cargo area | 10 min |
| Partial unload | 30-45 min |
| Paperwork/clearance | 30-60 min |
| Taxi and takeoff | 15 min |
| **Per-stop time** | **1.5-2.5 hours** |

---

## Scenario Comparison

### Option A: Single Airport (Sharjah) + Ground Distribution

| Stage | Time | Cost |
|-------|------|------|
| Land at SHJ | - | Landing/handling: £2,500 |
| Customs clearance | 1 hr | Broker: £500 |
| Sort and dispatch | 30 min | - |
| Van to Dubai hotels | 45 min | £100 |
| Van to Abu Dhabi hotels | 1.5 hr | £200 |
| Van to RAK hotels | 1 hr | £150 |
| **Total delivery window** | **2.5 hr max** | **~£3,500** |

### Option B: Multi-Stop (SHJ → DXB → AUH)

| Stage | Time | Cost |
|-------|------|------|
| Land at SHJ, partial unload | 1.5 hr | £2,500 |
| Hop to DXB, partial unload | 1.5 hr | £3,000 |
| Hop to AUH, final unload | 1.5 hr | £3,500 |
| **Total** | **4.5 hr** | **~£9,000** |

Then still need ground delivery from each airport to hotels.

---

## The Verdict

**Multi-stop does not make sense.**

| Factor | Single Airport | Multi-Stop |
|--------|----------------|------------|
| Time | 2.5 hr to all UAE | 4.5+ hr |
| Cost | ~£3,500 | ~£9,000 |
| Customs | One clearance | Potentially 3 |
| Complexity | Low | High |
| Risk points | 1 | 3 |

The UAE is too geographically compact. Ground distribution from a single cargo-friendly airport beats air-hopping.

---

## Optimal Single-Airport Choice

| Airport | Pros | Cons |
|---------|------|------|
| **Sharjah (SHJ)** | 3rd largest ME cargo hub, lower fees than DXB, 39km to Dubai, cargo-focused infrastructure | Slightly further from Abu Dhabi |
| DWC (Al Maktoum) | Cargo-designed, lower congestion | 37km from Dubai center, still developing |
| DXB | Closest to Dubai hotels | Most expensive, congested, passenger-focused |
| AUH | Good for Abu Dhabi deliveries | 116km from Dubai (your main market) |

**Recommendation: Sharjah (SHJ)**

- Cargo-optimised airport
- Lower landing/handling fees than DXB
- Central position for ground distribution
- 30-45 min to Dubai hotels
- 1.5 hr to Abu Dhabi hotels
- Established cargo customs processes

---

## Ground Distribution Model from SHJ

### Fleet Requirement

| Delivery Zone | Distance | Time | Suits/Run |
|---------------|----------|------|-----------|
| Dubai hotels | 39 km | 45 min | 50-100 |
| Sharjah hotels | 10 km | 15 min | 20-30 |
| Abu Dhabi hotels | 140 km | 1.5 hr | 30-50 |
| RAK/Northern | 60 km | 1 hr | 10-20 |

### Daily Distribution (540 suits)

Assuming 80% Dubai, 15% Abu Dhabi, 5% other:

| Zone | Suits | Runs Needed | Vehicles |
|------|-------|-------------|----------|
| Dubai | 432 | 5-8 | 2-3 vans |
| Abu Dhabi | 81 | 2 | 1 van |
| Other | 27 | 1 | 1 van |
| **Total** | **540** | **8-11** | **4-5 vans** |

---

## Revised Final Mile Cost

| Item | Daily Cost |
|------|------------|
| 5 vans + drivers | £400-500 |
| Fuel | £100-150 |
| Hotel delivery teams (tips, access) | £100-200 |
| **Total** | **£600-850/day** |

At 540 suits: **£1.10-1.60 per suit** for UAE ground distribution.

---

## Complete Revised Logistics Cost Stack

| Component | Cost/Suit |
|-----------|-----------|
| Dual manufacturing | £158 |
| Saab charter (2 flights, 540 suits) | £63 |
| SHJ landing/handling/customs | £6 |
| UAE ground distribution | £1.50 |
| **Total** | **£228.50** |
| **Remaining margin** | **£771.50** |

Does SHJ as the single hub work for your hotel coverage map?



## Prompt:
1/19/2026, 7:10:32 PM

ok between SHJ and DWC is there anywhere we cant deliver to in the window in the UAE?



## Response:
1/19/2026, 7:11:11 PM

````plaintext
Thought process: Analyzed UAE geography and delivery feasibility from both airports.

The user wants to know if there are any locations in the UAE that can't be reached within the delivery window from either Sharjah (SHJ) or Dubai World Central (DWC) airports.

Let me think about the geography of the UAE and the most remote locations from these two airports.

The UAE is roughly 650km long. The main population centers are:
- Dubai (central)
- Abu Dhabi (southwest)
- Sharjah (north of Dubai)
- Ajman (north of Sharjah)
- Umm Al Quwain (further north)
- Ras Al Khaimah (far north)
- Fujairah (east coast)
- Al Ain (inland, southeast near Oman border)

From SHJ (northern Dubai area):
- Dubai: 30-45 min
- Abu Dhabi: 1.5 hr
- Ras Al Khaimah: 1 hr
- Fujairah: 1.5-2 hr
- Al Ain: 2-2.5 hr

From DWC (southern Dubai, Jebel Ali area):
- Dubai center: 45 min
- Abu Dhabi: 1 hr (closer than from SHJ)
- Sharjah: 1 hr
- Ras Al Khaimah: 1.5 hr
- Fujairah: 2 hr
- Al Ain: 2 hr

The most remote locations would be:
- Al Ain (inland city near Oman border)
- Fujairah (east coast, other side of mountains)
- Remote areas in Ras Al Khaimah or the interior

Let me think about what the delivery window is. From the earlier analysis, after landing and customs clearance, they have about 2-3 hours for final mile delivery to stay within 24 hours total.

So the question is: can any location in the UAE be reached within 2-3 hours from SHJ or DWC?


Given the UAE's compact size, most major cities and hotels fall within the 2-3 hour window from at least one airport. Even the furthest destinations like Fujairah and Al Ain are reachable in 2-2.5 hours, which fits the available delivery window. I should map out the specific coverage to show the user exactly which areas are accessible.
````

Let me map the coverage from both airports.

---

## UAE Coverage Analysis

### Distance from Each Airport

| Destination | From SHJ | From DWC |
|-------------|----------|----------|
| Dubai Marina/JBR | 50 km / 45 min | 25 km / 25 min |
| Downtown Dubai/Burj Khalifa | 40 km / 40 min | 40 km / 35 min |
| Dubai Creek/Deira | 20 km / 20 min | 55 km / 50 min |
| Palm Jumeirah | 55 km / 50 min | 30 km / 30 min |
| Sharjah City | 10 km / 15 min | 65 km / 55 min |
| Ajman | 20 km / 25 min | 75 km / 1 hr |
| Umm Al Quwain | 45 km / 40 min | 100 km / 1.25 hr |
| Ras Al Khaimah | 85 km / 1 hr | 120 km / 1.5 hr |
| Abu Dhabi City | 150 km / 1.5 hr | 80 km / 1 hr |
| Abu Dhabi Saadiyat/Yas | 140 km / 1.5 hr | 70 km / 50 min |
| Al Ain | 160 km / 2 hr | 130 km / 1.5 hr |
| Fujairah | 120 km / 1.5 hr | 170 km / 2 hr |
| Liwa Oasis | 280 km / 3 hr | 210 km / 2.5 hr |
| Sir Bani Yas Island | 300 km / 3.5 hr+ | 230 km / 3 hr |

---

## Your Delivery Window

From revised timeline:
- Land and clear customs: 1.5 hr
- Sort and dispatch: 30 min
- **Remaining window for delivery: ~2.5-3 hours**

---

## Coverage Map

### Within 2-Hour Drive (Comfortable)

| From SHJ | From DWC |
|----------|----------|
| All Dubai | All Dubai |
| Sharjah | Sharjah |
| Ajman | Ajman |
| Umm Al Quwain | Umm Al Quwain |
| Ras Al Khaimah | Abu Dhabi City |
| - | Saadiyat/Yas Island |

### 2-2.5 Hour Drive (Tight but Doable)

| From SHJ | From DWC |
|----------|----------|
| Abu Dhabi City | Ras Al Khaimah |
| Saadiyat/Yas | Al Ain |
| Al Ain | Fujairah |
| Fujairah | - |

### Over 2.5 Hours (Risk Zone)

| Location | From SHJ | From DWC | Notes |
|----------|----------|----------|-------|
| Liwa Oasis | 3 hr | 2.5 hr | Desert, minimal hotels |
| Sir Bani Yas Island | 3.5 hr + ferry | 3 hr + ferry | Island resort |
| Madinat Zayed | 2.5 hr | 2 hr | Western region |
| Remote RAK mountains | 2+ hr | 2.5+ hr | Adventure resorts |

---

## Problem Destinations

### Genuinely Difficult

| Location | Issue | Realistic? |
|----------|-------|------------|
| **Sir Bani Yas Island** | Ferry required, 3+ hr total | Low volume, schedule around ferry times |
| **Liwa Oasis** | Deep desert, 2.5-3 hr | Very few luxury hotels |
| **Remote mountain resorts** | Winding roads, 2+ hr | Niche market |

### Tight But Manageable

| Location | Time from Best Airport | Solution |
|----------|------------------------|----------|
| Al Ain | 1.5 hr from DWC | Use DWC for these orders |
| Fujairah | 1.5 hr from SHJ | Use SHJ for these orders |
| Far RAK | 1 hr from SHJ | Use SHJ |
| Far Abu Dhabi | 1 hr from DWC | Use DWC |

---

## The Strategic Answer

**From SHJ alone:** 95% of UAE luxury hotel market covered within 2 hours

**From DWC alone:** 95% of UAE luxury hotel market covered within 2 hours

**Combined SHJ + DWC:** 99% coverage within 2 hours

---

## Dual Airport Option

If you split consignments by destination:

| Order Destination | Route To |
|-------------------|----------|
| Dubai North (Deira, Creek) | SHJ |
| Dubai South (Marina, Palm) | DWC |
| Sharjah, Ajman, UAQ, RAK | SHJ |
| Abu Dhabi, Al Ain | DWC |
| Fujairah | SHJ (shorter mountain route) |

### Operational Complexity

| Model | Pros | Cons |
|-------|------|------|
| Single airport (SHJ) | One customs clearance, simpler ops | Longer runs to Abu Dhabi |
| Single airport (DWC) | Better Abu Dhabi coverage | Longer runs to Northern Emirates |
| Split by destination | Optimal coverage | Two customs clearances, sorting in Amritsar, coordination |

---

## Actual Gaps

**Locations you genuinely cannot serve in 24 hours:**

| Location | Reason | Volume Impact |
|----------|--------|---------------|
| Sir Bani Yas Island | Ferry + 3 hr drive | ~0.1% of market |
| Remote Liwa desert camps | 3+ hr drive | ~0.1% of market |

**That's it.** 

The UAE is small enough that 99.8% of the luxury hotel market is reachable within your delivery window from either airport.

---

## Recommendation

**Start with SHJ single-hub model.** 

- Covers your primary Dubai/Sharjah expo market easily
- Abu Dhabi runs at 1.5 hr are within window
- Lower fees than DXB
- Cargo-optimised

**Consider DWC if:**
- Abu Dhabi volume grows significantly
- DWC offers better charter rates (cargo-focused airport)
- You want to avoid SHJ congestion during peak

Do you want me to map the specific luxury hotels against delivery zones to validate coverage of your target properties (Burj Al Arab, Atlantis, Four Seasons, etc.)?



## Prompt:
1/19/2026, 7:11:39 PM

does abu dhabi have an airport?



## Response:
1/19/2026, 7:11:56 PM

````plaintext
Thought process: Recognized oversight and corrected airport identification.

The user is asking a straightforward question - does Abu Dhabi have an airport? Yes, it does - Abu Dhabi International Airport (AUH). I mentioned it in my earlier search results and table but didn't include it as a potential hub option, which was an oversight. Let me correct that.
````

Yes. I overlooked it as a hub option.

---

## Abu Dhabi International Airport (AUH)

| Metric | Value |
|--------|-------|
| Code | AUH |
| Location | 30 km from Abu Dhabi city center |
| Distance to Dubai | 116 km / 1-1.5 hr |
| Primary airline | Etihad Airways |
| Cargo capacity | Major hub, 2,400 hectares |
| Status | New Terminal A opened Nov 2023 (80m pax capacity) |

---

## Revised Three-Airport Comparison

| Airport | To Dubai Center | To Abu Dhabi Center | To RAK | Cargo Focus | Fees |
|---------|-----------------|---------------------|--------|-------------|------|
| **SHJ** | 40 km / 40 min | 150 km / 1.5 hr | 85 km / 1 hr | High | Lower |
| **DWC** | 40 km / 35 min | 80 km / 1 hr | 120 km / 1.5 hr | High | Lower |
| **AUH** | 116 km / 1.25 hr | 30 km / 25 min | 200 km / 2 hr | Medium | Medium |

---

## Coverage from AUH

| Destination | Distance | Time |
|-------------|----------|------|
| Abu Dhabi City hotels | 30 km | 25 min |
| Saadiyat Island | 25 km | 20 min |
| Yas Island | 10 km | 10 min |
| Sir Bani Yas Island | 200 km + ferry | 2.5 hr |
| Al Ain | 140 km | 1.5 hr |
| Dubai | 116 km | 1.25 hr |
| Sharjah | 140 km | 1.5 hr |
| RAK | 200 km | 2 hr |

---

## If Your Order Split Looks Like This:

| Region | % of Orders | Best Airport |
|--------|-------------|--------------|
| Dubai | 70% | SHJ or DWC |
| Abu Dhabi | 20% | **AUH** |
| Northern Emirates | 10% | SHJ |

Then a **dual-hub model (SHJ + AUH)** could make sense:

- SHJ handles Dubai + Northern Emirates (80%)
- AUH handles Abu Dhabi + Al Ain + Western region (20%)

---

## Dual-Hub Economics

| Model | Charter Cost | Customs Clearances | Ground Fleet |
|-------|--------------|-------------------|--------------|
| Single SHJ | £17,000 x 2 = £34,000 | 2/day | 5 vans |
| SHJ + AUH split | Needs different aircraft or routing | 4/day | 6 vans (split) |

The question becomes: is the Abu Dhabi volume high enough to justify splitting the operation, or is a 1.5 hr drive from SHJ acceptable for 20% of orders?

What's your expected Abu Dhabi vs Dubai order ratio during expo season?



## Prompt:
1/19/2026, 7:33:26 PM

Abu Dhabi finance week will be huge



## Response:
1/19/2026, 7:34:06 PM

````plaintext
Thought process: Reconsidered hub strategy around concentrated demand surges.

The user is pointing out that Abu Dhabi Finance Week will be a major event driving significant order volume from Abu Dhabi. This changes the calculus - if Abu Dhabi has concentrated high-volume periods, they might need a more flexible approach.

Let me think about this:

1. During Abu Dhabi Finance Week, the order ratio might flip - maybe 60-70% Abu Dhabi, 30-40% Dubai
2. This suggests they need the ability to switch primary hub based on where the demand is
3. Or run dual hubs during peak Abu Dhabi events
4. Or route the Saab to AUH instead of SHJ during these periods

Let me explore the options for event-driven hub switching.
````

That changes the calculus. Let me look at this event-driven.

---

## Event-Driven Demand Pattern

| Event | Location | Expected Volume Split |
|-------|----------|----------------------|
| Dubai Expo season | Dubai | 80% Dubai / 20% Abu Dhabi |
| Abu Dhabi Finance Week | Abu Dhabi | 30% Dubai / 70% Abu Dhabi |
| Abu Dhabi F1 (Yas Marina) | Abu Dhabi | 40% Dubai / 60% Abu Dhabi |
| Art Abu Dhabi | Abu Dhabi | 35% Dubai / 65% Abu Dhabi |
| Dubai Shopping Festival | Dubai | 85% Dubai / 15% Abu Dhabi |
| Ramadan/Eid | Mixed | 50/50 |

---

## The Problem with Fixed Hub

If you're locked into SHJ during Abu Dhabi Finance Week:

| Order Origin | Delivery Route | Time |
|--------------|----------------|------|
| Abu Dhabi hotel measurement | Suit made in Amritsar | - |
| Lands at SHJ | - | - |
| Drives to Abu Dhabi | 150 km | 1.5 hr |
| **Total final mile** | - | **2+ hr** |

That eats your buffer on a day when 70% of orders need that long run.

---

## Flexible Hub Model

**Switch primary airport based on event calendar:**

| Period | Primary Hub | Secondary Coverage |
|--------|-------------|-------------------|
| Dubai-heavy events | SHJ | Van run to Abu Dhabi |
| Abu Dhabi-heavy events | AUH | Van run to Dubai |
| Mixed demand | Either (or split) | Cross-coverage |

---

## Saab Routing Options

### Option A: Single Destination (Switchable)

| Event Type | Route | Hub |
|------------|-------|-----|
| Dubai events | ATQ → (fuel) → SHJ | SHJ |
| Abu Dhabi events | ATQ → (fuel) → AUH | AUH |

Same aircraft, same cost, just different endpoint.

### Option B: Two-Stop Same Flight

| Leg | Time | Notes |
|-----|------|-------|
| ATQ → (fuel stop) | 2.5 hr | Muscat or similar |
| Fuel stop → AUH | 1.5 hr | Drop Abu Dhabi consignment |
| AUH → SHJ | 30 min | Drop Dubai/Northern consignment |
| **Total flight time** | **4.5 hr** | vs 5.5 hr single destination |

Wait - AUH to SHJ is only **150 km**. That's a 20-30 minute hop.

---

## Revised Multi-Stop Analysis (AUH + SHJ)

### Intra-UAE Hop

| Leg | Distance | Flight Time |
|-----|----------|-------------|
| AUH to SHJ | 150 km | 25-30 min |
| AUH to DWC | 80 km | 15-20 min |
| SHJ to AUH | 150 km | 25-30 min |

This is not like hopping between countries. It's essentially a repositioning flight.

### Cost of Intra-UAE Stop

| Item | Cost |
|------|------|
| Additional landing (AUH) | £1,000-1,500 |
| Handling (AUH) | £800-1,200 |
| Fuel (minimal) | £200 |
| Customs (if pre-cleared as single shipment) | May not duplicate |
| **Additional cost per stop** | **£2,000-3,000** |

---

## Dual-Drop Route

**ATQ → Fuel Stop → AUH → SHJ**

| Stage | Time | Cumulative |
|-------|------|------------|
| ATQ to fuel stop | 2.5 hr | 2.5 hr |
| Fuel stop ground time | 45 min | 3.25 hr |
| Fuel stop to AUH | 2 hr | 5.25 hr |
| AUH unload (Abu Dhabi suits) | 45 min | 6 hr |
| AUH to SHJ | 25 min | 6.4 hr |
| SHJ unload (Dubai suits) | 45 min | 7.15 hr |
| **Total** | - | **7.25 hr** |

vs single destination: **5.5 hr**

**Added time for dual-drop: 1.75 hr**

---

## Economics Comparison

### Single Hub (Event-Switched)

| Metric | Value |
|--------|-------|
| Charter cost | £17,000 |
| Ground distribution (longer runs) | £850 |
| **Total** | **£17,850** |

### Dual-Drop (AUH then SHJ)

| Metric | Value |
|--------|-------|
| Charter cost | £17,000 |
| Additional AUH stop | £2,500 |
| Ground distribution (shorter runs) | £500 |
| **Total** | **£20,000** |

**Premium for dual-drop: ~£2,150/flight**

---

## When Dual-Drop Makes Sense

Break-even calculation:

| Factor | Single Hub | Dual-Drop |
|--------|------------|-----------|
| Flight cost | £17,000 | £19,500 |
| Ground (Abu Dhabi run from SHJ) | £200 per van x 3 runs = £600 | £100 per van x 1 run = £100 |
| Time risk (1.5hr runs eating buffer) | High on AD-heavy days | Low |

**If Abu Dhabi volume exceeds ~100 suits/flight**, dual-drop saves ground costs and protects your 24-hour window.

---

## Abu Dhabi Finance Week Model

| Flight | Route | Abu Dhabi Drop | Dubai Drop |
|--------|-------|----------------|------------|
| Morning | ATQ → Fuel → AUH → SHJ | 180 suits | 90 suits |
| Afternoon | ATQ → Fuel → AUH → SHJ | 180 suits | 90 suits |
| **Daily** | - | **360 suits** | **180 suits** |

Cost: £40,000/day (2 x £20,000)
At 540 suits: **£74/suit**

vs single hub at £63/suit - you're paying an extra **£11/suit** for the dual-drop during Abu Dhabi events.

On £1,000 margin, that's 1.1%. Acceptable for operational security.

---

## Recommendation

| Demand Pattern | Model | Cost/Suit |
|----------------|-------|-----------|
| Dubai-heavy (>70% Dubai) | Single hub SHJ | £63 |
| Abu Dhabi-heavy (>40% Abu Dhabi) | Dual-drop AUH→SHJ | £74 |
| Even split | Dual-drop AUH→SHJ | £74 |

**Build the operation to flex between both modes based on event calendar.**

Do you want me to map out the full Abu Dhabi Finance Week timeline against your production capacity?



## Prompt:
1/19/2026, 7:36:18 PM

i think what we need is an ai that can automate and analyse and organise the delivery on every suit based on calculating the fulfillment of every suit based on the logistics of all operators and resources and their deployment, a system that is smart enough to track every package and in real time respond to delivery challenges



## Response:
1/19/2026, 7:37:35 PM

````plaintext
Thought process: Architected real-time logistics optimization engine with dynamic routing capabilities.

The user is asking for an AI-powered logistics orchestration system that can:
1. Track every suit/package in real-time
2. Analyze and organize delivery based on all available resources
3. Calculate optimal fulfillment paths
4. Respond dynamically to delivery challenges

This is essentially a logistics AI/optimization engine. Let me think through what this system would need to do:

1. Real-time tracking of all suits through the pipeline
2. Dynamic routing decisions based on:
   - Order destination (Dubai vs Abu Dhabi vs other)
   - Current production status
   - Available transport options (runners vs charter)
   - Event calendars and demand patterns
   - Weather, traffic, flight delays
   - Resource availability (vans, drivers, tailors, QC inspectors)

3. Optimization across multiple variables:
   - Cost minimization
   - Time constraint satisfaction (24hr promise)
   - Resource utilization
   - Risk mitigation

4. Real-time response to:
   - QC failures
   - Flight delays
   - Traffic issues
   - Customs holds
   - Tailor availability changes

This is a significant technical undertaking. Let me outline the architecture and components needed.
````

This is the brain of the operation. Let me architect it.

---

## Logistics Orchestration Engine

### Core Function

Real-time decision-making across every suit from payment to delivery, optimizing for 24-hour guarantee while minimizing cost.

---

## Data Inputs (Live Feeds)

| Source | Data | Update Frequency |
|--------|------|------------------|
| Order system | New orders, destinations, deadlines | Real-time |
| Tailor app | Claim status, production progress, completion | Real-time |
| QC app | Pass/fail, timestamps | Real-time |
| Flight tracking | Charter position, delays, ETAs | Every 5 min |
| UAE ground fleet | Van GPS, capacity, availability | Every 1 min |
| Customs | Clearance status, holds | Real-time |
| Traffic APIs | Dubai/Abu Dhabi road conditions | Every 5 min |
| Weather | Fog, storms affecting flights/roads | Hourly |
| Event calendar | Demand patterns, hotel clusters | Daily |

---

## Decision Points

### Decision 1: Flight Allocation

**When:** Order enters packing queue

**Variables:**
- Order destination (Dubai/Abu Dhabi/other)
- Current flight manifest for next departure
- Remaining capacity on each flight
- Delivery deadline

**Logic:**
```
IF destination = Abu Dhabi region
  AND abu_dhabi_volume_today > 100
  AND next_flight_has_AUH_stop = false
    → FLAG: Consider dual-drop route
    
IF deadline - current_time < 18 hours
  AND next_flight_capacity < orders_waiting
    → ALERT: Capacity constraint, evaluate runner backup
```

---

### Decision 2: Hub Selection

**When:** Flight manifest closes (2 hours before departure)

**Variables:**
- Destination mix of manifest
- Ground resource availability at each hub
- Current traffic/weather at each hub

**Logic:**
```
abu_dhabi_ratio = abu_dhabi_orders / total_orders

IF abu_dhabi_ratio > 0.4
  → ROUTE: ATQ → Fuel → AUH → SHJ (dual-drop)
  → DEPLOY: 2 vans at AUH, 3 vans at SHJ
  
ELSE IF abu_dhabi_ratio > 0.2
  → EVALUATE: dual-drop cost vs ground run cost
  → SELECT: lower total cost option
  
ELSE
  → ROUTE: ATQ → Fuel → SHJ (single hub)
  → DEPLOY: 1 van for Abu Dhabi run, 4 vans Dubai
```

---

### Decision 3: Ground Assignment

**When:** Aircraft wheels down + customs cleared

**Variables:**
- Individual suit destinations (hotel addresses)
- Van current positions
- Real-time traffic
- Delivery time windows
- Hotel concierge availability

**Logic:**
```
FOR each suit in manifest:
  
  optimal_van = SELECT van WHERE:
    - van.current_capacity > 0
    - van.current_zone = suit.destination_zone 
      OR van.next_zone = suit.destination_zone
    - estimated_delivery_time < suit.deadline
    
  IF no_optimal_van:
    → DISPATCH: nearest available van
    → ALERT: Tight delivery window
    
  ASSIGN suit → optimal_van
  UPDATE van.route (re-optimize sequence)
```

---

### Decision 4: Dynamic Re-routing

**When:** Exception occurs

**Exception Types:**

| Exception | Detection | Response |
|-----------|-----------|----------|
| Flight delay >30 min | Flight tracker | Re-calculate all delivery windows, alert at-risk orders |
| Customs hold | Clearance system | Escalate to broker, notify affected customers |
| Van breakdown | GPS + driver app | Re-assign suits to other vans, dispatch backup |
| Traffic jam | Traffic API | Re-route van, re-sequence deliveries |
| Hotel access issue | Driver app | Contact concierge, hold for next window |
| QC fail (both suits) | QC app | Emergency production trigger, customer notification |

---

## System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    LOGISTICS BRAIN (AI Core)                     │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐              │
│  │  Optimizer  │  │  Predictor  │  │  Responder  │              │
│  │             │  │             │  │             │              │
│  │ Route calc  │  │ Demand      │  │ Exception   │              │
│  │ Cost min    │  │ forecast    │  │ handling    │              │
│  │ Time sat    │  │ Risk score  │  │ Re-routing  │              │
│  └─────────────┘  └─────────────┘  └─────────────┘              │
└─────────────────────────────────────────────────────────────────┘
          │                   │                   │
          ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                      REAL-TIME DATA LAYER                        │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────┤
│   Orders    │  Production │   Flight    │   Ground    │ External│
│   Queue     │   Status    │   Tracker   │   Fleet     │  APIs   │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────┘
          │                   │                   │
          ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                        ACTION LAYER                              │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────┤
│   Tailor    │     QC      │   Charter   │    Van      │ Customer│
│    App      │    App      │   Ops       │  Dispatch   │  Comms  │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────┘
```

---

## Suit-Level Tracking Object

Every suit carries a live state object:

```json
{
  "suit_id": "SUIT-2026-01-19-0847",
  "order_id": "ORD-xxxxx",
  "customer_id": "CUS-xxxxx",
  
  "destination": {
    "hotel": "Burj Al Arab",
    "address": "Jumeirah Beach Road, Dubai",
    "zone": "DUBAI-SOUTH",
    "coordinates": [25.1412, 55.1853],
    "concierge_contact": "+971-xxx"
  },
  
  "deadline": "2026-01-20T14:00:00+04:00",
  
  "current_state": "IN_TRANSIT_AIR",
  "current_location": {
    "type": "aircraft",
    "identifier": "SAAB-340F-REG",
    "coordinates": [24.8888, 56.2341],
    "eta_next_point": "2026-01-20T06:30:00+04:00"
  },
  
  "timeline": {
    "payment": "2026-01-19T10:00:00+04:00",
    "pattern_complete": "2026-01-19T10:45:00+04:00",
    "tailor_claimed": "2026-01-19T10:52:00+04:00",
    "production_complete": "2026-01-19T17:30:00+04:00",
    "qc_pass": "2026-01-19T18:15:00+04:00",
    "packed": "2026-01-19T19:00:00+04:00",
    "loaded_aircraft": "2026-01-19T23:30:00+04:00",
    "landed": null,
    "customs_cleared": null,
    "out_for_delivery": null,
    "delivered": null
  },
  
  "assigned_resources": {
    "tailor_primary": "TAILOR-042",
    "tailor_backup": "TAILOR-087",
    "qc_inspector": "QC-012",
    "flight": "CHARTER-2026-01-19-PM",
    "van": null,
    "driver": null
  },
  
  "risk_score": 0.15,
  "risk_factors": [],
  
  "alerts": []
}
```

---

## Risk Scoring Model

Every suit gets a live risk score (0 to 1):

| Factor | Weight | Calculation |
|--------|--------|-------------|
| Time remaining vs stages left | 0.3 | `(deadline - now) / expected_remaining_time` |
| Production delays | 0.2 | `actual_time / expected_time` per stage |
| Distance to destination | 0.15 | Longer = higher risk |
| Weather/traffic conditions | 0.15 | API-driven |
| Resource availability | 0.1 | Van capacity, driver hours |
| Historical route performance | 0.1 | Past delivery success rate |

**Thresholds:**
- 0.0 - 0.3: Green (on track)
- 0.3 - 0.6: Amber (monitor closely)
- 0.6 - 0.8: Red (intervention required)
- 0.8 - 1.0: Critical (escalate immediately)

---

## Automated Interventions

| Risk Level | Trigger | Auto-Response |
|------------|---------|---------------|
| Amber | Risk > 0.3 | Flag in dashboard, increase monitoring frequency |
| Red | Risk > 0.6 | Alert ops manager, evaluate backup options |
| Red | Tailor behind schedule | VAPI call to tailor, prep backup suit |
| Red | Flight delay >1hr | Re-calculate all delivery windows, notify at-risk customers |
| Critical | Risk > 0.8 | Auto-dispatch backup resources, customer proactive notification |
| Critical | Delivery window <30 min | Direct driver call, hotel concierge alert |

---

## Customer Communication Layer

**Proactive updates triggered by state changes:**

| Event | Customer Message |
|-------|------------------|
| Payment confirmed | "Your suit is in production. Expected delivery: [time]" |
| QC passed | "Your suit passed quality inspection and is being packed" |
| Loaded on aircraft | "Your suit is on its way to UAE" |
| Customs cleared | "Your suit has arrived and is out for delivery" |
| 30 min from delivery | "Your suit will arrive in approximately 30 minutes" |
| Delivered | "Your suit has been delivered to [hotel]. Enjoy!" |

**Exception messages:**

| Event | Customer Message |
|-------|------------------|
| Delay detected | "We're experiencing a slight delay. New ETA: [time]. We apologize for any inconvenience." |
| Significant delay | "Due to [reason], your delivery is delayed. New ETA: [time]. We're offering [compensation]." |

---

## Dashboard Views

### Operations Control Tower

```
┌────────────────────────────────────────────────────────────────────┐
│  SUIT AI - LOGISTICS CONTROL                     19 Jan 2026 14:32 │
├────────────────────────────────────────────────────────────────────┤
│                                                                    │
│  TODAY'S PIPELINE                                                  │
│  ┌──────────┬──────────┬──────────┬──────────┬──────────┐         │
│  │ Production│ QC Queue │ Packed   │ In Air   │ Delivered│         │
│  │    287    │    43    │   112    │   156    │   342    │         │
│  │   ████    │   ██     │  ████    │  █████   │ ████████ │         │
│  └──────────┴──────────┴──────────┴──────────┴──────────┘         │
│                                                                    │
│  RISK ALERTS                              [3 Red] [12 Amber]       │
│  ┌────────────────────────────────────────────────────────────┐   │
│  │ ⚠ SUIT-0847  Flight delay 45min    Risk: 0.72   [RESPOND]  │   │
│  │ ⚠ SUIT-0923  QC fail (primary)     Risk: 0.65   [MONITOR]  │   │
│  │ ⚠ SUIT-1102  Van 3 traffic jam     Risk: 0.61   [REROUTE]  │   │
│  └────────────────────────────────────────────────────────────┘   │
│                                                                    │
│  FLIGHTS                                                           │
│  ┌────────────────────────────────────────────────────────────┐   │
│  │ AM Flight  ✓ Delivered (267 suits)                         │   │
│  │ PM Flight  ● In Air - ETA SHJ 18:45 (289 suits)           │   │
│  │ Route: ATQ → MCT → AUH → SHJ (dual-drop)                   │   │
│  └────────────────────────────────────────────────────────────┘   │
│                                                                    │
│  GROUND FLEET                                    [MAP VIEW]        │
│  ┌────────────────────────────────────────────────────────────┐   │
│  │ Van 1: Dubai Marina    ████░░░░ 12/20 suits   ETA: 19:30   │   │
│  │ Van 2: Downtown        ██████░░ 15/20 suits   ETA: 19:15   │   │
│  │ Van 3: Abu Dhabi       ███░░░░░  8/20 suits   ETA: 20:00   │   │
│  │ Van 4: Sharjah         ████████ 18/20 suits   ETA: 19:45   │   │
│  │ Van 5: Palm Jumeirah   ██░░░░░░  5/20 suits   ETA: 19:20   │   │
│  └────────────────────────────────────────────────────────────┘   │
│                                                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## Build Approach

### Phase 1: Core Tracking
- Suit state machine
- Real-time status updates from all apps
- Basic dashboard

### Phase 2: Optimization Engine
- Route calculation
- Hub selection logic
- Van assignment algorithm

### Phase 3: Prediction & Risk
- Risk scoring model
- Demand forecasting
- Buffer time calculation

### Phase 4: Autonomous Response
- Auto-interventions
- VAPI integration for escalations
- Customer communication automation

### Phase 5: Learning Loop
- Performance data collection
- Model refinement
- Route/time prediction improvement

---

## Technical Stack

| Component | Technology |
|-----------|------------|
| Real-time database | Supabase Realtime / Firebase |
| Optimization engine | Python (OR-Tools, PuLP) or custom |
| Risk model | Python ML or rule-based initially |
| Flight tracking | FlightAware API / ADS-B |
| Traffic/routing | Google Maps Platform |
| Weather | OpenWeatherMap API |
| Messaging | Twilio / WhatsApp Business API |
| Voice escalation | VAPI (existing) |
| Dashboard | React + WebSockets |

---

This is the system that makes 24-hour delivery at scale actually work. Without it, you're relying on humans to track 540 suits across two countries in real-time.

Do you want me to spec out the database schema or the optimization algorithm in detail?



## Prompt:
1/19/2026, 7:38:47 PM

spec out the database schema then the optimization algorithm



## Response:
1/19/2026, 7:43:11 PM

````plaintext
Thought process: Architected database schema and optimization algorithm framework.

The user wants me to spec out the database schema for the logistics orchestration engine, then the optimization algorithm. This is a substantial technical request that will require detailed work.

Let me think through what tables we need:

1. Core entities:
- Suits (the central tracking object)
- Orders
- Customers
- Destinations/Hotels

2. Production resources:
- Tailors
- QC Inspectors
- Production stages

3. Logistics resources:
- Flights/Charters
- Airports/Hubs
- Vans/Vehicles
- Drivers

4. Tracking:
- Suit timeline events
- Alerts
- Risk scores (could be computed or stored)

5. Reference data:
- Zones
- Hotels
- Routes
- Event calendar

Then for the optimization algorithm, I need to cover:
1. Flight/hub selection optimization
2. Van routing optimization (Vehicle Routing Problem with Time Windows - VRPTW)
3. Real-time re-optimization when exceptions occur

Let me build this out comprehensively.
````

## Part 1: Database Schema

### Entity Relationship Overview

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  customers  │────<│   orders    │────<│    suits    │
└─────────────┘     └─────────────┘     └─────────────┘
                                              │
                    ┌─────────────────────────┼─────────────────────────┐
                    │                         │                         │
                    ▼                         ▼                         ▼
            ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
            │   tailor    │           │   flights   │           │ deliveries  │
            │ assignments │           │             │           │             │
            └─────────────┘           └─────────────┘           └─────────────┘
                    │                         │                         │
                    ▼                         ▼                         ▼
            ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
            │   tailors   │           │flight_legs  │           │    vans     │
            └─────────────┘           └─────────────┘           └─────────────┘
```

---

### Core Tables

#### customers

```sql
CREATE TABLE customers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    first_name TEXT NOT NULL,
    last_name TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    phone TEXT NOT NULL,
    phone_country_code TEXT DEFAULT '+971',
    
    -- Communication preferences
    preferred_language TEXT DEFAULT 'en',
    whatsapp_enabled BOOLEAN DEFAULT true,
    sms_enabled BOOLEAN DEFAULT true,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_email CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

CREATE INDEX idx_customers_email ON customers(email);
CREATE INDEX idx_customers_phone ON customers(phone);
```

#### orders

```sql
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_number TEXT UNIQUE NOT NULL, -- Human readable: ORD-2026-01-19-0001
    
    -- Relations
    customer_id UUID NOT NULL REFERENCES customers(id),
    
    -- Destination
    destination_hotel_id UUID REFERENCES hotels(id),
    destination_address TEXT,
    destination_zone_id UUID REFERENCES zones(id),
    destination_coordinates POINT,
    delivery_notes TEXT,
    
    -- Timing
    ordered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    deadline TIMESTAMPTZ NOT NULL, -- 24hr from ordered_at
    
    -- Payment
    payment_status TEXT NOT NULL DEFAULT 'pending',
    payment_captured_at TIMESTAMPTZ,
    stripe_payment_intent_id TEXT,
    total_amount_aed DECIMAL(10,2),
    
    -- Order status
    status TEXT NOT NULL DEFAULT 'draft',
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_payment_status CHECK (payment_status IN ('pending', 'captured', 'failed', 'refunded')),
    CONSTRAINT valid_order_status CHECK (status IN (
        'draft', 'paid', 'in_production', 'packed', 
        'in_transit', 'out_for_delivery', 'delivered', 'cancelled'
    ))
);

CREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_deadline ON orders(deadline);
CREATE INDEX idx_orders_destination_zone ON orders(destination_zone_id);
```

#### suits

```sql
CREATE TABLE suits (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    suit_number TEXT UNIQUE NOT NULL, -- SUIT-2026-01-19-0847
    
    -- Relations
    order_id UUID NOT NULL REFERENCES orders(id),
    
    -- Production type
    is_backup BOOLEAN DEFAULT false, -- true for dual-production backup
    primary_suit_id UUID REFERENCES suits(id), -- if backup, links to primary
    
    -- Current state
    status TEXT NOT NULL DEFAULT 'pending_production',
    current_location_type TEXT, -- 'tailor', 'qc_station', 'hq', 'aircraft', 'van', 'delivered'
    current_location_id UUID, -- Polymorphic reference
    current_coordinates POINT,
    
    -- Risk tracking
    risk_score DECIMAL(3,2) DEFAULT 0.00,
    risk_factors JSONB DEFAULT '[]',
    
    -- Timing
    deadline TIMESTAMPTZ NOT NULL,
    estimated_delivery TIMESTAMPTZ,
    actual_delivery TIMESTAMPTZ,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_suit_status CHECK (status IN (
        'pending_production', 'pattern_ready', 'assigned_tailor',
        'in_production', 'production_complete', 'qc_pending',
        'qc_passed', 'qc_failed', 'packed', 'loaded_aircraft',
        'in_transit_air', 'customs_pending', 'customs_cleared',
        'assigned_van', 'out_for_delivery', 'delivered', 'cancelled'
    )),
    CONSTRAINT valid_risk_score CHECK (risk_score >= 0 AND risk_score <= 1)
);

CREATE INDEX idx_suits_order ON suits(order_id);
CREATE INDEX idx_suits_status ON suits(status);
CREATE INDEX idx_suits_risk ON suits(risk_score DESC);
CREATE INDEX idx_suits_deadline ON suits(deadline);
```

#### suit_timeline

```sql
CREATE TABLE suit_timeline (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    suit_id UUID NOT NULL REFERENCES suits(id),
    
    -- Event details
    event_type TEXT NOT NULL,
    from_status TEXT,
    to_status TEXT,
    
    -- Location at time of event
    location_type TEXT,
    location_id UUID,
    coordinates POINT,
    
    -- Actor
    actor_type TEXT, -- 'system', 'tailor', 'inspector', 'driver', 'operator'
    actor_id UUID,
    
    -- Additional data
    metadata JSONB DEFAULT '{}',
    notes TEXT,
    
    -- Timing
    occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    recorded_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_event_type CHECK (event_type IN (
        'created', 'pattern_generated', 'tailor_assigned', 'tailor_claimed',
        'production_started', 'production_stage_update', 'production_complete',
        'qc_started', 'qc_passed', 'qc_failed', 'packed',
        'loaded_aircraft', 'aircraft_departed', 'aircraft_landed',
        'customs_submitted', 'customs_cleared', 'customs_held',
        'assigned_van', 'out_for_delivery', 'delivery_attempted', 'delivered',
        'risk_escalated', 'risk_resolved', 'exception_raised', 'exception_resolved'
    ))
);

CREATE INDEX idx_timeline_suit ON suit_timeline(suit_id);
CREATE INDEX idx_timeline_occurred ON suit_timeline(occurred_at DESC);
CREATE INDEX idx_timeline_event_type ON suit_timeline(event_type);
```

---

### Production Tables

#### tailors

```sql
CREATE TABLE tailors (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    
    -- Location
    workshop_address TEXT NOT NULL,
    workshop_coordinates POINT NOT NULL,
    zone_id UUID REFERENCES zones(id),
    distance_to_qc_station_meters INTEGER,
    
    -- Capacity
    max_concurrent_jobs INTEGER DEFAULT 2,
    current_job_count INTEGER DEFAULT 0,
    
    -- Skills and inventory
    skill_level TEXT DEFAULT 'standard', -- 'standard', 'advanced', 'master'
    fabric_variants_in_stock TEXT[] DEFAULT '{}', -- Array of Saffire codes
    
    -- Performance
    total_jobs_completed INTEGER DEFAULT 0,
    qc_pass_rate DECIMAL(4,3) DEFAULT 1.000,
    avg_production_time_minutes INTEGER,
    
    -- Status
    status TEXT DEFAULT 'active',
    available_from TIMESTAMPTZ,
    
    -- Payment
    stripe_connect_id TEXT,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_tailor_status CHECK (status IN ('active', 'inactive', 'suspended', 'on_leave'))
);

CREATE INDEX idx_tailors_zone ON tailors(zone_id);
CREATE INDEX idx_tailors_status ON tailors(status);
CREATE INDEX idx_tailors_available ON tailors(status, current_job_count);
```

#### tailor_assignments

```sql
CREATE TABLE tailor_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    suit_id UUID NOT NULL REFERENCES suits(id),
    tailor_id UUID NOT NULL REFERENCES tailors(id),
    
    -- Assignment type
    assignment_type TEXT DEFAULT 'primary', -- 'primary', 'backup'
    
    -- Status
    status TEXT NOT NULL DEFAULT 'pending',
    
    -- Timing
    posted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    claimed_at TIMESTAMPTZ,
    production_started_at TIMESTAMPTZ,
    production_completed_at TIMESTAMPTZ,
    
    -- SLA tracking
    sla_deadline TIMESTAMPTZ NOT NULL,
    sla_breached BOOLEAN DEFAULT false,
    
    -- Outcome
    outcome TEXT, -- 'completed', 'qc_failed', 'abandoned', 'reassigned'
    
    -- Payment
    payout_amount_inr DECIMAL(10,2),
    payout_status TEXT DEFAULT 'pending',
    payout_triggered_at TIMESTAMPTZ,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_assignment_status CHECK (status IN (
        'pending', 'claimed', 'in_production', 'completed', 'abandoned', 'reassigned'
    ))
);

CREATE INDEX idx_assignments_suit ON tailor_assignments(suit_id);
CREATE INDEX idx_assignments_tailor ON tailor_assignments(tailor_id);
CREATE INDEX idx_assignments_status ON tailor_assignments(status);
CREATE INDEX idx_assignments_sla ON tailor_assignments(sla_deadline);
```

#### qc_inspections

```sql
CREATE TABLE qc_inspections (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    suit_id UUID NOT NULL REFERENCES suits(id),
    tailor_assignment_id UUID NOT NULL REFERENCES tailor_assignments(id),
    inspector_id UUID REFERENCES inspectors(id),
    
    -- Timing
    requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    
    -- Result
    result TEXT, -- 'pass', 'fail', 'conditional_pass'
    
    -- Checklist scores
    visual_score INTEGER, -- 1-5
    measurement_score INTEGER,
    construction_score INTEGER,
    finishing_score INTEGER,
    overall_score DECIMAL(3,2),
    
    -- Issues
    issues JSONB DEFAULT '[]', -- Array of {category, description, severity}
    
    -- Evidence
    photos JSONB DEFAULT '[]', -- Array of photo URLs
    
    -- Notes
    inspector_notes TEXT,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_qc_result CHECK (result IN ('pass', 'fail', 'conditional_pass'))
);

CREATE INDEX idx_qc_suit ON qc_inspections(suit_id);
CREATE INDEX idx_qc_inspector ON qc_inspections(inspector_id);
CREATE INDEX idx_qc_result ON qc_inspections(result);
```

---

### Logistics Tables

#### airports

```sql
CREATE TABLE airports (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    code TEXT UNIQUE NOT NULL, -- IATA code: SHJ, AUH, DWC
    name TEXT NOT NULL,
    city TEXT NOT NULL,
    country TEXT NOT NULL,
    
    -- Location
    coordinates POINT NOT NULL,
    timezone TEXT NOT NULL,
    
    -- Capabilities
    cargo_capable BOOLEAN DEFAULT true,
    customs_preclearance_available BOOLEAN DEFAULT false,
    
    -- Costs (baseline estimates)
    landing_fee_usd DECIMAL(10,2),
    handling_fee_usd DECIMAL(10,2),
    
    -- Operations
    operating_hours_start TIME,
    operating_hours_end TIME,
    
    -- Contacts
    cargo_handler_contact JSONB,
    customs_broker_contact JSONB,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### flights

```sql
CREATE TABLE flights (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    flight_number TEXT UNIQUE NOT NULL, -- CHARTER-2026-01-19-AM
    
    -- Aircraft
    aircraft_type TEXT NOT NULL, -- 'SAAB_340F', 'B737_400F'
    aircraft_registration TEXT,
    capacity_suits INTEGER NOT NULL,
    
    -- Route type
    route_type TEXT NOT NULL, -- 'single_hub', 'dual_drop'
    
    -- Status
    status TEXT NOT NULL DEFAULT 'scheduled',
    
    -- Timing
    scheduled_departure TIMESTAMPTZ NOT NULL,
    actual_departure TIMESTAMPTZ,
    scheduled_arrival TIMESTAMPTZ NOT NULL,
    actual_arrival TIMESTAMPTZ,
    
    -- Manifest
    suits_loaded INTEGER DEFAULT 0,
    manifest_closed_at TIMESTAMPTZ,
    
    -- Cost
    charter_cost_gbp DECIMAL(10,2),
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_flight_status CHECK (status IN (
        'scheduled', 'boarding', 'departed', 'in_air', 
        'landed', 'unloading', 'completed', 'cancelled', 'delayed'
    ))
);

CREATE INDEX idx_flights_status ON flights(status);
CREATE INDEX idx_flights_departure ON flights(scheduled_departure);
```

#### flight_legs

```sql
CREATE TABLE flight_legs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    flight_id UUID NOT NULL REFERENCES flights(id),
    
    -- Sequence
    leg_number INTEGER NOT NULL,
    
    -- Route
    origin_airport_id UUID NOT NULL REFERENCES airports(id),
    destination_airport_id UUID NOT NULL REFERENCES airports(id),
    
    -- Purpose
    leg_type TEXT NOT NULL, -- 'positioning', 'fuel_stop', 'cargo_drop', 'final'
    
    -- Timing
    scheduled_departure TIMESTAMPTZ NOT NULL,
    actual_departure TIMESTAMPTZ,
    scheduled_arrival TIMESTAMPTZ NOT NULL,
    actual_arrival TIMESTAMPTZ,
    
    -- Cargo operations at destination
    suits_to_unload INTEGER DEFAULT 0,
    unload_completed_at TIMESTAMPTZ,
    customs_cleared_at TIMESTAMPTZ,
    
    -- Status
    status TEXT DEFAULT 'scheduled',
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_leg_type CHECK (leg_type IN ('positioning', 'fuel_stop', 'cargo_drop', 'final')),
    CONSTRAINT unique_flight_leg UNIQUE (flight_id, leg_number)
);

CREATE INDEX idx_legs_flight ON flight_legs(flight_id);
CREATE INDEX idx_legs_destination ON flight_legs(destination_airport_id);
```

#### suit_flight_assignments

```sql
CREATE TABLE suit_flight_assignments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    suit_id UUID NOT NULL REFERENCES suits(id),
    flight_id UUID NOT NULL REFERENCES flights(id),
    unload_leg_id UUID NOT NULL REFERENCES flight_legs(id),
    
    -- Position
    load_sequence INTEGER,
    
    -- Status
    loaded_at TIMESTAMPTZ,
    unloaded_at TIMESTAMPTZ,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_suit_flight UNIQUE (suit_id, flight_id)
);

CREATE INDEX idx_suit_flight_suit ON suit_flight_assignments(suit_id);
CREATE INDEX idx_suit_flight_flight ON suit_flight_assignments(flight_id);
```

---

### Ground Fleet Tables

#### vans

```sql
CREATE TABLE vans (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    van_number TEXT UNIQUE NOT NULL, -- VAN-01
    license_plate TEXT NOT NULL,
    
    -- Base
    home_airport_id UUID REFERENCES airports(id),
    home_zone_id UUID REFERENCES zones(id),
    
    -- Capacity
    max_suits INTEGER DEFAULT 25,
    current_suit_count INTEGER DEFAULT 0,
    
    -- Current state
    status TEXT DEFAULT 'available',
    current_coordinates POINT,
    current_zone_id UUID REFERENCES zones(id),
    last_location_update TIMESTAMPTZ,
    
    -- Current driver
    current_driver_id UUID REFERENCES drivers(id),
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_van_status CHECK (status IN (
        'available', 'assigned', 'loading', 'in_transit', 
        'delivering', 'returning', 'maintenance', 'offline'
    ))
);

CREATE INDEX idx_vans_status ON vans(status);
CREATE INDEX idx_vans_airport ON vans(home_airport_id);
CREATE INDEX idx_vans_location ON vans USING GIST(current_coordinates);
```

#### drivers

```sql
CREATE TABLE drivers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    
    -- License
    license_number TEXT NOT NULL,
    license_expiry DATE NOT NULL,
    
    -- Status
    status TEXT DEFAULT 'available',
    shift_start TIMESTAMPTZ,
    shift_end TIMESTAMPTZ,
    hours_worked_today DECIMAL(4,2) DEFAULT 0,
    
    -- Performance
    total_deliveries INTEGER DEFAULT 0,
    on_time_rate DECIMAL(4,3) DEFAULT 1.000,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_driver_status CHECK (status IN (
        'available', 'assigned', 'on_delivery', 'on_break', 'off_duty'
    ))
);

CREATE INDEX idx_drivers_status ON drivers(status);
```

#### delivery_routes

```sql
CREATE TABLE delivery_routes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    van_id UUID NOT NULL REFERENCES vans(id),
    driver_id UUID NOT NULL REFERENCES drivers(id),
    flight_leg_id UUID REFERENCES flight_legs(id), -- Which arrival this route serves
    
    -- Route details
    origin_airport_id UUID REFERENCES airports(id),
    
    -- Timing
    created_at TIMESTAMPTZ DEFAULT NOW(),
    started_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    
    -- Route optimization
    total_stops INTEGER DEFAULT 0,
    total_distance_km DECIMAL(10,2),
    estimated_duration_minutes INTEGER,
    actual_duration_minutes INTEGER,
    
    -- Waypoints (optimized order)
    waypoints JSONB DEFAULT '[]', -- Array of {sequence, hotel_id, suit_ids, eta}
    
    -- Status
    status TEXT DEFAULT 'planned',
    current_stop_index INTEGER DEFAULT 0,
    
    CONSTRAINT valid_route_status CHECK (status IN (
        'planned', 'assigned', 'in_progress', 'completed', 'cancelled'
    ))
);

CREATE INDEX idx_routes_van ON delivery_routes(van_id);
CREATE INDEX idx_routes_status ON delivery_routes(status);
CREATE INDEX idx_routes_flight ON delivery_routes(flight_leg_id);
```

#### deliveries

```sql
CREATE TABLE deliveries (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Relations
    suit_id UUID NOT NULL REFERENCES suits(id),
    route_id UUID NOT NULL REFERENCES delivery_routes(id),
    hotel_id UUID REFERENCES hotels(id),
    
    -- Sequence
    stop_sequence INTEGER NOT NULL,
    
    -- Destination
    delivery_address TEXT NOT NULL,
    delivery_coordinates POINT NOT NULL,
    recipient_name TEXT,
    recipient_phone TEXT,
    delivery_notes TEXT,
    
    -- Timing
    estimated_arrival TIMESTAMPTZ,
    actual_arrival TIMESTAMPTZ,
    
    -- Status
    status TEXT DEFAULT 'pending',
    
    -- Outcome
    delivered_to TEXT, -- 'customer', 'concierge', 'front_desk'
    signature_url TEXT,
    photo_url TEXT,
    
    -- Issues
    delivery_attempts INTEGER DEFAULT 0,
    last_attempt_at TIMESTAMPTZ,
    failure_reason TEXT,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_delivery_status CHECK (status IN (
        'pending', 'in_transit', 'arrived', 'delivered', 'failed', 'rescheduled'
    ))
);

CREATE INDEX idx_deliveries_suit ON deliveries(suit_id);
CREATE INDEX idx_deliveries_route ON deliveries(route_id);
CREATE INDEX idx_deliveries_status ON deliveries(status);
CREATE INDEX idx_deliveries_eta ON deliveries(estimated_arrival);
```

---

### Reference Tables

#### zones

```sql
CREATE TABLE zones (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    code TEXT UNIQUE NOT NULL, -- 'DUBAI-MARINA', 'ABU-DHABI-DOWNTOWN'
    name TEXT NOT NULL,
    city TEXT NOT NULL,
    country TEXT DEFAULT 'UAE',
    
    -- Geography
    boundary POLYGON, -- GeoJSON polygon
    center_coordinates POINT,
    
    -- Logistics
    primary_airport_id UUID REFERENCES airports(id),
    avg_delivery_time_from_airport_minutes INTEGER,
    
    -- Traffic patterns
    peak_hours JSONB, -- {morning: {start, end, multiplier}, evening: {...}}
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_zones_airport ON zones(primary_airport_id);
CREATE INDEX idx_zones_boundary ON zones USING GIST(boundary);
```

#### hotels

```sql
CREATE TABLE hotels (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    name TEXT NOT NULL,
    brand TEXT, -- 'Four Seasons', 'Jumeirah', etc.
    star_rating INTEGER,
    
    -- Location
    address TEXT NOT NULL,
    coordinates POINT NOT NULL,
    zone_id UUID REFERENCES zones(id),
    
    -- Contacts
    concierge_phone TEXT,
    concierge_whatsapp TEXT,
    concierge_email TEXT,
    front_desk_phone TEXT,
    
    -- Delivery instructions
    delivery_entrance TEXT, -- 'Main lobby', 'Service entrance Gate 3'
    delivery_notes TEXT,
    requires_advance_notice BOOLEAN DEFAULT false,
    advance_notice_minutes INTEGER,
    
    -- Access
    guest_verification_required BOOLEAN DEFAULT false,
    
    -- Priority
    tier TEXT DEFAULT 'standard', -- 'flagship', 'priority', 'standard'
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_hotels_zone ON hotels(zone_id);
CREATE INDEX idx_hotels_location ON hotels USING GIST(coordinates);
CREATE INDEX idx_hotels_tier ON hotels(tier);
```

#### events

```sql
CREATE TABLE events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    name TEXT NOT NULL,
    event_type TEXT NOT NULL, -- 'expo', 'finance', 'racing', 'art', 'fashion'
    
    -- Location
    city TEXT NOT NULL,
    venue TEXT,
    primary_zone_id UUID REFERENCES zones(id),
    
    -- Timing
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    
    -- Impact
    expected_demand_multiplier DECIMAL(3,2) DEFAULT 1.00,
    expected_dubai_ratio DECIMAL(3,2), -- Expected % of orders for Dubai
    expected_abu_dhabi_ratio DECIMAL(3,2),
    
    -- Recommended config
    recommended_hub TEXT, -- 'SHJ', 'AUH', 'dual'
    recommended_flights_per_day INTEGER,
    
    -- Notes
    notes TEXT,
    
    -- Metadata
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_events_dates ON events(start_date, end_date);
CREATE INDEX idx_events_city ON events(city);
```

---

### Alerts and Monitoring

#### alerts

```sql
CREATE TABLE alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Subject
    entity_type TEXT NOT NULL, -- 'suit', 'flight', 'van', 'tailor'
    entity_id UUID NOT NULL,
    
    -- Alert details
    alert_type TEXT NOT NULL,
    severity TEXT NOT NULL, -- 'info', 'warning', 'critical'
    
    -- Content
    title TEXT NOT NULL,
    description TEXT,
    metadata JSONB DEFAULT '{}',
    
    -- Risk context (for suit alerts)
    risk_score_at_alert DECIMAL(3,2),
    risk_factors JSONB,
    
    -- Response
    status TEXT DEFAULT 'open',
    acknowledged_at TIMESTAMPTZ,
    acknowledged_by UUID,
    resolved_at TIMESTAMPTZ,
    resolved_by UUID,
    resolution_notes TEXT,
    
    -- Auto-response
    auto_response_triggered BOOLEAN DEFAULT false,
    auto_response_action TEXT,
    auto_response_at TIMESTAMPTZ,
    
    -- Timing
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_alert_severity CHECK (severity IN ('info', 'warning', 'critical')),
    CONSTRAINT valid_alert_status CHECK (status IN ('open', 'acknowledged', 'resolved', 'escalated'))
);

CREATE INDEX idx_alerts_entity ON alerts(entity_type, entity_id);
CREATE INDEX idx_alerts_status ON alerts(status);
CREATE INDEX idx_alerts_severity ON alerts(severity);
CREATE INDEX idx_alerts_created ON alerts(created_at DESC);
```

#### system_metrics

```sql
CREATE TABLE system_metrics (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Timestamp
    recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    period_type TEXT NOT NULL, -- 'minute', 'hour', 'day'
    
    -- Pipeline metrics
    orders_received INTEGER DEFAULT 0,
    suits_in_production INTEGER DEFAULT 0,
    suits_in_transit INTEGER DEFAULT 0,
    suits_delivered INTEGER DEFAULT 0,
    
    -- Risk metrics
    suits_green INTEGER DEFAULT 0,
    suits_amber INTEGER DEFAULT 0,
    suits_red INTEGER DEFAULT 0,
    suits_critical INTEGER DEFAULT 0,
    
    -- Performance
    avg_production_time_minutes DECIMAL(10,2),
    avg_delivery_time_minutes DECIMAL(10,2),
    on_time_delivery_rate DECIMAL(4,3),
    qc_pass_rate DECIMAL(4,3),
    
    -- Capacity
    tailor_utilization_rate DECIMAL(4,3),
    van_utilization_rate DECIMAL(4,3),
    flight_capacity_used_rate DECIMAL(4,3),
    
    -- Cost
    total_charter_cost_gbp DECIMAL(10,2),
    avg_cost_per_suit_gbp DECIMAL(10,2),
    
    CONSTRAINT valid_period_type CHECK (period_type IN ('minute', 'hour', 'day'))
);

CREATE INDEX idx_metrics_time ON system_metrics(recorded_at DESC);
CREATE INDEX idx_metrics_period ON system_metrics(period_type, recorded_at DESC);
```

---

### Views for Optimization Engine

#### v_suits_pending_flight_assignment

```sql
CREATE VIEW v_suits_pending_flight_assignment AS
SELECT 
    s.id AS suit_id,
    s.suit_number,
    s.deadline,
    s.risk_score,
    o.destination_zone_id,
    z.primary_airport_id,
    z.code AS zone_code,
    h.name AS hotel_name,
    h.coordinates AS destination_coordinates,
    EXTRACT(EPOCH FROM (s.deadline - NOW())) / 3600 AS hours_until_deadline
FROM suits s
JOIN orders o ON s.order_id = o.id
LEFT JOIN zones z ON o.destination_zone_id = z.id
LEFT JOIN hotels h ON o.destination_hotel_id = h.id
WHERE s.status = 'packed'
AND NOT EXISTS (
    SELECT 1 FROM suit_flight_assignments sfa WHERE sfa.suit_id = s.id
)
ORDER BY s.deadline ASC;
```

#### v_active_routes_with_capacity

```sql
CREATE VIEW v_active_routes_with_capacity AS
SELECT 
    dr.id AS route_id,
    dr.van_id,
    v.van_number,
    v.max_suits,
    v.current_suit_count,
    v.max_suits - v.current_suit_count AS available_capacity,
    v.current_coordinates,
    dr.status,
    dr.current_stop_index,
    dr.total_stops,
    d.name AS driver_name,
    d.phone AS driver_phone
FROM delivery_routes dr
JOIN vans v ON dr.van_id = v.id
JOIN drivers d ON dr.driver_id = d.id
WHERE dr.status IN ('planned', 'assigned', 'in_progress')
AND v.status != 'offline';
```

#### v_tailor_availability

```sql
CREATE VIEW v_tailor_availability AS
SELECT 
    t.id AS tailor_id,
    t.name,
    t.max_concurrent_jobs,
    t.current_job_count,
    t.max_concurrent_jobs - t.current_job_count AS available_slots,
    t.skill_level,
    t.fabric_variants_in_stock,
    t.qc_pass_rate,
    t.avg_production_time_minutes,
    t.workshop_coordinates,
    t.distance_to_qc_station_meters
FROM tailors t
WHERE t.status = 'active'
AND t.current_job_count < t.max_concurrent_jobs
ORDER BY t.qc_pass_rate DESC, t.avg_production_time_minutes ASC;
```

---

## Part 2: Optimization Algorithm

### Overview

The system runs three main optimization processes:

1. **Flight Planning Optimizer** - Decides hub strategy and flight routing
2. **Tailor Assignment Optimizer** - Allocates suits to tailors
3. **Vehicle Routing Optimizer** - Plans delivery routes (VRPTW)

Plus a real-time **Re-optimization Engine** that responds to exceptions.

---

### Algorithm 1: Flight Planning Optimizer

**Runs:** Every time manifest needs to close (2 hours before departure)

**Objective:** Minimize total cost while ensuring all suits meet delivery deadlines

```python
"""
Flight Planning Optimizer

Decides:
1. Single hub (SHJ or AUH) vs dual-drop (AUH → SHJ)
2. Which suits go on which flight
3. At which airport each suit should be unloaded
"""

import numpy as np
from dataclasses import dataclass
from typing import List, Dict, Optional
from datetime import datetime, timedelta


@dataclass
class Suit:
    id: str
    deadline: datetime
    destination_zone: str
    destination_airport: str  # Preferred based on zone
    priority: int  # 1=critical, 2=high, 3=normal
    

@dataclass
class FlightOption:
    id: str
    route_type: str  # 'single_shj', 'single_auh', 'dual_drop'
    departure_time: datetime
    legs: List[Dict]  # [{airport, arrival_time, unload_capacity}]
    base_cost: float
    additional_stop_cost: float
    

@dataclass 
class Airport:
    code: str
    ground_delivery_times: Dict[str, int]  # zone_code -> minutes


class FlightPlanningOptimizer:
    
    def __init__(self, airports: Dict[str, Airport], cost_params: Dict):
        self.airports = airports
        self.cost_params = cost_params
        
    def optimize(
        self,
        pending_suits: List[Suit],
        available_flights: List[FlightOption],
        current_time: datetime
    ) -> Dict:
        """
        Main optimization function.
        Returns optimal flight configuration and suit assignments.
        """
        
        # Step 1: Analyze demand distribution
        demand_analysis = self._analyze_demand(pending_suits)
        
        # Step 2: Calculate feasibility for each flight option
        feasibility = {}
        for flight in available_flights:
            feasibility[flight.id] = self._calculate_feasibility(
                flight, pending_suits, current_time
            )
        
        # Step 3: Calculate cost for each viable option
        costs = {}
        for flight_id, feas in feasibility.items():
            if feas['viable']:
                costs[flight_id] = self._calculate_total_cost(
                    available_flights[flight_id],
                    feas['assignments'],
                    demand_analysis
                )
        
        # Step 4: Select optimal configuration
        if not costs:
            return {'status': 'infeasible', 'reason': 'No viable flight options'}
            
        optimal_flight_id = min(costs, key=lambda x: costs[x]['total'])
        optimal_flight = next(f for f in available_flights if f.id == optimal_flight_id)
        
        # Step 5: Generate final assignments
        assignments = self._generate_assignments(
            optimal_flight,
            feasibility[optimal_flight_id]['assignments']
        )
        
        return {
            'status': 'optimal',
            'flight_id': optimal_flight_id,
            'route_type': optimal_flight.route_type,
            'total_cost': costs[optimal_flight_id]['total'],
            'cost_breakdown': costs[optimal_flight_id],
            'assignments': assignments,
            'demand_analysis': demand_analysis
        }
    
    def _analyze_demand(self, suits: List[Suit]) -> Dict:
        """Analyze geographic distribution of demand."""
        
        zones = {}
        airports = {'SHJ': 0, 'AUH': 0, 'DWC': 0}
        
        for suit in suits:
            zone = suit.destination_zone
            zones[zone] = zones.get(zone, 0) + 1
            airports[suit.destination_airport] += 1
        
        total = len(suits)
        
        return {
            'total_suits': total,
            'by_zone': zones,
            'by_airport': airports,
            'abu_dhabi_ratio': airports.get('AUH', 0) / total if total > 0 else 0,
            'dubai_ratio': (airports.get('SHJ', 0) + airports.get('DWC', 0)) / total if total > 0 else 0,
            'recommend_dual_drop': airports.get('AUH', 0) >= 100  # Threshold
        }
    
    def _calculate_feasibility(
        self,
        flight: FlightOption,
        suits: List[Suit],
        current_time: datetime
    ) -> Dict:
        """
        Check if flight option can deliver all suits on time.
        Returns feasibility status and preliminary assignments.
        """
        
        assignments = []
        infeasible_suits = []
        
        for suit in suits:
            # Find best unload point for this suit
            best_leg = None
            best_buffer = -float('inf')
            
            for leg in flight.legs:
                if leg['type'] not in ['cargo_drop', 'final']:
                    continue
                    
                airport = leg['airport']
                arrival_time = leg['arrival_time']
                
                # Calculate delivery time from this airport
                ground_time = self.airports[airport].ground_delivery_times.get(
                    suit.destination_zone, 180  # Default 3 hours if unknown
                )
                
                # Add customs and sorting time
                customs_time = 60  # minutes
                sorting_time = 30
                
                delivery_time = arrival_time + timedelta(
                    minutes=customs_time + sorting_time + ground_time
                )
                
                buffer = (suit.deadline - delivery_time).total_seconds() / 60
                
                if buffer > best_buffer:
                    best_buffer = buffer
                    best_leg = {
                        'leg_id': leg['id'],
                        'airport': airport,
                        'estimated_delivery': delivery_time,
                        'buffer_minutes': buffer
                    }
            
            if best_leg and best_leg['buffer_minutes'] >= 0:
                assignments.append({
                    'suit_id': suit.id,
                    'unload_leg': best_leg
                })
            else:
                infeasible_suits.append(suit.id)
        
        return {
            'viable': len(infeasible_suits) == 0,
            'assignments': assignments,
            'infeasible_suits': infeasible_suits,
            'feasibility_rate': len(assignments) / len(suits) if suits else 0
        }
    
    def _calculate_total_cost(
        self,
        flight: FlightOption,
        assignments: List[Dict],
        demand: Dict
    ) -> Dict:
        """Calculate total cost including flight and ground distribution."""
        
        # Flight cost
        flight_cost = flight.base_cost
        if flight.route_type == 'dual_drop':
            flight_cost += flight.additional_stop_cost
        
        # Ground distribution cost
        ground_cost = 0
        suits_by_airport = {}
        
        for assignment in assignments:
            airport = assignment['unload_leg']['airport']
            suits_by_airport[airport] = suits_by_airport.get(airport, 0) + 1
        
        for airport, count in suits_by_airport.items():
            # Estimate vans needed
            vans_needed = np.ceil(count / 20)  # 20 suits per van
            ground_cost += vans_needed * self.cost_params['van_cost_per_trip']
        
        # Per-suit cost
        total_suits = len(assignments)
        per_suit = (flight_cost + ground_cost) / total_suits if total_suits > 0 else 0
        
        return {
            'flight_cost': flight_cost,
            'ground_cost': ground_cost,
            'total': flight_cost + ground_cost,
            'per_suit': per_suit,
            'suits_count': total_suits
        }
    
    def _generate_assignments(
        self,
        flight: FlightOption,
        preliminary_assignments: List[Dict]
    ) -> List[Dict]:
        """Generate final assignment records."""
        
        return [
            {
                'suit_id': a['suit_id'],
                'flight_id': flight.id,
                'unload_airport': a['unload_leg']['airport'],
                'unload_leg_id': a['unload_leg']['leg_id'],
                'estimated_delivery': a['unload_leg']['estimated_delivery'],
                'buffer_minutes': a['unload_leg']['buffer_minutes']
            }
            for a in preliminary_assignments
        ]
```

---

### Algorithm 2: Tailor Assignment Optimizer

**Runs:** When pattern is ready and job needs posting

**Objective:** Assign suits to tailors minimizing production time and QC fail risk

```python
"""
Tailor Assignment Optimizer

Decides:
1. Which tailors receive job postings
2. Dual-posting strategy (which two tailors)
3. Auto-assignment if no claims within threshold
"""

from dataclasses import dataclass
from typing import List, Tuple, Optional
from datetime import datetime, timedelta
import heapq


@dataclass
class TailorProfile:
    id: str
    name: str
    available_slots: int
    skill_level: str  # 'standard', 'advanced', 'master'
    qc_pass_rate: float  # 0.0 - 1.0
    avg_production_time: int  # minutes
    fabric_variants: List[str]
    distance_to_qc: int  # meters
    current_load: int
    max_load: int
    

@dataclass
class JobRequirements:
    suit_id: str
    fabric_variant: str
    complexity: str  # 'standard', 'complex', 'bespoke'
    deadline: datetime
    required_skill: str


class TailorAssignmentOptimizer:
    
    def __init__(self, config: Dict):
        self.config = config
        self.claim_timeout_minutes = config.get('claim_timeout', 10)
        self.enable_dual_posting = config.get('dual_posting', True)
        
    def find_optimal_tailors(
        self,
        job: JobRequirements,
        available_tailors: List[TailorProfile],
        current_time: datetime
    ) -> Dict:
        """
        Find optimal tailor(s) for a job.
        Returns ranked list for posting or direct assignment.
        """
        
        # Step 1: Filter eligible tailors
        eligible = self._filter_eligible(job, available_tailors)
        
        if not eligible:
            return {
                'status': 'no_eligible_tailors',
                'reason': 'No tailors with capacity and required fabric'
            }
        
        # Step 2: Score each tailor
        scored = []
        for tailor in eligible:
            score = self._calculate_tailor_score(tailor, job, current_time)
            scored.append((score, tailor))
        
        # Step 3: Sort by score (higher is better)
        scored.sort(key=lambda x: x[0], reverse=True)
        
        # Step 4: Select for dual posting
        if self.enable_dual_posting and len(scored) >= 2:
            primary = scored[0][1]
            backup = scored[1][1]
            
            return {
                'status': 'dual_post',
                'primary_tailor': self._tailor_assignment(primary, 'primary', job),
                'backup_tailor': self._tailor_assignment(backup, 'backup', job),
                'ranked_alternatives': [
                    self._tailor_assignment(t, 'alternative', job) 
                    for _, t in scored[2:10]  # Next 8 as VAPI call list
                ]
            }
        elif scored:
            return {
                'status': 'single_post',
                'primary_tailor': self._tailor_assignment(scored[0][1], 'primary', job),
                'ranked_alternatives': [
                    self._tailor_assignment(t, 'alternative', job)
                    for _, t in scored[1:10]
                ]
            }
        
    def _filter_eligible(
        self,
        job: JobRequirements,
        tailors: List[TailorProfile]
    ) -> List[TailorProfile]:
        """Filter tailors who can take this job."""
        
        eligible = []
        
        for tailor in tailors:
            # Must have capacity
            if tailor.available_slots <= 0:
                continue
                
            # Must have the fabric
            if job.fabric_variant not in tailor.fabric_variants:
                continue
                
            # Must meet skill requirement
            skill_hierarchy = {'standard': 1, 'advanced': 2, 'master': 3}
            required_skill = {'standard': 1, 'complex': 2, 'bespoke': 3}
            
            if skill_hierarchy.get(tailor.skill_level, 0) < required_skill.get(job.complexity, 1):
                continue
                
            eligible.append(tailor)
            
        return eligible
    
    def _calculate_tailor_score(
        self,
        tailor: TailorProfile,
        job: JobRequirements,
        current_time: datetime
    ) -> float:
        """
        Calculate composite score for tailor-job match.
        Higher score = better match.
        """
        
        score = 0.0
        
        # Factor 1: QC Pass Rate (weight: 35%)
        # Higher pass rate = less rework risk
        qc_score = tailor.qc_pass_rate * 100
        score += qc_score * 0.35
        
        # Factor 2: Production Speed (weight: 25%)
        # Faster = better, normalized against 8-hour baseline (480 min)
        speed_score = max(0, (480 - tailor.avg_production_time) / 480 * 100)
        score += speed_score * 0.25
        
        # Factor 3: Current Load (weight: 15%)
        # Less loaded = more attention to this job
        load_ratio = tailor.current_load / tailor.max_load
        load_score = (1 - load_ratio) * 100
        score += load_score * 0.15
        
        # Factor 4: Distance to QC (weight: 15%)
        # Closer = faster handoff, normalized against 1000m baseline
        distance_score = max(0, (1000 - tailor.distance_to_qc) / 1000 * 100)
        score += distance_score * 0.15
        
        # Factor 5: Skill Match (weight: 10%)
        # Exact match is ideal, overqualified is okay but not optimal
        skill_map = {'standard': 1, 'advanced': 2, 'master': 3}
        complexity_map = {'standard': 1, 'complex': 2, 'bespoke': 3}
        
        tailor_skill = skill_map.get(tailor.skill_level, 1)
        required = complexity_map.get(job.complexity, 1)
        
        if tailor_skill == required:
            skill_score = 100
        elif tailor_skill > required:
            skill_score = 80  # Overqualified
        else:
            skill_score = 0  # Shouldn't happen after filtering
            
        score += skill_score * 0.10
        
        return score
    
    def _tailor_assignment(
        self,
        tailor: TailorProfile,
        role: str,
        job: JobRequirements
    ) -> Dict:
        """Create assignment record."""
        
        return {
            'tailor_id': tailor.id,
            'tailor_name': tailor.name,
            'role': role,
            'score': self._calculate_tailor_score(tailor, job, datetime.now()),
            'estimated_production_time': tailor.avg_production_time,
            'qc_pass_probability': tailor.qc_pass_rate,
            'distance_to_qc': tailor.distance_to_qc
        }
    
    def escalate_unclaimed(
        self,
        job: JobRequirements,
        posted_tailors: List[str],
        alternative_tailors: List[Dict],
        time_posted: datetime
    ) -> Dict:
        """
        Handle unclaimed job after timeout.
        Triggers VAPI calls to alternative tailors.
        """
        
        minutes_elapsed = (datetime.now() - time_posted).total_seconds() / 60
        
        if minutes_elapsed < self.claim_timeout_minutes:
            return {'action': 'wait', 'remaining_minutes': self.claim_timeout_minutes - minutes_elapsed}
        
        # Select tailors for VAPI call (up to 20 simultaneously)
        call_list = [t for t in alternative_tailors if t['tailor_id'] not in posted_tailors][:20]
        
        return {
            'action': 'vapi_escalation',
            'call_list': call_list,
            'message': f"Urgent job available: {job.suit_id}. Respond to claim.",
            'auto_assign_after_minutes': 5,
            'auto_assign_to': call_list[0]['tailor_id'] if call_list else None
        }
```

---

### Algorithm 3: Vehicle Routing Optimizer (VRPTW)

**Runs:** When flight lands and customs clears

**Objective:** Minimize total delivery time while meeting all deadlines

```python
"""
Vehicle Routing Problem with Time Windows (VRPTW)

Decides:
1. Which van delivers which suits
2. Optimal delivery sequence per van
3. Dynamic re-routing on exceptions
"""

from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional
from datetime import datetime, timedelta
import numpy as np
from scipy.spatial.distance import cdist


@dataclass
class DeliveryPoint:
    id: str
    suit_ids: List[str]
    coordinates: Tuple[float, float]
    hotel_name: str
    deadline: datetime
    service_time: int  # minutes at location
    priority: int  # 1=critical, 2=high, 3=normal
    

@dataclass
class Van:
    id: str
    current_location: Tuple[float, float]
    capacity: int
    current_load: int
    driver_hours_remaining: float
    speed_kmh: float  # Average speed


class VRPTWOptimizer:
    
    def __init__(self, config: Dict):
        self.config = config
        self.max_iterations = config.get('max_iterations', 1000)
        self.traffic_multiplier = config.get('traffic_multiplier', 1.0)
        
    def optimize(
        self,
        deliveries: List[DeliveryPoint],
        vans: List[Van],
        depot_location: Tuple[float, float],
        current_time: datetime
    ) -> Dict:
        """
        Main VRPTW optimization using modified Clarke-Wright savings algorithm
        with time window constraints.
        """
        
        if not deliveries:
            return {'status': 'empty', 'routes': []}
            
        if not vans:
            return {'status': 'no_vehicles', 'routes': []}
        
        # Step 1: Build distance/time matrix
        all_points = [depot_location] + [d.coordinates for d in deliveries]
        distance_matrix = self._build_distance_matrix(all_points)
        time_matrix = self._build_time_matrix(distance_matrix, vans[0].speed_kmh)
        
        # Step 2: Calculate savings
        savings = self._calculate_savings(distance_matrix, len(deliveries))
        
        # Step 3: Build initial routes using savings algorithm
        routes = self._build_routes_savings(
            deliveries, vans, savings, time_matrix, current_time
        )
        
        # Step 4: Optimize routes with 2-opt
        routes = self._optimize_2opt(routes, time_matrix, deliveries, current_time)
        
        # Step 5: Validate time windows
        validation = self._validate_time_windows(routes, deliveries, current_time)
        
        if not validation['all_feasible']:
            # Try to fix infeasible routes
            routes = self._repair_infeasible(
                routes, validation['infeasible'], vans, deliveries, current_time
            )
        
        # Step 6: Generate output
        return self._format_output(routes, deliveries, vans, current_time)
    
    def _build_distance_matrix(
        self,
        points: List[Tuple[float, float]]
    ) -> np.ndarray:
        """Build distance matrix between all points (km)."""
        
        coords = np.array(points)
        
        # Haversine distance for lat/long
        lat1 = np.radians(coords[:, 0:1])
        lat2 = np.radians(coords[:, 0:1].T)
        lon1 = np.radians(coords[:, 1:2])
        lon2 = np.radians(coords[:, 1:2].T)
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
        c = 2 * np.arcsin(np.sqrt(a))
        
        return 6371 * c  # Earth radius in km
    
    def _build_time_matrix(
        self,
        distance_matrix: np.ndarray,
        speed_kmh: float
    ) -> np.ndarray:
        """Convert distance to time (minutes) with traffic multiplier."""
        
        return (distance_matrix / speed_kmh * 60) * self.traffic_multiplier
    
    def _calculate_savings(
        self,
        distance_matrix: np.ndarray,
        n_deliveries: int
    ) -> List[Tuple[float, int, int]]:
        """
        Calculate Clarke-Wright savings.
        Savings(i,j) = Distance(depot,i) + Distance(depot,j) - Distance(i,j)
        """
        
        savings = []
        
        for i in range(1, n_deliveries + 1):
            for j in range(i + 1, n_deliveries + 1):
                s = (
                    distance_matrix[0, i] + 
                    distance_matrix[0, j] - 
                    distance_matrix[i, j]
                )
                savings.append((s, i, j))
        
        # Sort by savings descending
        savings.sort(key=lambda x: x[0], reverse=True)
        
        return savings
    
    def _build_routes_savings(
        self,
        deliveries: List[DeliveryPoint],
        vans: List[Van],
        savings: List[Tuple[float, int, int]],
        time_matrix: np.ndarray,
        current_time: datetime
    ) -> List[Dict]:
        """Build initial routes using Clarke-Wright savings algorithm."""
        
        n = len(deliveries)
        
        # Initialize: each delivery in its own route
        routes = []
        delivery_to_route = {}
        
        for i, delivery in enumerate(deliveries):
            route = {
                'van_id': None,
                'stops': [i],
                'load': len(delivery.suit_ids),
                'total_time': time_matrix[0, i+1] + delivery.service_time + time_matrix[i+1, 0]
            }
            routes.append(route)
            delivery_to_route[i] = len(routes) - 1
        
        # Merge routes based on savings
        for saving, i, j in savings:
            route_i = delivery_to_route.get(i-1)
            route_j = delivery_to_route.get(j-1)
            
            if route_i is None or route_j is None or route_i == route_j:
                continue
            
            r_i = routes[route_i]
            r_j = routes[route_j]
            
            # Check if merge is feasible
            combined_load = r_i['load'] + r_j['load']
            
            # Find a van that can handle this
            suitable_van = None
            for van in vans:
                if van.capacity >= combined_load:
                    suitable_van = van
                    break
            
            if not suitable_van:
                continue
            
            # Check if i is at end of route_i and j is at start of route_j (or vice versa)
            can_merge = False
            new_stops = []
            
            if r_i['stops'][-1] == i-1 and r_j['stops'][0] == j-1:
                new_stops = r_i['stops'] + r_j['stops']
                can_merge = True
            elif r_i['stops'][0] == i-1 and r_j['stops'][-1] == j-1:
                new_stops = r_j['stops'] + r_i['stops']
                can_merge = True
            elif r_i['stops'][-1] == i-1 and r_j['stops'][-1] == j-1:
                new_stops = r_i['stops'] + list(reversed(r_j['stops']))
                can_merge = True
            elif r_i['stops'][0] == i-1 and r_j['stops'][0] == j-1:
                new_stops = list(reversed(r_i['stops'])) + r_j['stops']
                can_merge = True
            
            if can_merge:
                # Calculate new route time
                new_time = self._calculate_route_time(
                    new_stops, deliveries, time_matrix
                )
                
                # Check time window feasibility
                if self._check_time_windows(new_stops, deliveries, time_matrix, current_time):
                    # Merge routes
                    r_i['stops'] = new_stops
                    r_i['load'] = combined_load
                    r_i['total_time'] = new_time
                    
                    # Update delivery mappings
                    for stop in r_j['stops']:
                        delivery_to_route[stop] = route_i
                    
                    # Mark route_j as empty
                    r_j['stops'] = []
                    r_j['load'] = 0
        
        # Remove empty routes and assign vans
        final_routes = []
        van_index = 0
        
        for route in routes:
            if route['stops']:
                if van_index < len(vans):
                    route['van_id'] = vans[van_index].id
                    van_index += 1
                final_routes.append(route)
        
        return final_routes
    
    def _calculate_route_time(
        self,
        stops: List[int],
        deliveries: List[DeliveryPoint],
        time_matrix: np.ndarray
    ) -> float:
        """Calculate total time for a route."""
        
        if not stops:
            return 0
        
        total = time_matrix[0, stops[0] + 1]  # Depot to first stop
        
        for i in range(len(stops)):
            total += deliveries[stops[i]].service_time
            
            if i < len(stops) - 1:
                total += time_matrix[stops[i] + 1, stops[i+1] + 1]
        
        total += time_matrix[stops[-1] + 1, 0]  # Last stop to depot
        
        return total
    
    def _check_time_windows(
        self,
        stops: List[int],
        deliveries: List[DeliveryPoint],
        time_matrix: np.ndarray,
        current_time: datetime
    ) -> bool:
        """Check if all time windows can be met."""
        
        arrival_time = current_time + timedelta(minutes=time_matrix[0, stops[0] + 1])
        
        for i, stop in enumerate(stops):
            delivery = deliveries[stop]
            
            # Check deadline
            if arrival_time > delivery.deadline:
                return False
            
            # Move to next stop
            departure = arrival_time + timedelta(minutes=delivery.service_time)
            
            if i < len(stops) - 1:
                travel = time_matrix[stop + 1, stops[i+1] + 1]
                arrival_time = departure + timedelta(minutes=travel)
        
        return True
    
    def _optimize_2opt(
        self,
        routes: List[Dict],
        time_matrix: np.ndarray,
        deliveries: List[DeliveryPoint],
        current_time: datetime
    ) -> List[Dict]:
        """Apply 2-opt optimization to each route."""
        
        for route in routes:
            if len(route['stops']) <= 2:
                continue
            
            improved = True
            while improved:
                improved = False
                
                for i in range(len(route['stops']) - 1):
                    for j in range(i + 2, len(route['stops'])):
                        # Try reversing segment [i+1:j+1]
                        new_stops = (
                            route['stops'][:i+1] + 
                            list(reversed(route['stops'][i+1:j+1])) + 
                            route['stops'][j+1:]
                        )
                        
                        new_time = self._calculate_route_time(
                            new_stops, deliveries, time_matrix
                        )
                        
                        if (new_time < route['total_time'] and 
                            self._check_time_windows(new_stops, deliveries, time_matrix, current_time)):
                            route['stops'] = new_stops
                            route['total_time'] = new_time
                            improved = True
                            break
                    
                    if improved:
                        break
        
        return routes
    
    def _validate_time_windows(
        self,
        routes: List[Dict],
        deliveries: List[DeliveryPoint],
        current_time: datetime
    ) -> Dict:
        """Validate all routes meet time windows."""
        
        infeasible = []
        
        for route in routes:
            # Recalculate arrival times
            # (simplified - would need time_matrix in real implementation)
            pass
        
        return {
            'all_feasible': len(infeasible) == 0,
            'infeasible': infeasible
        }
    
    def _repair_infeasible(
        self,
        routes: List[Dict],
        infeasible: List[Dict],
        vans: List[Van],
        deliveries: List[DeliveryPoint],
        current_time: datetime
    ) -> List[Dict]:
        """Attempt to repair infeasible routes."""
        
        # Strategy 1: Move critical deliveries to their own routes
        # Strategy 2: Resequence based on deadline priority
        # Strategy 3: Request additional van
        
        return routes  # Simplified
    
    def _format_output(
        self,
        routes: List[Dict],
        deliveries: List[DeliveryPoint],
        vans: List[Van],
        current_time: datetime
    ) -> Dict:
        """Format optimization results for database insertion."""
        
        output_routes = []
        
        for route in routes:
            if not route['stops']:
                continue
            
            waypoints = []
            cumulative_time = 0
            
            for i, stop_idx in enumerate(route['stops']):
                delivery = deliveries[stop_idx]
                
                waypoints.append({
                    'sequence': i + 1,
                    'delivery_id': delivery.id,
                    'hotel_name': delivery.hotel_name,
                    'suit_ids': delivery.suit_ids,
                    'coordinates': delivery.coordinates,
                    'estimated_arrival': (
                        current_time + timedelta(minutes=cumulative_time)
                    ).isoformat(),
                    'deadline': delivery.deadline.isoformat(),
                    'buffer_minutes': (
                        delivery.deadline - 
                        (current_time + timedelta(minutes=cumulative_time))
                    ).total_seconds() / 60
                })
                
                cumulative_time += delivery.service_time + 15  # Simplified travel
            
            output_routes.append({
                'van_id': route['van_id'],
                'total_stops': len(route['stops']),
                'total_suits': route['load'],
                'total_time_minutes': route['total_time'],
                'waypoints': waypoints
            })
        
        return {
            'status': 'optimized',
            'routes': output_routes,
            'total_vans_used': len(output_routes),
            'total_deliveries': sum(len(r['waypoints']) for r in output_routes),
            'optimization_timestamp': current_time.isoformat()
        }
    
    def reoptimize_on_exception(
        self,
        current_routes: List[Dict],
        exception_type: str,
        exception_data: Dict,
        vans: List[Van],
        current_time: datetime
    ) -> Dict:
        """
        Handle real-time re-optimization on exceptions.
        """
        
        if exception_type == 'traffic_delay':
            # Recalculate ETAs and resequence if needed
            affected_route = exception_data['route_id']
            delay_minutes = exception_data['delay_minutes']
            
            # Check which deliveries are now at risk
            at_risk = []
            for route in current_routes:
                if route['van_id'] == affected_route:
                    for waypoint in route['waypoints']:
                        new_eta = (
                            datetime.fromisoformat(waypoint['estimated_arrival']) + 
                            timedelta(minutes=delay_minutes)
                        )
                        if new_eta > datetime.fromisoformat(waypoint['deadline']):
                            at_risk.append(waypoint)
            
            if at_risk:
                # Try to reassign at-risk deliveries to other vans
                return {
                    'action': 'reassign',
                    'at_risk_deliveries': at_risk,
                    'recommendation': 'Transfer to nearest available van'
                }
            else:
                return {
                    'action': 'update_etas',
                    'delay_minutes': delay_minutes
                }
        
        elif exception_type == 'van_breakdown':
            # Reassign all remaining deliveries
            broken_van = exception_data['van_id']
            remaining_deliveries = exception_data['remaining_stops']
            
            return {
                'action': 'full_reassignment',
                'deliveries_to_reassign': remaining_deliveries,
                'recommendation': 'Dispatch backup van immediately'
            }
        
        elif exception_type == 'delivery_failed':
            # Handle failed delivery attempt
            delivery_id = exception_data['delivery_id']
            reason = exception_data['reason']
            
            return {
                'action': 'reschedule',
                'delivery_id': delivery_id,
                'options': [
                    'Retry in 30 minutes',
                    'Contact customer for alternative',
                    'Hold at concierge desk'
                ]
            }
        
        return {'action': 'none'}
```

---

### Algorithm 4: Real-Time Risk Scoring

**Runs:** Continuously (every minute per suit)

**Objective:** Early warning system for delivery risk

```python
"""
Real-Time Risk Scoring Engine

Calculates dynamic risk score for each suit
and triggers interventions when thresholds exceeded.
"""

from dataclasses import dataclass
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import numpy as np


@dataclass
class SuitState:
    id: str
    status: str
    deadline: datetime
    current_stage: str
    time_in_current_stage: int  # minutes
    expected_stage_duration: int
    remaining_stages: List[str]
    assigned_resources: Dict
    location: Optional[Dict]
    

class RiskScoringEngine:
    
    def __init__(self, config: Dict):
        self.config = config
        
        # Expected durations per stage (minutes)
        self.stage_durations = {
            'pattern_generation': 30,
            'tailor_assignment': 15,
            'in_production': 390,  # 6.5 hours
            'qc_inspection': 45,
            'packing': 50,
            'awaiting_flight': 60,
            'in_transit_air': 330,  # 5.5 hours
            'customs': 60,
            'van_assignment': 20,
            'out_for_delivery': 120
        }
        
        # Risk thresholds
        self.thresholds = {
            'amber': 0.3,
            'red': 0.6,
            'critical': 0.8
        }
    
    def calculate_risk_score(
        self,
        suit: SuitState,
        current_time: datetime,
        external_factors: Dict
    ) -> Dict:
        """
        Calculate composite risk score for a suit.
        Returns score (0-1) and contributing factors.
        """
        
        factors = []
        weights = []
        
        # Factor 1: Time Buffer (30%)
        time_score, time_factor = self._calculate_time_risk(suit, current_time)
        factors.append(time_score)
        weights.append(0.30)
        if time_factor:
            factors_detail = [time_factor]
        else:
            factors_detail = []
        
        # Factor 2: Stage Progress (20%)
        stage_score, stage_factor = self._calculate_stage_risk(suit)
        factors.append(stage_score)
        weights.append(0.20)
        if stage_factor:
            factors_detail.append(stage_factor)
        
        # Factor 3: Resource Risk (15%)
        resource_score, resource_factor = self._calculate_resource_risk(suit)
        factors.append(resource_score)
        weights.append(0.15)
        if resource_factor:
            factors_detail.append(resource_factor)
        
        # Factor 4: External Factors (20%)
        external_score, external_factor = self._calculate_external_risk(
            suit, external_factors
        )
        factors.append(external_score)
        weights.append(0.20)
        if external_factor:
            factors_detail.append(external_factor)
        
        # Factor 5: Historical Performance (15%)
        historical_score, hist_factor = self._calculate_historical_risk(suit)
        factors.append(historical_score)
        weights.append(0.15)
        if hist_factor:
            factors_detail.append(hist_factor)
        
        # Calculate weighted score
        composite_score = np.average(factors, weights=weights)
        
        # Determine severity level
        if composite_score >= self.thresholds['critical']:
            severity = 'critical'
        elif composite_score >= self.thresholds['red']:
            severity = 'red'
        elif composite_score >= self.thresholds['amber']:
            severity = 'amber'
        else:
            severity = 'green'
        
        return {
            'score': round(composite_score, 3),
            'severity': severity,
            'factors': factors_detail,
            'breakdown': {
                'time_risk': round(factors[0], 3),
                'stage_risk': round(factors[1], 3),
                'resource_risk': round(factors[2], 3),
                'external_risk': round(factors[3], 3),
                'historical_risk': round(factors[4], 3)
            },
            'recommended_action': self._get_recommended_action(
                composite_score, severity, factors_detail
            )
        }
    
    def _calculate_time_risk(
        self,
        suit: SuitState,
        current_time: datetime
    ) -> tuple:
        """
        Calculate risk based on time remaining vs work remaining.
        """
        
        # Time until deadline
        time_remaining = (suit.deadline - current_time).total_seconds() / 60
        
        # Estimate remaining work time
        remaining_work = sum(
            self.stage_durations.get(stage, 60) 
            for stage in suit.remaining_stages
        )
        
        # Calculate buffer ratio
        if remaining_work == 0:
            buffer_ratio = time_remaining / 60  # Normalize against 1 hour
        else:
            buffer_ratio = time_remaining / remaining_work
        
        # Convert to risk score (inverse - less buffer = higher risk)
        if buffer_ratio >= 2.0:
            score = 0.0  # Plenty of buffer
        elif buffer_ratio >= 1.5:
            score = 0.2
        elif buffer_ratio >= 1.2:
            score = 0.4
        elif buffer_ratio >= 1.0:
            score = 0.6
        elif buffer_ratio >= 0.8:
            score = 0.8
        else:
            score = 1.0  # Critical - not enough time
        
        factor = None
        if score >= 0.6:
            factor = {
                'type': 'time_pressure',
                'description': f'Only {int(time_remaining)} min remaining for {int(remaining_work)} min of work',
                'buffer_ratio': round(buffer_ratio, 2)
            }
        
        return score, factor
    
    def _calculate_stage_risk(self, suit: SuitState) -> tuple:
        """
        Calculate risk based on current stage progress.
        """
        
        expected = self.stage_durations.get(suit.current_stage, 60)
        actual = suit.time_in_current_stage
        
        # Calculate overrun ratio
        if expected == 0:
            overrun_ratio = 0
        else:
            overrun_ratio = actual / expected
        
        # Convert to risk score
        if overrun_ratio <= 0.8:
            score = 0.0
        elif overrun_ratio <= 1.0:
            score = 0.2
        elif overrun_ratio <= 1.2:
            score = 0.4
        elif overrun_ratio <= 1.5:
            score = 0.6
        elif overrun_ratio <= 2.0:
            score = 0.8
        else:
            score = 1.0
        
        factor = None
        if score >= 0.4:
            factor = {
                'type': 'stage_delay',
                'description': f'{suit.current_stage} taking {actual} min (expected {expected})',
                'overrun_ratio': round(overrun_ratio, 2)
            }
        
        return score, factor
    
    def _calculate_resource_risk(self, suit: SuitState) -> tuple:
        """
        Calculate risk based on assigned resource reliability.
        """
        
        resources = suit.assigned_resources
        score = 0.0
        issues = []
        
        # Check tailor assignment
        if resources.get('tailor_primary'):
            tailor_qc_rate = resources.get('tailor_qc_rate', 0.9)
            if tailor_qc_rate < 0.85:
                score += 0.3
                issues.append(f"Tailor QC rate: {tailor_qc_rate:.0%}")
        else:
            if suit.current_stage in ['assigned_tailor', 'in_production']:
                score += 0.5
                issues.append("No tailor assigned")
        
        # Check backup tailor
        if not resources.get('tailor_backup') and suit.current_stage == 'in_production':
            score += 0.2
            issues.append("No backup tailor")
        
        # Check flight assignment
        if suit.current_stage == 'packed' and not resources.get('flight'):
            score += 0.3
            issues.append("No flight assigned")
        
        # Check van assignment
        if suit.current_stage in ['customs_cleared', 'assigned_van']:
            if not resources.get('van'):
                score += 0.4
                issues.append("No van assigned")
        
        score = min(score, 1.0)
        
        factor = None
        if issues:
            factor = {
                'type': 'resource_gap',
                'description': '; '.join(issues)
            }
        
        return score, factor
    
    def _calculate_external_risk(
        self,
        suit: SuitState,
        external_factors: Dict
    ) -> tuple:
        """
        Calculate risk from external factors (weather, traffic, etc).
        """
        
        score = 0.0
        issues = []
        
        # Flight delays
        if external_factors.get('flight_delay_minutes', 0) > 30:
            delay = external_factors['flight_delay_minutes']
            score += min(delay / 120, 0.5)  # Max 0.5 for 2hr delay
            issues.append(f"Flight delayed {delay} min")
        
        # Weather
        weather = external_factors.get('weather', 'clear')
        if weather in ['storm', 'fog']:
            score += 0.4
            issues.append(f"Weather: {weather}")
        elif weather == 'rain':
            score += 0.2
            issues.append("Rain may affect delivery")
        
        # Traffic
        traffic_multiplier = external_factors.get('traffic_multiplier', 1.0)
        if traffic_multiplier > 1.5:
            score += 0.3
            issues.append(f"Heavy traffic ({traffic_multiplier:.1f}x)")
        elif traffic_multiplier > 1.2:
            score += 0.15
        
        # Customs backlog
        customs_backlog = external_factors.get('customs_backlog_minutes', 0)
        if customs_backlog > 60:
            score += 0.3
            issues.append(f"Customs backlog: {customs_backlog} min")
        
        score = min(score, 1.0)
        
        factor = None
        if issues:
            factor = {
                'type': 'external_factors',
                'description': '; '.join(issues)
            }
        
        return score, factor
    
    def _calculate_historical_risk(self, suit: SuitState) -> tuple:
        """
        Calculate risk based on historical patterns.
        """
        
        # This would query historical data for:
        # - Similar routes
        # - Same tailor
        # - Same time of day
        # - Same hotel
        
        # Simplified placeholder
        score = 0.1  # Base risk
        
        return score, None
    
    def _get_recommended_action(
        self,
        score: float,
        severity: str,
        factors: List[Dict]
    ) -> Optional[Dict]:
        """
        Determine recommended intervention based on risk profile.
        """
        
        if severity == 'green':
            return None
        
        # Analyze primary risk factor
        if not factors:
            return {'action': 'monitor', 'urgency': severity}
        
        primary_factor = factors[0]
        
        actions = {
            'time_pressure': {
                'amber': {'action': 'expedite_current_stage', 'notify': ['ops_manager']},
                'red': {'action': 'activate_backup_tailor', 'notify': ['ops_manager', 'customer']},
                'critical': {'action': 'emergency_protocol', 'notify': ['ops_manager', 'customer', 'exec']}
            },
            'stage_delay': {
                'amber': {'action': 'contact_tailor', 'notify': []},
                'red': {'action': 'vapi_call_tailor', 'notify': ['ops_manager']},
                'critical': {'action': 'activate_backup_tailor', 'notify': ['ops_manager', 'customer']}
            },
            'resource_gap': {
                'amber': {'action': 'assign_resource', 'notify': []},
                'red': {'action': 'priority_assignment', 'notify': ['ops_manager']},
                'critical': {'action': 'manual_intervention', 'notify': ['ops_manager', 'exec']}
            },
            'external_factors': {
                'amber': {'action': 'adjust_eta', 'notify': ['customer']},
                'red': {'action': 'reroute_or_reassign', 'notify': ['ops_manager', 'customer']},
                'critical': {'action': 'emergency_backup', 'notify': ['ops_manager', 'customer', 'exec']}
            }
        }
        
        factor_type = primary_factor.get('type', 'unknown')
        
        return actions.get(factor_type, {}).get(severity, {'action': 'monitor'})
```

---

## Integration: Main Orchestrator

```python
"""
Main Logistics Orchestrator

Coordinates all optimization algorithms and manages the event loop.
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List


class LogisticsOrchestrator:
    
    def __init__(
        self,
        db,  # Database connection
        flight_optimizer: FlightPlanningOptimizer,
        tailor_optimizer: TailorAssignmentOptimizer,
        routing_optimizer: VRPTWOptimizer,
        risk_engine: RiskScoringEngine
    ):
        self.db = db
        self.flight_optimizer = flight_optimizer
        self.tailor_optimizer = tailor_optimizer
        self.routing_optimizer = routing_optimizer
        self.risk_engine = risk_engine
        
    async def run(self):
        """Main event loop."""
        
        await asyncio.gather(
            self._risk_monitoring_loop(),
            self._flight_planning_loop(),
            self._tailor_assignment_loop(),
            self._delivery_routing_loop(),
            self._exception_handling_loop()
        )
    
    async def _risk_monitoring_loop(self):
        """Continuous risk monitoring - runs every minute."""
        
        while True:
            # Get all active suits
            suits = await self.db.get_active_suits()
            
            # Get external factors
            external = await self._get_external_factors()
            
            for suit in suits:
                # Calculate risk
                risk = self.risk_engine.calculate_risk_score(
                    suit, datetime.now(), external
                )
                
                # Update database
                await self.db.update_suit_risk(suit.id, risk)
                
                # Trigger alerts if needed
                if risk['severity'] in ['red', 'critical']:
                    await self._create_alert(suit, risk)
                
                # Auto-intervene if configured
                if risk['recommended_action']:
                    await self._execute_intervention(
                        suit, risk['recommended_action']
                    )
            
            await asyncio.sleep(60)  # Run every minute
    
    async def _flight_planning_loop(self):
        """Flight planning - runs 2 hours before each departure."""
        
        while True:
            # Check for upcoming flights needing manifest closure
            flights = await self.db.get_flights_needing_planning()
            
            for flight in flights:
                # Get pending suits
                suits = await self.db.get_suits_pending_flight()
                
                # Run optimizer
                result = self.flight_optimizer.optimize(
                    suits, [flight], datetime.now()
                )
                
                if result['status'] == 'optimal':
                    # Create assignments
                    await self.db.create_flight_assignments(
                        result['assignments']
                    )
                    
                    # Close manifest
                    await self.db.close_flight_manifest(flight.id)
            
            await asyncio.sleep(300)  # Check every 5 minutes
    
    async def _tailor_assignment_loop(self):
        """Tailor assignment - runs on new patterns ready."""
        
        while True:
            # Get suits needing tailor assignment
            suits = await self.db.get_suits_needing_tailor()
            
            # Get available tailors
            tailors = await self.db.get_available_tailors()
            
            for suit in suits:
                # Find optimal tailors
                result = self.tailor_optimizer.find_optimal_tailors(
                    suit, tailors, datetime.now()
                )
                
                if result['status'] in ['dual_post', 'single_post']:
                    # Create assignments
                    await self.db.create_tailor_assignments(
                        suit.id, result
                    )
            
            # Check for unclaimed jobs needing escalation
            unclaimed = await self.db.get_unclaimed_jobs()
            
            for job in unclaimed:
                escalation = self.tailor_optimizer.escalate_unclaimed(
                    job['requirements'],
                    job['posted_tailors'],
                    job['alternatives'],
                    job['posted_at']
                )
                
                if escalation['action'] == 'vapi_escalation':
                    await self._trigger_vapi_calls(escalation)
            
            await asyncio.sleep(30)  # Check every 30 seconds
    
    async def _delivery_routing_loop(self):
        """Delivery routing - runs when flights land."""
        
        while True:
            # Check for landed flights with cleared customs
            cleared = await self.db.get_customs_cleared_batches()
            
            for batch in cleared:
                # Get deliveries
                deliveries = await self.db.get_deliveries_for_batch(batch.id)
                
                # Get available vans
                vans = await self.db.get_available_vans(batch.airport_id)
                
                # Run optimizer
                result = self.routing_optimizer.optimize(
                    deliveries, vans, batch.airport_coordinates, datetime.now()
                )
                
                if result['status'] == 'optimized':
                    # Create routes
                    await self.db.create_delivery_routes(result['routes'])
                    
                    # Dispatch vans
                    await self._dispatch_vans(result['routes'])
            
            await asyncio.sleep(60)  # Check every minute
    
    async def _exception_handling_loop(self):
        """Handle exceptions in real-time."""
        
        while True:
            # Subscribe to exception events
            exceptions = await self.db.get_pending_exceptions()
            
            for exc in exceptions:
                # Determine response
                if exc['type'] == 'traffic_delay':
                    response = self.routing_optimizer.reoptimize_on_exception(
                        exc['current_routes'],
                        exc['type'],
                        exc['data'],
                        exc['available_vans'],
                        datetime.now()
                    )
                    
                    if response['action'] == 'reassign':
                        await self._reassign_deliveries(response)
                
                elif exc['type'] == 'qc_fail':
                    # Activate backup suit
                    await self._activate_backup_suit(exc['suit_id'])
                
                elif exc['type'] == 'flight_delay':
                    # Recalculate all affected ETAs
                    await self._handle_flight_delay(exc)
                
                # Mark exception handled
                await self.db.mark_exception_handled(exc['id'])
            
            await asyncio.sleep(10)  # Check every 10 seconds
```

---

This gives you:

1. **Complete database schema** with 20+ tables covering every entity
2. **Flight planning optimizer** that chooses single vs dual-drop routing
3. **Tailor assignment optimizer** with dual-posting and VAPI escalation
4. **Vehicle routing optimizer** (VRPTW) for ground delivery
5. **Real-time risk scoring** with automatic interventions
6. **Main orchestrator** coordinating all systems

Want me to detail the API endpoints, the real-time event subscription system, or the dashboard data queries?



## Prompt:
1/19/2026, 7:45:28 PM

detail the API endpoints, the real-time event subscription system and the dashboard data queries



## Response:
1/19/2026, 7:50:26 PM

````plaintext
Thought process: Orchestrated comprehensive documentation across three technical domains.

The user wants me to detail three things:
1. API endpoints
2. Real-time event subscription system
3. Dashboard data queries

Let me create comprehensive documentation for each of these.
````

## Part 1: API Endpoints

### API Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         API Gateway                              │
│                    (Authentication + Rate Limiting)              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │   Public     │  │   Internal   │  │   Webhooks   │          │
│  │   API        │  │   API        │  │   Receivers  │          │
│  │              │  │              │  │              │          │
│  │ • Customer   │  │ • Tailor App │  │ • Stripe     │          │
│  │ • Tracking   │  │ • QC App     │  │ • Flight API │          │
│  │ • Orders     │  │ • Driver App │  │ • Courier    │          │
│  │              │  │ • Admin      │  │ • GPS        │          │
│  └──────────────┘  └──────────────┘  └──────────────┘          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### Base Configuration

```typescript
// Base URL structure
const API_BASE = 'https://api.suitai.com/v1';

// Authentication
// - Customer API: JWT tokens
// - Internal API: API keys + JWT
// - Webhooks: Signature verification

// Rate Limits
// - Customer: 100 req/min
// - Internal: 1000 req/min
// - Webhooks: Unlimited (verified sources)
```

---

### 1. Customer-Facing API

#### Orders

```yaml
# Create Order
POST /orders
Authorization: Bearer {customer_jwt}
Content-Type: application/json

Request:
{
  "customer_id": "uuid",
  "destination": {
    "hotel_id": "uuid",
    "room_number": "1205",
    "guest_name": "John Smith",
    "special_instructions": "Leave with concierge if unavailable"
  },
  "suits": [
    {
      "style_id": "uuid",
      "fabric_id": "uuid",
      "customizations": {
        "lapel": "notch",
        "buttons": "two",
        "vents": "double",
        "lining_color": "burgundy"
      },
      "measurements_id": "uuid"
    }
  ],
  "express_delivery": true
}

Response: 201 Created
{
  "id": "uuid",
  "order_number": "ORD-2026-01-19-0847",
  "status": "pending_payment",
  "suits": [
    {
      "id": "uuid",
      "suit_number": "SUIT-2026-01-19-0847",
      "status": "pending_production"
    }
  ],
  "total_amount": {
    "currency": "AED",
    "amount": 22000.00
  },
  "deadline": "2026-01-20T14:00:00+04:00",
  "payment_url": "https://checkout.stripe.com/...",
  "created_at": "2026-01-19T14:00:00+04:00"
}

# Get Order
GET /orders/{order_id}
Authorization: Bearer {customer_jwt}

Response: 200 OK
{
  "id": "uuid",
  "order_number": "ORD-2026-01-19-0847",
  "status": "in_production",
  "suits": [...],
  "destination": {...},
  "timeline": {
    "ordered_at": "2026-01-19T14:00:00+04:00",
    "payment_captured_at": "2026-01-19T14:02:00+04:00",
    "production_started_at": "2026-01-19T14:45:00+04:00",
    "estimated_completion": "2026-01-19T21:30:00+04:00",
    "estimated_delivery": "2026-01-20T10:00:00+04:00"
  },
  "deadline": "2026-01-20T14:00:00+04:00"
}

# List Customer Orders
GET /orders?status={status}&limit={limit}&offset={offset}
Authorization: Bearer {customer_jwt}

Response: 200 OK
{
  "orders": [...],
  "pagination": {
    "total": 12,
    "limit": 10,
    "offset": 0,
    "has_more": true
  }
}

# Cancel Order (if not yet in production)
POST /orders/{order_id}/cancel
Authorization: Bearer {customer_jwt}

Request:
{
  "reason": "Changed travel plans"
}

Response: 200 OK
{
  "id": "uuid",
  "status": "cancelled",
  "refund": {
    "amount": 22000.00,
    "currency": "AED",
    "status": "processing",
    "estimated_completion": "2026-01-22T00:00:00+04:00"
  }
}
```

#### Tracking

```yaml
# Get Suit Tracking
GET /tracking/{suit_number}
Authorization: Bearer {customer_jwt} OR Public (with order_id query param)

Response: 200 OK
{
  "suit_number": "SUIT-2026-01-19-0847",
  "status": "out_for_delivery",
  "status_display": "Out for Delivery",
  "progress_percentage": 85,
  
  "current_location": {
    "type": "van",
    "description": "En route to Burj Al Arab",
    "coordinates": [25.1312, 55.1175],
    "updated_at": "2026-01-20T09:45:00+04:00"
  },
  
  "eta": {
    "estimated_arrival": "2026-01-20T10:15:00+04:00",
    "confidence": "high",
    "window_minutes": 15
  },
  
  "timeline": [
    {
      "status": "order_placed",
      "timestamp": "2026-01-19T14:00:00+04:00",
      "completed": true
    },
    {
      "status": "in_production",
      "timestamp": "2026-01-19T14:45:00+04:00",
      "completed": true
    },
    {
      "status": "quality_check",
      "timestamp": "2026-01-19T21:30:00+04:00",
      "completed": true
    },
    {
      "status": "shipped",
      "timestamp": "2026-01-19T23:30:00+04:00",
      "completed": true
    },
    {
      "status": "arrived_uae",
      "timestamp": "2026-01-20T06:30:00+04:00",
      "completed": true
    },
    {
      "status": "out_for_delivery",
      "timestamp": "2026-01-20T09:30:00+04:00",
      "completed": true
    },
    {
      "status": "delivered",
      "timestamp": null,
      "completed": false,
      "eta": "2026-01-20T10:15:00+04:00"
    }
  ],
  
  "delivery": {
    "hotel": "Burj Al Arab",
    "address": "Jumeirah Beach Road, Dubai",
    "recipient": "John Smith",
    "driver": {
      "name": "Ahmed",
      "phone": "+971-50-XXX-XXXX",
      "vehicle": "White Mercedes Vito"
    }
  }
}

# Get Live Location (WebSocket upgrade available)
GET /tracking/{suit_number}/live
Authorization: Bearer {customer_jwt}

Response: 200 OK (or 101 Switching Protocols for WebSocket)
{
  "suit_number": "SUIT-2026-01-19-0847",
  "location": {
    "coordinates": [25.1312, 55.1175],
    "heading": 245,
    "speed_kmh": 42,
    "updated_at": "2026-01-20T09:45:32+04:00"
  },
  "eta_minutes": 28,
  "distance_km": 12.4
}
```

#### Measurements

```yaml
# Submit Measurements (from 3D scan)
POST /measurements
Authorization: Bearer {customer_jwt}
Content-Type: application/json

Request:
{
  "scan_data": {
    "format": "obj",
    "data": "base64_encoded_scan_data...",
    "capture_device": "iphone_14_pro",
    "capture_timestamp": "2026-01-19T13:45:00+04:00"
  },
  "manual_overrides": {
    "chest": 102,
    "waist": 86
  }
}

Response: 201 Created
{
  "id": "uuid",
  "status": "processing",
  "estimated_completion_seconds": 30
}

# Get Measurements
GET /measurements/{measurement_id}
Authorization: Bearer {customer_jwt}

Response: 200 OK
{
  "id": "uuid",
  "status": "validated",
  "quality_score": 0.94,
  "measurements": {
    "chest": 102.5,
    "waist": 86.0,
    "hips": 98.5,
    "shoulders": 46.5,
    "arm_length": 65.0,
    "inseam": 82.0,
    // ... 28 total measurements
  },
  "validation": {
    "passed": true,
    "warnings": [
      {
        "field": "chest",
        "message": "Slightly above average - please confirm"
      }
    ]
  },
  "created_at": "2026-01-19T13:45:30+04:00"
}
```

---

### 2. Tailor App API

#### Job Board

```yaml
# Get Available Jobs
GET /tailor/jobs/available
Authorization: Bearer {tailor_jwt}

Query Params:
- fabric_variant: Filter by fabric code
- skill_level: Filter by minimum skill required
- sort: 'deadline' | 'payout' | 'distance'

Response: 200 OK
{
  "jobs": [
    {
      "id": "uuid",
      "suit_number": "SUIT-2026-01-19-0847",
      "job_type": "two_piece_suit",
      "style": "Slim Fit",
      "fabric": {
        "code": "SF150-NAVY-001",
        "name": "Saffire 150s Navy"
      },
      "complexity": "standard",
      "deadline": "2026-01-19T18:00:00+05:30",
      "payout": {
        "fabric_allowance": 4500,
        "labor_fee": 4000,
        "rush_bonus": 2000,
        "total": 10500,
        "currency": "INR"
      },
      "posted_at": "2026-01-19T15:00:00+05:30",
      "time_remaining_minutes": 180,
      "distance_to_you_meters": 450
    }
  ],
  "total_available": 12
}

# Claim Job
POST /tailor/jobs/{job_id}/claim
Authorization: Bearer {tailor_jwt}

Request:
{
  "confirm_fabric_stock": true,
  "estimated_completion_hours": 6
}

Response: 200 OK
{
  "assignment_id": "uuid",
  "status": "claimed",
  "suit_number": "SUIT-2026-01-19-0847",
  "deadline": "2026-01-19T18:00:00+05:30",
  "tech_pack_url": "https://cdn.suitai.com/techpacks/...",
  "pattern_status": "dispatching",
  "pattern_eta_minutes": 15
}

Response: 409 Conflict (already claimed)
{
  "error": "job_already_claimed",
  "message": "This job was claimed by another tailor"
}

# Get My Active Jobs
GET /tailor/jobs/active
Authorization: Bearer {tailor_jwt}

Response: 200 OK
{
  "jobs": [
    {
      "assignment_id": "uuid",
      "suit_number": "SUIT-2026-01-19-0847",
      "status": "in_production",
      "current_stage": "body_assembly",
      "deadline": "2026-01-19T18:00:00+05:30",
      "time_remaining_minutes": 120,
      "pattern_received": true,
      "stages": [
        {"name": "fabric_cutting", "status": "completed", "completed_at": "..."},
        {"name": "canvas_fusing", "status": "completed", "completed_at": "..."},
        {"name": "body_assembly", "status": "in_progress", "started_at": "..."},
        {"name": "sleeve_setting", "status": "pending"},
        {"name": "collar_lapel", "status": "pending"},
        {"name": "trouser_construction", "status": "pending"},
        {"name": "hand_finishing", "status": "pending"},
        {"name": "final_press", "status": "pending"}
      ]
    }
  ]
}
```

#### Production Updates

```yaml
# Update Production Stage
POST /tailor/jobs/{assignment_id}/stage
Authorization: Bearer {tailor_jwt}
Content-Type: multipart/form-data

Request:
{
  "stage": "body_assembly",
  "status": "completed",
  "photo": <file>,
  "notes": "Panel alignment perfect"
}

Response: 200 OK
{
  "assignment_id": "uuid",
  "stage": "body_assembly",
  "status": "completed",
  "next_stage": "sleeve_setting",
  "time_remaining_minutes": 90,
  "on_track": true
}

# Mark Job Complete
POST /tailor/jobs/{assignment_id}/complete
Authorization: Bearer {tailor_jwt}
Content-Type: multipart/form-data

Request:
{
  "photos": [<file>, <file>, <file>],
  "notes": "Ready for QC inspection"
}

Response: 200 OK
{
  "assignment_id": "uuid",
  "status": "ready_for_qc",
  "qc_scheduled": true,
  "qc_eta_minutes": 30,
  "inspector": {
    "name": "Rajesh Kumar",
    "phone": "+91-XXX-XXX-XXXX",
    "eta": "2026-01-19T17:45:00+05:30"
  }
}

# Report Issue
POST /tailor/jobs/{assignment_id}/issue
Authorization: Bearer {tailor_jwt}

Request:
{
  "issue_type": "fabric_defect",
  "description": "Small snag found in fabric during cutting",
  "severity": "minor",
  "photo": <file>,
  "can_continue": true
}

Response: 200 OK
{
  "issue_id": "uuid",
  "status": "reported",
  "response_eta_minutes": 15,
  "instruction": "Continue production, document defect location"
}
```

#### Pattern Receipt

```yaml
# Confirm Pattern Receipt
POST /tailor/patterns/{dispatch_id}/received
Authorization: Bearer {tailor_jwt}

Request:
{
  "received_at": "2026-01-19T15:30:00+05:30",
  "pieces_count": 24,
  "condition": "good",
  "photo": <file>
}

Response: 200 OK
{
  "dispatch_id": "uuid",
  "status": "received",
  "sla_timer_started": true,
  "deadline": "2026-01-19T18:00:00+05:30",
  "time_remaining_minutes": 150
}
```

---

### 3. QC Inspector App API

```yaml
# Get Assigned Inspections
GET /inspector/inspections
Authorization: Bearer {inspector_jwt}

Response: 200 OK
{
  "inspections": [
    {
      "id": "uuid",
      "suit_number": "SUIT-2026-01-19-0847",
      "tailor": {
        "name": "Amit Sharma",
        "address": "123 Tailor Lane, Amritsar",
        "phone": "+91-XXX-XXX-XXXX",
        "coordinates": [31.6340, 74.8723]
      },
      "scheduled_time": "2026-01-19T17:45:00+05:30",
      "priority": "high",
      "tech_pack_url": "https://cdn.suitai.com/techpacks/...",
      "key_measurements": {
        "chest": 102.5,
        "waist": 86.0,
        "jacket_length": 74.0,
        "trouser_length": 102.0
      }
    }
  ]
}

# Start Inspection
POST /inspector/inspections/{inspection_id}/start
Authorization: Bearer {inspector_jwt}

Request:
{
  "arrived_at": "2026-01-19T17:43:00+05:30",
  "location_confirmed": true
}

Response: 200 OK
{
  "inspection_id": "uuid",
  "status": "in_progress",
  "checklist": [
    {
      "category": "visual",
      "items": [
        {"id": "v1", "name": "Overall appearance", "type": "score_1_5"},
        {"id": "v2", "name": "Symmetry", "type": "score_1_5"},
        {"id": "v3", "name": "Fabric condition", "type": "pass_fail"},
        {"id": "v4", "name": "Color consistency", "type": "pass_fail"}
      ]
    },
    {
      "category": "measurements",
      "items": [
        {"id": "m1", "name": "Chest", "target": 102.5, "tolerance": 1.0, "type": "measurement"},
        {"id": "m2", "name": "Waist", "target": 86.0, "tolerance": 1.0, "type": "measurement"},
        {"id": "m3", "name": "Jacket length", "target": 74.0, "tolerance": 0.5, "type": "measurement"}
      ]
    },
    {
      "category": "construction",
      "items": [
        {"id": "c1", "name": "Seam quality", "type": "score_1_5"},
        {"id": "c2", "name": "Canvas attachment", "type": "pass_fail"},
        {"id": "c3", "name": "Buttonhole quality", "type": "score_1_5"},
        {"id": "c4", "name": "Lining attachment", "type": "pass_fail"}
      ]
    }
  ]
}

# Submit Inspection Result
POST /inspector/inspections/{inspection_id}/submit
Authorization: Bearer {inspector_jwt}
Content-Type: multipart/form-data

Request:
{
  "result": "pass",
  "scores": {
    "v1": 5,
    "v2": 4,
    "v3": "pass",
    "v4": "pass",
    "m1": 102.3,
    "m2": 86.1,
    "m3": 74.0,
    "c1": 5,
    "c2": "pass",
    "c3": 4,
    "c4": "pass"
  },
  "overall_score": 4.5,
  "photos": [<file>, <file>, <file>],
  "notes": "Excellent construction quality"
}

Response: 200 OK
{
  "inspection_id": "uuid",
  "result": "pass",
  "suit_status": "qc_passed",
  "payout_triggered": true,
  "collection_method": "inspector_takes",
  "next_steps": "Please bring suit to QC station for packing"
}

# Submit QC Fail
POST /inspector/inspections/{inspection_id}/submit
Authorization: Bearer {inspector_jwt}

Request:
{
  "result": "fail",
  "scores": {...},
  "issues": [
    {
      "category": "measurement",
      "item": "m1",
      "expected": 102.5,
      "actual": 104.8,
      "severity": "major",
      "photo": <file>
    }
  ],
  "rework_required": true,
  "rework_instructions": "Jacket chest needs taking in by 2.3cm"
}

Response: 200 OK
{
  "inspection_id": "uuid",
  "result": "fail",
  "suit_status": "qc_failed",
  "rework_assignment": {
    "id": "uuid",
    "tailor_notified": true,
    "rework_deadline": "2026-01-19T19:30:00+05:30"
  },
  "backup_suit_status": "activating"
}
```

---

### 4. Driver App API

```yaml
# Get Today's Routes
GET /driver/routes
Authorization: Bearer {driver_jwt}

Response: 200 OK
{
  "routes": [
    {
      "id": "uuid",
      "van_id": "uuid",
      "status": "assigned",
      "start_location": {
        "name": "Sharjah Airport Cargo",
        "coordinates": [25.3285, 55.5172]
      },
      "total_stops": 8,
      "total_suits": 18,
      "estimated_duration_minutes": 165,
      "estimated_distance_km": 78,
      "start_time": "2026-01-20T09:30:00+04:00"
    }
  ]
}

# Get Route Details
GET /driver/routes/{route_id}
Authorization: Bearer {driver_jwt}

Response: 200 OK
{
  "id": "uuid",
  "status": "in_progress",
  "current_stop_index": 2,
  "stops": [
    {
      "sequence": 1,
      "status": "completed",
      "hotel": {
        "name": "Address Downtown",
        "address": "Sheikh Mohammed bin Rashid Blvd",
        "coordinates": [25.1936, 55.2796],
        "delivery_entrance": "Main lobby, valet area",
        "concierge_phone": "+971-4-XXX-XXXX"
      },
      "suits": [
        {
          "suit_number": "SUIT-2026-01-19-0842",
          "recipient": "James Wilson",
          "room": "2305"
        }
      ],
      "eta": "2026-01-20T09:45:00+04:00",
      "actual_arrival": "2026-01-20T09:43:00+04:00",
      "delivered_at": "2026-01-20T09:48:00+04:00"
    },
    {
      "sequence": 2,
      "status": "completed",
      "hotel": {...},
      "suits": [...],
      "delivered_at": "2026-01-20T10:05:00+04:00"
    },
    {
      "sequence": 3,
      "status": "in_transit",
      "hotel": {
        "name": "Burj Al Arab",
        "address": "Jumeirah Beach Road",
        "coordinates": [25.1412, 55.1853],
        "delivery_entrance": "Service entrance, Gate 2",
        "concierge_phone": "+971-4-XXX-XXXX"
      },
      "suits": [
        {
          "suit_number": "SUIT-2026-01-19-0847",
          "recipient": "John Smith",
          "room": "1205"
        },
        {
          "suit_number": "SUIT-2026-01-19-0851",
          "recipient": "Michael Brown",
          "room": "Royal Suite"
        }
      ],
      "eta": "2026-01-20T10:25:00+04:00",
      "distance_km": 8.5,
      "traffic_status": "moderate"
    },
    // ... more stops
  ],
  "navigation_url": "https://maps.google.com/..."
}

# Update Location (called automatically every 30 seconds)
POST /driver/location
Authorization: Bearer {driver_jwt}

Request:
{
  "coordinates": [25.1312, 55.1175],
  "heading": 245,
  "speed_kmh": 42,
  "accuracy_meters": 5,
  "timestamp": "2026-01-20T10:15:32+04:00"
}

Response: 200 OK
{
  "received": true,
  "route_update": {
    "current_stop_eta_minutes": 8,
    "route_on_track": true
  }
}

# Arrive at Stop
POST /driver/routes/{route_id}/stops/{stop_sequence}/arrive
Authorization: Bearer {driver_jwt}

Request:
{
  "arrived_at": "2026-01-20T10:23:00+04:00",
  "coordinates": [25.1412, 55.1852]
}

Response: 200 OK
{
  "stop_sequence": 3,
  "status": "arrived",
  "suits_to_deliver": [
    {
      "suit_number": "SUIT-2026-01-19-0847",
      "recipient": "John Smith",
      "room": "1205",
      "verification_code": "JS7847"
    },
    {
      "suit_number": "SUIT-2026-01-19-0851",
      "recipient": "Michael Brown",
      "room": "Royal Suite",
      "verification_code": "MB7851"
    }
  ],
  "hotel_notified": true
}

# Complete Delivery
POST /driver/routes/{route_id}/stops/{stop_sequence}/deliver
Authorization: Bearer {driver_jwt}
Content-Type: multipart/form-data

Request:
{
  "suits": [
    {
      "suit_number": "SUIT-2026-01-19-0847",
      "delivered_to": "concierge",
      "recipient_name": "Ahmed (Concierge)",
      "signature": <file>,
      "photo": <file>
    },
    {
      "suit_number": "SUIT-2026-01-19-0851",
      "delivered_to": "customer",
      "recipient_name": "Michael Brown",
      "signature": <file>
    }
  ],
  "completed_at": "2026-01-20T10:35:00+04:00"
}

Response: 200 OK
{
  "stop_sequence": 3,
  "status": "completed",
  "suits_delivered": 2,
  "next_stop": {
    "sequence": 4,
    "hotel": "Atlantis The Palm",
    "eta_minutes": 22,
    "navigation_url": "https://maps.google.com/..."
  },
  "customer_notifications_sent": true
}

# Report Delivery Issue
POST /driver/routes/{route_id}/stops/{stop_sequence}/issue
Authorization: Bearer {driver_jwt}

Request:
{
  "issue_type": "customer_unavailable",
  "suit_numbers": ["SUIT-2026-01-19-0847"],
  "description": "Guest not in room, concierge unable to accept",
  "attempted_at": "2026-01-20T10:30:00+04:00"
}

Response: 200 OK
{
  "issue_id": "uuid",
  "status": "reported",
  "resolution": {
    "action": "hold_and_retry",
    "instruction": "Hold suit, continue route. Return attempt scheduled for 14:00",
    "retry_time": "2026-01-20T14:00:00+04:00"
  },
  "customer_notified": true,
  "ops_alerted": true
}
```

---

### 5. Admin/Operations API

```yaml
# Dashboard Summary
GET /admin/dashboard/summary
Authorization: Bearer {admin_jwt}

Query Params:
- date: YYYY-MM-DD (default: today)
- timezone: UTC offset

Response: 200 OK
{
  "date": "2026-01-20",
  "pipeline": {
    "orders_received": 287,
    "in_production": 156,
    "in_qc": 43,
    "packed": 112,
    "in_transit": 89,
    "out_for_delivery": 67,
    "delivered": 342
  },
  "risk": {
    "green": 412,
    "amber": 45,
    "red": 8,
    "critical": 2
  },
  "performance": {
    "on_time_rate": 0.967,
    "qc_pass_rate": 0.912,
    "avg_production_time_hours": 6.2,
    "avg_delivery_time_hours": 20.8
  },
  "flights": {
    "today": [
      {
        "id": "uuid",
        "flight_number": "CHARTER-2026-01-20-AM",
        "status": "landed",
        "suits_loaded": 267,
        "departed_at": "2026-01-20T02:00:00+05:30",
        "landed_at": "2026-01-20T06:30:00+04:00"
      },
      {
        "id": "uuid",
        "flight_number": "CHARTER-2026-01-20-PM",
        "status": "boarding",
        "suits_loaded": 289,
        "scheduled_departure": "2026-01-20T14:00:00+05:30"
      }
    ]
  },
  "ground_fleet": {
    "total_vans": 5,
    "active": 4,
    "available": 1,
    "total_suits_out": 67
  }
}

# Get Alerts
GET /admin/alerts
Authorization: Bearer {admin_jwt}

Query Params:
- status: 'open' | 'acknowledged' | 'resolved'
- severity: 'info' | 'warning' | 'critical'
- entity_type: 'suit' | 'flight' | 'van' | 'tailor'
- limit: number
- offset: number

Response: 200 OK
{
  "alerts": [
    {
      "id": "uuid",
      "severity": "critical",
      "entity_type": "suit",
      "entity_id": "uuid",
      "suit_number": "SUIT-2026-01-19-0923",
      "title": "QC Failed - Both Primary and Backup",
      "description": "Both suit productions failed QC. No backup available.",
      "risk_score": 0.92,
      "risk_factors": [
        {"type": "qc_fail", "description": "Both tailors failed inspection"},
        {"type": "time_pressure", "description": "Only 4 hours to deadline"}
      ],
      "recommended_action": {
        "action": "emergency_production",
        "details": "Assign to master tailor with expedited timeline"
      },
      "created_at": "2026-01-20T08:30:00+04:00",
      "status": "open"
    }
  ],
  "counts": {
    "open": 12,
    "critical_open": 2
  }
}

# Acknowledge Alert
POST /admin/alerts/{alert_id}/acknowledge
Authorization: Bearer {admin_jwt}

Request:
{
  "notes": "Reviewing situation, contacting master tailor"
}

Response: 200 OK
{
  "alert_id": "uuid",
  "status": "acknowledged",
  "acknowledged_by": "admin_user_name",
  "acknowledged_at": "2026-01-20T08:35:00+04:00"
}

# Resolve Alert
POST /admin/alerts/{alert_id}/resolve
Authorization: Bearer {admin_jwt}

Request:
{
  "resolution_action": "emergency_production_assigned",
  "notes": "Master tailor Vikram accepted emergency job, 3-hour turnaround"
}

Response: 200 OK
{
  "alert_id": "uuid",
  "status": "resolved",
  "resolved_by": "admin_user_name",
  "resolved_at": "2026-01-20T08:40:00+04:00"
}

# Manual Intervention
POST /admin/suits/{suit_id}/intervene
Authorization: Bearer {admin_jwt}

Request:
{
  "intervention_type": "reassign_tailor",
  "params": {
    "new_tailor_id": "uuid",
    "reason": "Original tailor equipment failure",
    "expedite": true
  }
}

Response: 200 OK
{
  "suit_id": "uuid",
  "intervention_id": "uuid",
  "result": "success",
  "new_assignment": {
    "tailor_id": "uuid",
    "tailor_name": "Vikram Singh",
    "new_deadline": "2026-01-20T12:00:00+05:30"
  },
  "timeline_impact": {
    "estimated_delay_minutes": 0,
    "still_on_track": true
  }
}

# Flight Operations
GET /admin/flights/{flight_id}
Authorization: Bearer {admin_jwt}

Response: 200 OK
{
  "id": "uuid",
  "flight_number": "CHARTER-2026-01-20-PM",
  "status": "boarding",
  "aircraft": {
    "type": "SAAB_340F",
    "registration": "VT-XXX",
    "capacity": 540
  },
  "route": {
    "type": "dual_drop",
    "legs": [
      {
        "leg_number": 1,
        "origin": "ATQ",
        "destination": "MCT",
        "type": "fuel_stop",
        "scheduled_departure": "2026-01-20T14:00:00+05:30",
        "scheduled_arrival": "2026-01-20T16:30:00+04:00"
      },
      {
        "leg_number": 2,
        "origin": "MCT",
        "destination": "AUH",
        "type": "cargo_drop",
        "scheduled_departure": "2026-01-20T17:15:00+04:00",
        "scheduled_arrival": "2026-01-20T18:15:00+04:00",
        "suits_to_unload": 98
      },
      {
        "leg_number": 3,
        "origin": "AUH",
        "destination": "SHJ",
        "type": "final",
        "scheduled_departure": "2026-01-20T19:00:00+04:00",
        "scheduled_arrival": "2026-01-20T19:25:00+04:00",
        "suits_to_unload": 191
      }
    ]
  },
  "manifest": {
    "total_suits": 289,
    "by_destination": {
      "AUH": 98,
      "SHJ": 191
    },
    "closed_at": "2026-01-20T12:00:00+05:30"
  },
  "cost": {
    "charter_base": 17000,
    "additional_stop": 2500,
    "total_gbp": 19500,
    "per_suit_gbp": 67.47
  }
}

# Modify Flight Route
POST /admin/flights/{flight_id}/modify-route
Authorization: Bearer {admin_jwt}

Request:
{
  "new_route_type": "single_hub",
  "destination": "SHJ",
  "reason": "Abu Dhabi volume dropped below threshold"
}

Response: 200 OK
{
  "flight_id": "uuid",
  "route_modified": true,
  "new_route": {...},
  "suits_reassigned": 98,
  "cost_savings_gbp": 2500
}
```

---

### 6. Webhook Receivers

```yaml
# Stripe Payment Webhook
POST /webhooks/stripe
Stripe-Signature: {signature}

Payload:
{
  "type": "payment_intent.succeeded",
  "data": {
    "object": {
      "id": "pi_xxx",
      "amount": 2200000,
      "currency": "aed",
      "metadata": {
        "order_id": "uuid"
      }
    }
  }
}

Processing:
1. Verify signature
2. Update order status to 'paid'
3. Trigger production pipeline
4. Send confirmation to customer

# Flight Tracking Webhook (FlightAware)
POST /webhooks/flightaware
X-FlightAware-Signature: {signature}

Payload:
{
  "event_type": "departure",
  "flight_id": "xxx",
  "timestamp": "2026-01-20T14:05:00Z",
  "position": {
    "lat": 31.7096,
    "lon": 74.7986,
    "altitude": 5000,
    "heading": 245
  }
}

Processing:
1. Verify signature
2. Update flight status
3. Recalculate ETAs for all suits on flight
4. Broadcast to real-time subscribers

# GPS Tracker Webhook
POST /webhooks/gps
X-API-Key: {api_key}

Payload:
{
  "device_id": "van_01_gps",
  "timestamp": "2026-01-20T10:15:32+04:00",
  "position": {
    "lat": 25.1312,
    "lon": 55.1175,
    "speed_kmh": 42,
    "heading": 245
  }
}

Processing:
1. Validate API key
2. Update van location in database
3. Recalculate ETAs for deliveries
4. Check for route deviations
5. Broadcast to real-time subscribers

# Customs Clearance Webhook
POST /webhooks/customs
X-Broker-Signature: {signature}

Payload:
{
  "event_type": "clearance_complete",
  "shipment_reference": "SUIT-CHARTER-2026-01-20-AM",
  "airport": "SHJ",
  "cleared_at": "2026-01-20T07:15:00+04:00",
  "items_count": 267
}

Processing:
1. Verify signature
2. Update all suits to 'customs_cleared'
3. Trigger van dispatch optimization
4. Notify drivers
5. Update customer ETAs
```

---

## Part 2: Real-Time Event Subscription System

### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Event Bus (Redis Streams)                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐                          ┌─────────────┐       │
│  │  Publishers │                          │ Subscribers │       │
│  │             │                          │             │       │
│  │ • API       │  ──── Events ────────▶  │ • WebSocket │       │
│  │ • Webhooks  │                          │ • Workers   │       │
│  │ • Workers   │                          │ • Notifiers │       │
│  │ • Cron      │                          │ • Analytics │       │
│  └─────────────┘                          └─────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Event Types

```typescript
// Event Schema
interface BaseEvent {
  id: string;              // UUID
  type: string;            // Event type
  timestamp: string;       // ISO 8601
  source: string;          // Origin service
  correlation_id?: string; // For tracing
  metadata?: Record<string, any>;
}

// Event Categories
enum EventCategory {
  SUIT = 'suit',
  ORDER = 'order',
  PRODUCTION = 'production',
  FLIGHT = 'flight',
  DELIVERY = 'delivery',
  ALERT = 'alert',
  SYSTEM = 'system'
}
```

### Event Definitions

```typescript
// ============================================
// SUIT EVENTS
// ============================================

interface SuitStatusChangedEvent extends BaseEvent {
  type: 'suit.status.changed';
  payload: {
    suit_id: string;
    suit_number: string;
    order_id: string;
    previous_status: string;
    new_status: string;
    location?: {
      type: string;
      coordinates?: [number, number];
    };
    risk_score?: number;
  };
}

interface SuitLocationUpdatedEvent extends BaseEvent {
  type: 'suit.location.updated';
  payload: {
    suit_id: string;
    suit_number: string;
    location_type: 'tailor' | 'qc_station' | 'hq' | 'aircraft' | 'van';
    coordinates: [number, number];
    heading?: number;
    speed_kmh?: number;
    eta_destination?: string;
  };
}

interface SuitRiskChangedEvent extends BaseEvent {
  type: 'suit.risk.changed';
  payload: {
    suit_id: string;
    suit_number: string;
    previous_score: number;
    new_score: number;
    previous_severity: string;
    new_severity: string;
    risk_factors: Array<{
      type: string;
      description: string;
      weight: number;
    }>;
    recommended_action?: {
      action: string;
      urgency: string;
    };
  };
}

interface SuitDeliveredEvent extends BaseEvent {
  type: 'suit.delivered';
  payload: {
    suit_id: string;
    suit_number: string;
    order_id: string;
    customer_id: string;
    delivered_at: string;
    delivered_to: 'customer' | 'concierge' | 'front_desk';
    recipient_name: string;
    hotel: string;
    time_from_order_hours: number;
    was_on_time: boolean;
  };
}

// ============================================
// PRODUCTION EVENTS
// ============================================

interface TailorJobClaimedEvent extends BaseEvent {
  type: 'production.job.claimed';
  payload: {
    assignment_id: string;
    suit_id: string;
    tailor_id: string;
    tailor_name: string;
    assignment_type: 'primary' | 'backup';
    deadline: string;
    time_to_claim_minutes: number;
  };
}

interface ProductionStageCompletedEvent extends BaseEvent {
  type: 'production.stage.completed';
  payload: {
    assignment_id: string;
    suit_id: string;
    tailor_id: string;
    stage: string;
    duration_minutes: number;
    expected_duration_minutes: number;
    stages_remaining: number;
    on_track: boolean;
  };
}

interface QCCompletedEvent extends BaseEvent {
  type: 'production.qc.completed';
  payload: {
    inspection_id: string;
    suit_id: string;
    assignment_id: string;
    tailor_id: string;
    result: 'pass' | 'fail' | 'conditional_pass';
    overall_score: number;
    issues?: Array<{
      category: string;
      description: string;
      severity: string;
    }>;
    payout_triggered: boolean;
    backup_activated?: boolean;
  };
}

// ============================================
// FLIGHT EVENTS
// ============================================

interface FlightStatusChangedEvent extends BaseEvent {
  type: 'flight.status.changed';
  payload: {
    flight_id: string;
    flight_number: string;
    previous_status: string;
    new_status: string;
    suits_count: number;
    current_position?: {
      coordinates: [number, number];
      altitude_feet: number;
      heading: number;
      speed_knots: number;
    };
  };
}

interface FlightDelayedEvent extends BaseEvent {
  type: 'flight.delayed';
  payload: {
    flight_id: string;
    flight_number: string;
    delay_minutes: number;
    reason?: string;
    new_arrival_time: string;
    suits_affected: number;
    suits_at_risk: Array<{
      suit_id: string;
      suit_number: string;
      new_risk_score: number;
    }>;
  };
}

interface FlightLandedEvent extends BaseEvent {
  type: 'flight.landed';
  payload: {
    flight_id: string;
    flight_number: string;
    airport: string;
    landed_at: string;
    suits_to_unload: number;
    customs_eta_minutes: number;
  };
}

interface CustomsClearedEvent extends BaseEvent {
  type: 'flight.customs.cleared';
  payload: {
    flight_id: string;
    flight_number: string;
    airport: string;
    cleared_at: string;
    suits_count: number;
    clearance_duration_minutes: number;
    van_dispatch_triggered: boolean;
  };
}

// ============================================
// DELIVERY EVENTS
// ============================================

interface VanDispatchedEvent extends BaseEvent {
  type: 'delivery.van.dispatched';
  payload: {
    route_id: string;
    van_id: string;
    van_number: string;
    driver_id: string;
    driver_name: string;
    stops_count: number;
    suits_count: number;
    estimated_duration_minutes: number;
  };
}

interface VanLocationUpdatedEvent extends BaseEvent {
  type: 'delivery.van.location';
  payload: {
    van_id: string;
    route_id: string;
    coordinates: [number, number];
    heading: number;
    speed_kmh: number;
    current_stop_index: number;
    next_stop_eta_minutes: number;
    suits_on_board: string[];  // suit_numbers
  };
}

interface DeliveryAttemptedEvent extends BaseEvent {
  type: 'delivery.attempted';
  payload: {
    delivery_id: string;
    suit_id: string;
    suit_number: string;
    route_id: string;
    hotel: string;
    result: 'success' | 'failed';
    failure_reason?: string;
    retry_scheduled?: string;
  };
}

// ============================================
// ALERT EVENTS
// ============================================

interface AlertCreatedEvent extends BaseEvent {
  type: 'alert.created';
  payload: {
    alert_id: string;
    severity: 'info' | 'warning' | 'critical';
    entity_type: string;
    entity_id: string;
    title: string;
    description: string;
    auto_response_triggered: boolean;
    auto_response_action?: string;
  };
}

interface AlertResolvedEvent extends BaseEvent {
  type: 'alert.resolved';
  payload: {
    alert_id: string;
    resolved_by: string;
    resolution_action: string;
    time_to_resolution_minutes: number;
  };
}
```

### Event Publisher

```typescript
// event-publisher.ts

import Redis from 'ioredis';
import { v4 as uuidv4 } from 'uuid';

interface PublishOptions {
  correlationId?: string;
  priority?: 'high' | 'normal' | 'low';
}

class EventPublisher {
  private redis: Redis;
  private serviceName: string;
  
  constructor(redis: Redis, serviceName: string) {
    this.redis = redis;
    this.serviceName = serviceName;
  }
  
  async publish<T extends BaseEvent>(
    streamName: string,
    eventType: string,
    payload: T['payload'],
    options: PublishOptions = {}
  ): Promise<string> {
    const event: BaseEvent = {
      id: uuidv4(),
      type: eventType,
      timestamp: new Date().toISOString(),
      source: this.serviceName,
      correlation_id: options.correlationId,
      metadata: {
        priority: options.priority || 'normal'
      }
    };
    
    const fullEvent = { ...event, payload };
    
    // Add to Redis Stream
    const messageId = await this.redis.xadd(
      streamName,
      '*',  // Auto-generate ID
      'event', JSON.stringify(fullEvent)
    );
    
    // Also publish to pub/sub for immediate subscribers
    await this.redis.publish(
      `${streamName}:${eventType}`,
      JSON.stringify(fullEvent)
    );
    
    return messageId;
  }
  
  // Convenience methods for common events
  async publishSuitStatusChange(
    suitId: string,
    suitNumber: string,
    orderId: string,
    previousStatus: string,
    newStatus: string,
    options: PublishOptions = {}
  ): Promise<string> {
    return this.publish(
      'stream:suits',
      'suit.status.changed',
      {
        suit_id: suitId,
        suit_number: suitNumber,
        order_id: orderId,
        previous_status: previousStatus,
        new_status: newStatus
      },
      options
    );
  }
  
  async publishSuitLocation(
    suitId: string,
    suitNumber: string,
    locationType: string,
    coordinates: [number, number],
    options: PublishOptions = {}
  ): Promise<string> {
    return this.publish(
      'stream:locations',
      'suit.location.updated',
      {
        suit_id: suitId,
        suit_number: suitNumber,
        location_type: locationType,
        coordinates
      },
      { ...options, priority: 'high' }  // Location updates are high priority
    );
  }
  
  async publishAlert(
    alertId: string,
    severity: string,
    entityType: string,
    entityId: string,
    title: string,
    description: string,
    options: PublishOptions = {}
  ): Promise<string> {
    return this.publish(
      'stream:alerts',
      'alert.created',
      {
        alert_id: alertId,
        severity,
        entity_type: entityType,
        entity_id: entityId,
        title,
        description,
        auto_response_triggered: false
      },
      { ...options, priority: severity === 'critical' ? 'high' : 'normal' }
    );
  }
}

export default EventPublisher;
```

### Event Subscriber (Worker)

```typescript
// event-subscriber.ts

import Redis from 'ioredis';

interface SubscriberOptions {
  groupName: string;
  consumerName: string;
  batchSize?: number;
  blockTimeout?: number;
}

type EventHandler<T> = (event: T) => Promise<void>;

class EventSubscriber {
  private redis: Redis;
  private options: SubscriberOptions;
  private handlers: Map<string, EventHandler<any>>;
  private running: boolean;
  
  constructor(redis: Redis, options: SubscriberOptions) {
    this.redis = redis;
    this.options = {
      batchSize: 10,
      blockTimeout: 5000,
      ...options
    };
    this.handlers = new Map();
    this.running = false;
  }
  
  on<T>(eventType: string, handler: EventHandler<T>): void {
    this.handlers.set(eventType, handler);
  }
  
  async subscribe(streamName: string): Promise<void> {
    // Create consumer group if not exists
    try {
      await this.redis.xgroup(
        'CREATE',
        streamName,
        this.options.groupName,
        '0',
        'MKSTREAM'
      );
    } catch (err: any) {
      if (!err.message.includes('BUSYGROUP')) {
        throw err;
      }
    }
    
    this.running = true;
    
    while (this.running) {
      try {
        // Read from stream
        const results = await this.redis.xreadgroup(
          'GROUP',
          this.options.groupName,
          this.options.consumerName,
          'COUNT',
          this.options.batchSize!,
          'BLOCK',
          this.options.blockTimeout!,
          'STREAMS',
          streamName,
          '>'
        );
        
        if (!results) continue;
        
        for (const [stream, messages] of results) {
          for (const [messageId, fields] of messages) {
            const eventData = JSON.parse(fields[1]);  // fields = ['event', json]
            
            const handler = this.handlers.get(eventData.type);
            
            if (handler) {
              try {
                await handler(eventData);
                
                // Acknowledge successful processing
                await this.redis.xack(
                  streamName,
                  this.options.groupName,
                  messageId
                );
              } catch (err) {
                console.error(`Error processing event ${messageId}:`, err);
                // Don't ack - will be retried
              }
            } else {
              // No handler, ack anyway to prevent buildup
              await this.redis.xack(
                streamName,
                this.options.groupName,
                messageId
              );
            }
          }
        }
      } catch (err) {
        console.error('Error reading from stream:', err);
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
  
  stop(): void {
    this.running = false;
  }
}

export default EventSubscriber;
```

### WebSocket Server

```typescript
// websocket-server.ts

import { WebSocketServer, WebSocket } from 'ws';
import Redis from 'ioredis';
import { IncomingMessage } from 'http';
import jwt from 'jsonwebtoken';

interface Client {
  ws: WebSocket;
  userId: string;
  userType: 'customer' | 'tailor' | 'driver' | 'admin';
  subscriptions: Set<string>;
}

interface SubscriptionRequest {
  action: 'subscribe' | 'unsubscribe';
  channels: string[];
}

class RealtimeServer {
  private wss: WebSocketServer;
  private redis: Redis;
  private redisSub: Redis;
  private clients: Map<string, Client>;
  
  constructor(port: number, redis: Redis) {
    this.wss = new WebSocketServer({ port });
    this.redis = redis;
    this.redisSub = redis.duplicate();
    this.clients = new Map();
    
    this.setupWebSocket();
    this.setupRedisSubscriber();
  }
  
  private setupWebSocket(): void {
    this.wss.on('connection', async (ws: WebSocket, req: IncomingMessage) => {
      // Authenticate connection
      const token = this.extractToken(req);
      
      if (!token) {
        ws.close(4001, 'Authentication required');
        return;
      }
      
      try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
        
        const clientId = `${decoded.user_type}:${decoded.user_id}`;
        
        const client: Client = {
          ws,
          userId: decoded.user_id,
          userType: decoded.user_type,
          subscriptions: new Set()
        };
        
        this.clients.set(clientId, client);
        
        // Send connection confirmation
        ws.send(JSON.stringify({
          type: 'connected',
          client_id: clientId
        }));
        
        // Handle messages
        ws.on('message', (data: string) => {
          this.handleMessage(clientId, data);
        });
        
        // Handle disconnect
        ws.on('close', () => {
          this.clients.delete(clientId);
        });
        
        // Auto-subscribe based on user type
        this.autoSubscribe(client);
        
      } catch (err) {
        ws.close(4001, 'Invalid token');
      }
    });
  }
  
  private extractToken(req: IncomingMessage): string | null {
    // From query string
    const url = new URL(req.url!, `http://${req.headers.host}`);
    const token = url.searchParams.get('token');
    
    if (token) return token;
    
    // From Authorization header
    const auth = req.headers.authorization;
    if (auth?.startsWith('Bearer ')) {
      return auth.slice(7);
    }
    
    return null;
  }
  
  private autoSubscribe(client: Client): void {
    switch (client.userType) {
      case 'customer':
        // Subscribe to their orders
        client.subscriptions.add(`customer:${client.userId}:orders`);
        break;
        
      case 'tailor':
        // Subscribe to job board and their assignments
        client.subscriptions.add('tailor:jobs:available');
        client.subscriptions.add(`tailor:${client.userId}:assignments`);
        break;
        
      case 'driver':
        // Subscribe to their routes
        client.subscriptions.add(`driver:${client.userId}:routes`);
        break;
        
      case 'admin':
        // Subscribe to everything important
        client.subscriptions.add('admin:alerts');
        client.subscriptions.add('admin:pipeline');
        client.subscriptions.add('admin:flights');
        client.subscriptions.add('admin:deliveries');
        break;
    }
  }
  
  private handleMessage(clientId: string, data: string): void {
    const client = this.clients.get(clientId);
    if (!client) return;
    
    try {
      const message = JSON.parse(data) as SubscriptionRequest;
      
      if (message.action === 'subscribe') {
        for (const channel of message.channels) {
          // Validate subscription permission
          if (this.canSubscribe(client, channel)) {
            client.subscriptions.add(channel);
            this.redisSub.subscribe(channel);
          }
        }
      } else if (message.action === 'unsubscribe') {
        for (const channel of message.channels) {
          client.subscriptions.delete(channel);
        }
      }
      
    } catch (err) {
      client.ws.send(JSON.stringify({
        type: 'error',
        message: 'Invalid message format'
      }));
    }
  }
  
  private canSubscribe(client: Client, channel: string): boolean {
    // Customers can only subscribe to their own data
    if (client.userType === 'customer') {
      return channel.startsWith(`customer:${client.userId}:`);
    }
    
    // Tailors can subscribe to job board and their own data
    if (client.userType === 'tailor') {
      return channel.startsWith('tailor:jobs:') ||
             channel.startsWith(`tailor:${client.userId}:`);
    }
    
    // Drivers can subscribe to their own routes
    if (client.userType === 'driver') {
      return channel.startsWith(`driver:${client.userId}:`);
    }
    
    // Admins can subscribe to anything
    if (client.userType === 'admin') {
      return true;
    }
    
    return false;
  }
  
  private setupRedisSubscriber(): void {
    this.redisSub.on('message', (channel: string, message: string) => {
      // Broadcast to all clients subscribed to this channel
      for (const [clientId, client] of this.clients) {
        if (client.subscriptions.has(channel)) {
          if (client.ws.readyState === WebSocket.OPEN) {
            client.ws.send(JSON.stringify({
              type: 'event',
              channel,
              data: JSON.parse(message)
            }));
          }
        }
      }
    });
  }
  
  // Publish event to specific channels
  async broadcast(channels: string[], event: any): Promise<void> {
    const message = JSON.stringify(event);
    
    for (const channel of channels) {
      await this.redis.publish(channel, message);
    }
  }
  
  // Broadcast to specific suit's watchers
  async broadcastSuitUpdate(suitNumber: string, orderId: string, event: any): Promise<void> {
    // Get customer ID for this order
    const customerId = await this.redis.get(`order:${orderId}:customer`);
    
    const channels = [
      `customer:${customerId}:orders`,
      `suit:${suitNumber}:tracking`,
      'admin:pipeline'
    ];
    
    await this.broadcast(channels, event);
  }
  
  // Broadcast flight updates
  async broadcastFlightUpdate(flightId: string, event: any): Promise<void> {
    const channels = [
      `flight:${flightId}:status`,
      'admin:flights'
    ];
    
    await this.broadcast(channels, event);
  }
  
  // Broadcast delivery updates
  async broadcastDeliveryUpdate(
    routeId: string,
    driverId: string,
    suitNumbers: string[],
    event: any
  ): Promise<void> {
    const channels = [
      `driver:${driverId}:routes`,
      `route:${routeId}:status`,
      'admin:deliveries'
    ];
    
    // Add channels for each suit's customer
    for (const suitNumber of suitNumbers) {
      channels.push(`suit:${suitNumber}:tracking`);
    }
    
    await this.broadcast(channels, event);
  }
}

export default RealtimeServer;
```

### Client-Side WebSocket Handler

```typescript
// client-websocket.ts (React/TypeScript)

interface RealtimeClientOptions {
  url: string;
  token: string;
  onConnect?: () => void;
  onDisconnect?: () => void;
  onError?: (error: Error) => void;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

type EventCallback = (data: any) => void;

class RealtimeClient {
  private ws: WebSocket | null = null;
  private options: RealtimeClientOptions;
  private reconnectAttempts = 0;
  private eventHandlers: Map<string, Set<EventCallback>> = new Map();
  private channelHandlers: Map<string, Set<EventCallback>> = new Map();
  private pendingSubscriptions: string[] = [];
  
  constructor(options: RealtimeClientOptions) {
    this.options = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 10,
      ...options
    };
  }
  
  connect(): void {
    const url = `${this.options.url}?token=${this.options.token}`;
    
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
      this.options.onConnect?.();
      
      // Resubscribe to pending channels
      if (this.pendingSubscriptions.length > 0) {
        this.subscribe(this.pendingSubscriptions);
        this.pendingSubscriptions = [];
      }
    };
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      
      if (message.type === 'event') {
        // Channel-specific handlers
        const channelCallbacks = this.channelHandlers.get(message.channel);
        channelCallbacks?.forEach(cb => cb(message.data));
        
        // Event type handlers
        const eventCallbacks = this.eventHandlers.get(message.data.type);
        eventCallbacks?.forEach(cb => cb(message.data));
      }
    };
    
    this.ws.onclose = () => {
      this.options.onDisconnect?.();
      this.attemptReconnect();
    };
    
    this.ws.onerror = (error) => {
      this.options.onError?.(new Error('WebSocket error'));
    };
  }
  
  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.options.maxReconnectAttempts!) {
      return;
    }
    
    this.reconnectAttempts++;
    
    setTimeout(() => {
      this.connect();
    }, this.options.reconnectInterval);
  }
  
  subscribe(channels: string[]): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
      this.pendingSubscriptions.push(...channels);
      return;
    }
    
    this.ws.send(JSON.stringify({
      action: 'subscribe',
      channels
    }));
  }
  
  unsubscribe(channels: string[]): void {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    
    this.ws.send(JSON.stringify({
      action: 'unsubscribe',
      channels
    }));
  }
  
  // Subscribe to events by type
  onEvent(eventType: string, callback: EventCallback): () => void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    
    this.eventHandlers.get(eventType)!.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.eventHandlers.get(eventType)?.delete(callback);
    };
  }
  
  // Subscribe to channel
  onChannel(channel: string, callback: EventCallback): () => void {
    if (!this.channelHandlers.has(channel)) {
      this.channelHandlers.set(channel, new Set());
    }
    
    this.channelHandlers.get(channel)!.add(callback);
    this.subscribe([channel]);
    
    return () => {
      this.channelHandlers.get(channel)?.delete(callback);
      if (this.channelHandlers.get(channel)?.size === 0) {
        this.unsubscribe([channel]);
      }
    };
  }
  
  disconnect(): void {
    this.ws?.close();
    this.ws = null;
  }
}

// React Hook
function useRealtime(token: string) {
  const [connected, setConnected] = useState(false);
  const clientRef = useRef<RealtimeClient | null>(null);
  
  useEffect(() => {
    const client = new RealtimeClient({
      url: process.env.REACT_APP_WS_URL!,
      token,
      onConnect: () => setConnected(true),
      onDisconnect: () => setConnected(false)
    });
    
    client.connect();
    clientRef.current = client;
    
    return () => {
      client.disconnect();
    };
  }, [token]);
  
  const subscribe = useCallback((
    eventType: string,
    callback: EventCallback
  ) => {
    return clientRef.current?.onEvent(eventType, callback) ?? (() => {});
  }, []);
  
  return { connected, subscribe, client: clientRef.current };
}

export { RealtimeClient, useRealtime };
```

---

## Part 3: Dashboard Data Queries

### Query Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                      Dashboard Frontend                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────┐    ┌──────────────────┐                   │
│  │  Initial Load    │    │  Real-time       │                   │
│  │  (REST API)      │    │  Updates (WS)    │                   │
│  └────────┬─────────┘    └────────┬─────────┘                   │
│           │                       │                              │
│           ▼                       ▼                              │
│  ┌──────────────────────────────────────────┐                   │
│  │           State Management               │                   │
│  │     (React Query + WebSocket)            │                   │
│  └──────────────────────────────────────────┘                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### SQL Queries

#### 1. Pipeline Summary

```sql
-- Get current pipeline state
CREATE OR REPLACE FUNCTION get_pipeline_summary(
    p_date DATE DEFAULT CURRENT_DATE,
    p_timezone TEXT DEFAULT 'Asia/Dubai'
)
RETURNS JSON AS $$
DECLARE
    result JSON;
BEGIN
    SELECT json_build_object(
        'date', p_date,
        'pipeline', (
            SELECT json_build_object(
                'orders_received', COUNT(*) FILTER (
                    WHERE DATE(ordered_at AT TIME ZONE p_timezone) = p_date
                ),
                'in_production', COUNT(*) FILTER (
                    WHERE status IN ('in_production', 'assigned_tailor')
                ),
                'in_qc', COUNT(*) FILTER (
                    WHERE status IN ('qc_pending', 'ready_for_qc')
                ),
                'packed', COUNT(*) FILTER (
                    WHERE status = 'packed'
                ),
                'in_transit', COUNT(*) FILTER (
                    WHERE status IN ('loaded_aircraft', 'in_transit_air', 'customs_pending')
                ),
                'out_for_delivery', COUNT(*) FILTER (
                    WHERE status IN ('customs_cleared', 'assigned_van', 'out_for_delivery')
                ),
                'delivered', COUNT(*) FILTER (
                    WHERE status = 'delivered'
                    AND DATE(actual_delivery AT TIME ZONE p_timezone) = p_date
                )
            )
            FROM suits
            WHERE created_at >= (p_date - INTERVAL '2 days')
        ),
        'risk', (
            SELECT json_build_object(
                'green', COUNT(*) FILTER (WHERE risk_score < 0.3),
                'amber', COUNT(*) FILTER (WHERE risk_score >= 0.3 AND risk_score < 0.6),
                'red', COUNT(*) FILTER (WHERE risk_score >= 0.6 AND risk_score < 0.8),
                'critical', COUNT(*) FILTER (WHERE risk_score >= 0.8)
            )
            FROM suits
            WHERE status NOT IN ('delivered', 'cancelled')
        )
    ) INTO result;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

#### 2. Active Suits with Risk

```sql
-- Get all active suits with risk details
CREATE OR REPLACE VIEW v_active_suits_dashboard AS
SELECT 
    s.id,
    s.suit_number,
    s.status,
    s.risk_score,
    CASE 
        WHEN s.risk_score >= 0.8 THEN 'critical'
        WHEN s.risk_score >= 0.6 THEN 'red'
        WHEN s.risk_score >= 0.3 THEN 'amber'
        ELSE 'green'
    END AS risk_severity,
    s.risk_factors,
    s.deadline,
    EXTRACT(EPOCH FROM (s.deadline - NOW())) / 3600 AS hours_until_deadline,
    s.estimated_delivery,
    s.current_location_type,
    
    -- Order details
    o.order_number,
    c.first_name || ' ' || c.last_name AS customer_name,
    h.name AS hotel_name,
    z.code AS destination_zone,
    
    -- Current assignment
    ta.tailor_id,
    t.name AS tailor_name,
    ta.status AS production_status,
    
    -- Flight assignment
    sfa.flight_id,
    f.flight_number,
    f.status AS flight_status,
    fl.destination_airport_id,
    a.code AS unload_airport,
    
    -- Delivery assignment
    d.route_id,
    d.status AS delivery_status,
    v.van_number,
    dr.name AS driver_name,
    d.estimated_arrival AS delivery_eta

FROM suits s
JOIN orders o ON s.order_id = o.id
JOIN customers c ON o.customer_id = c.id
LEFT JOIN hotels h ON o.destination_hotel_id = h.id
LEFT JOIN zones z ON o.destination_zone_id = z.id
LEFT JOIN tailor_assignments ta ON ta.suit_id = s.id 
    AND ta.assignment_type = 'primary'
    AND ta.status NOT IN ('abandoned', 'reassigned')
LEFT JOIN tailors t ON ta.tailor_id = t.id
LEFT JOIN suit_flight_assignments sfa ON sfa.suit_id = s.id
LEFT JOIN flights f ON sfa.flight_id = f.id
LEFT JOIN flight_legs fl ON sfa.unload_leg_id = fl.id
LEFT JOIN airports a ON fl.destination_airport_id = a.id
LEFT JOIN deliveries d ON d.suit_id = s.id
LEFT JOIN delivery_routes dr_route ON d.route_id = dr_route.id
LEFT JOIN vans v ON dr_route.van_id = v.id
LEFT JOIN drivers dr ON dr_route.driver_id = dr.id

WHERE s.status NOT IN ('delivered', 'cancelled')
ORDER BY s.risk_score DESC, s.deadline ASC;

-- Query for dashboard
SELECT * FROM v_active_suits_dashboard
WHERE risk_severity IN ('critical', 'red')
ORDER BY risk_score DESC
LIMIT 50;
```

#### 3. Flight Status Dashboard

```sql
-- Get today's flights with details
CREATE OR REPLACE FUNCTION get_flights_dashboard(
    p_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_agg(flight_data)
        FROM (
            SELECT 
                f.id,
                f.flight_number,
                f.aircraft_type,
                f.status,
                f.route_type,
                f.scheduled_departure,
                f.actual_departure,
                f.scheduled_arrival,
                f.actual_arrival,
                f.suits_loaded,
                f.charter_cost_gbp,
                
                -- Route legs
                (
                    SELECT json_agg(
                        json_build_object(
                            'leg_number', fl.leg_number,
                            'origin', ao.code,
                            'destination', ad.code,
                            'type', fl.leg_type,
                            'scheduled_departure', fl.scheduled_departure,
                            'actual_departure', fl.actual_departure,
                            'scheduled_arrival', fl.scheduled_arrival,
                            'actual_arrival', fl.actual_arrival,
                            'suits_to_unload', fl.suits_to_unload,
                            'status', fl.status
                        )
                        ORDER BY fl.leg_number
                    )
                    FROM flight_legs fl
                    JOIN airports ao ON fl.origin_airport_id = ao.id
                    JOIN airports ad ON fl.destination_airport_id = ad.id
                    WHERE fl.flight_id = f.id
                ) AS legs,
                
                -- Manifest summary
                (
                    SELECT json_build_object(
                        'total_suits', COUNT(*),
                        'by_airport', json_object_agg(a.code, airport_count),
                        'at_risk', COUNT(*) FILTER (WHERE s.risk_score >= 0.6)
                    )
                    FROM suit_flight_assignments sfa
                    JOIN suits s ON sfa.suit_id = s.id
                    JOIN flight_legs fl ON sfa.unload_leg_id = fl.id
                    JOIN airports a ON fl.destination_airport_id = a.id
                    JOIN LATERAL (
                        SELECT COUNT(*) as airport_count
                        FROM suit_flight_assignments sfa2
                        JOIN flight_legs fl2 ON sfa2.unload_leg_id = fl2.id
                        WHERE fl2.destination_airport_id = fl.destination_airport_id
                        AND sfa2.flight_id = f.id
                    ) counts ON true
                    WHERE sfa.flight_id = f.id
                ) AS manifest,
                
                -- Delay info
                CASE 
                    WHEN f.actual_departure IS NOT NULL 
                    THEN EXTRACT(EPOCH FROM (f.actual_departure - f.scheduled_departure)) / 60
                    ELSE NULL
                END AS departure_delay_minutes
                
            FROM flights f
            WHERE DATE(f.scheduled_departure) = p_date
               OR DATE(f.scheduled_arrival) = p_date
               OR f.status IN ('in_air', 'boarding', 'unloading')
            ORDER BY f.scheduled_departure
        ) flight_data
    );
END;
$$ LANGUAGE plpgsql;
```

#### 4. Ground Fleet Status

```sql
-- Get van fleet status with active routes
CREATE OR REPLACE FUNCTION get_ground_fleet_dashboard()
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_build_object(
            'summary', (
                SELECT json_build_object(
                    'total_vans', COUNT(*),
                    'active', COUNT(*) FILTER (WHERE status IN ('assigned', 'in_transit', 'delivering')),
                    'available', COUNT(*) FILTER (WHERE status = 'available'),
                    'offline', COUNT(*) FILTER (WHERE status IN ('maintenance', 'offline'))
                )
                FROM vans
            ),
            'vans', (
                SELECT json_agg(van_data)
                FROM (
                    SELECT 
                        v.id,
                        v.van_number,
                        v.status,
                        v.current_coordinates[0] AS lat,
                        v.current_coordinates[1] AS lng,
                        v.current_suit_count,
                        v.max_suits,
                        v.last_location_update,
                        
                        -- Driver info
                        json_build_object(
                            'id', d.id,
                            'name', d.name,
                            'phone', d.phone,
                            'hours_worked', d.hours_worked_today
                        ) AS driver,
                        
                        -- Active route
                        CASE WHEN dr.id IS NOT NULL THEN
                            json_build_object(
                                'route_id', dr.id,
                                'total_stops', dr.total_stops,
                                'current_stop', dr.current_stop_index,
                                'stops_remaining', dr.total_stops - dr.current_stop_index,
                                'estimated_completion', (
                                    SELECT estimated_arrival
                                    FROM deliveries
                                    WHERE route_id = dr.id
                                    ORDER BY stop_sequence DESC
                                    LIMIT 1
                                ),
                                'suits_delivered', (
                                    SELECT COUNT(*)
                                    FROM deliveries
                                    WHERE route_id = dr.id AND status = 'delivered'
                                ),
                                'suits_remaining', (
                                    SELECT COUNT(*)
                                    FROM deliveries
                                    WHERE route_id = dr.id AND status != 'delivered'
                                )
                            )
                        ELSE NULL
                        END AS active_route
                        
                    FROM vans v
                    LEFT JOIN drivers d ON v.current_driver_id = d.id
                    LEFT JOIN delivery_routes dr ON dr.van_id = v.id 
                        AND dr.status = 'in_progress'
                    ORDER BY v.van_number
                ) van_data
            )
        )
    );
END;
$$ LANGUAGE plpgsql;
```

#### 5. Alerts Dashboard

```sql
-- Get active alerts with context
CREATE OR REPLACE FUNCTION get_alerts_dashboard(
    p_status TEXT[] DEFAULT ARRAY['open', 'acknowledged'],
    p_severity TEXT[] DEFAULT ARRAY['warning', 'critical'],
    p_limit INT DEFAULT 50
)
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_build_object(
            'counts', (
                SELECT json_build_object(
                    'total_open', COUNT(*) FILTER (WHERE status = 'open'),
                    'critical_open', COUNT(*) FILTER (WHERE status = 'open' AND severity = 'critical'),
                    'acknowledged', COUNT(*) FILTER (WHERE status = 'acknowledged')
                )
                FROM alerts
                WHERE status IN ('open', 'acknowledged')
            ),
            'alerts', (
                SELECT json_agg(alert_data)
                FROM (
                    SELECT 
                        al.id,
                        al.severity,
                        al.entity_type,
                        al.entity_id,
                        al.alert_type,
                        al.title,
                        al.description,
                        al.risk_score_at_alert,
                        al.risk_factors,
                        al.status,
                        al.created_at,
                        al.acknowledged_at,
                        al.acknowledged_by,
                        
                        -- Entity context
                        CASE al.entity_type
                            WHEN 'suit' THEN (
                                SELECT json_build_object(
                                    'suit_number', s.suit_number,
                                    'status', s.status,
                                    'deadline', s.deadline,
                                    'customer', c.first_name || ' ' || c.last_name,
                                    'hotel', h.name
                                )
                                FROM suits s
                                JOIN orders o ON s.order_id = o.id
                                JOIN customers c ON o.customer_id = c.id
                                LEFT JOIN hotels h ON o.destination_hotel_id = h.id
                                WHERE s.id = al.entity_id
                            )
                            WHEN 'flight' THEN (
                                SELECT json_build_object(
                                    'flight_number', f.flight_number,
                                    'status', f.status,
                                    'suits_loaded', f.suits_loaded
                                )
                                FROM flights f
                                WHERE f.id = al.entity_id
                            )
                            WHEN 'van' THEN (
                                SELECT json_build_object(
                                    'van_number', v.van_number,
                                    'status', v.status,
                                    'suits_on_board', v.current_suit_count
                                )
                                FROM vans v
                                WHERE v.id = al.entity_id
                            )
                        END AS entity_context,
                        
                        -- Recommended action
                        al.metadata->'recommended_action' AS recommended_action
                        
                    FROM alerts al
                    WHERE al.status = ANY(p_status)
                    AND al.severity = ANY(p_severity)
                    ORDER BY 
                        CASE al.severity 
                            WHEN 'critical' THEN 1 
                            WHEN 'warning' THEN 2 
                            ELSE 3 
                        END,
                        al.created_at DESC
                    LIMIT p_limit
                ) alert_data
            )
        )
    );
END;
$$ LANGUAGE plpgsql;
```

#### 6. Tailor Performance Dashboard

```sql
-- Get tailor performance metrics
CREATE OR REPLACE FUNCTION get_tailor_dashboard()
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_build_object(
            'summary', (
                SELECT json_build_object(
                    'total_active', COUNT(*) FILTER (WHERE status = 'active'),
                    'currently_working', COUNT(*) FILTER (WHERE current_job_count > 0),
                    'available_capacity', SUM(max_concurrent_jobs - current_job_count) 
                        FILTER (WHERE status = 'active'),
                    'avg_qc_pass_rate', ROUND(AVG(qc_pass_rate)::numeric, 3)
                )
                FROM tailors
            ),
            'tailors', (
                SELECT json_agg(tailor_data ORDER BY active_jobs DESC, qc_pass_rate DESC)
                FROM (
                    SELECT 
                        t.id,
                        t.name,
                        t.status,
                        t.skill_level,
                        t.current_job_count AS active_jobs,
                        t.max_concurrent_jobs,
                        t.qc_pass_rate,
                        t.avg_production_time_minutes,
                        t.total_jobs_completed,
                        
                        -- Current assignments
                        (
                            SELECT json_agg(
                                json_build_object(
                                    'suit_number', s.suit_number,
                                    'status', ta.status,
                                    'deadline', ta.sla_deadline,
                                    'time_remaining_minutes', 
                                        EXTRACT(EPOCH FROM (ta.sla_deadline - NOW())) / 60
                                )
                            )
                            FROM tailor_assignments ta
                            JOIN suits s ON ta.suit_id = s.id
                            WHERE ta.tailor_id = t.id
                            AND ta.status IN ('claimed', 'in_production')
                        ) AS current_assignments,
                        
                        -- Today's stats
                        (
                            SELECT json_build_object(
                                'jobs_completed', COUNT(*) FILTER (
                                    WHERE ta.status = 'completed'
                                    AND DATE(ta.production_completed_at) = CURRENT_DATE
                                ),
                                'qc_passes', COUNT(*) FILTER (
                                    WHERE qc.result = 'pass'
                                    AND DATE(qc.completed_at) = CURRENT_DATE
                                ),
                                'qc_fails', COUNT(*) FILTER (
                                    WHERE qc.result = 'fail'
                                    AND DATE(qc.completed_at) = CURRENT_DATE
                                )
                            )
                            FROM tailor_assignments ta
                            LEFT JOIN qc_inspections qc ON qc.tailor_assignment_id = ta.id
                            WHERE ta.tailor_id = t.id
                        ) AS today_stats
                        
                    FROM tailors t
                    WHERE t.status = 'active'
                ) tailor_data
            )
        )
    );
END;
$$ LANGUAGE plpgsql;
```

#### 7. Performance Metrics (Time Series)

```sql
-- Get hourly performance metrics for charts
CREATE OR REPLACE FUNCTION get_performance_timeseries(
    p_start_time TIMESTAMPTZ,
    p_end_time TIMESTAMPTZ,
    p_interval TEXT DEFAULT '1 hour'
)
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_agg(
            json_build_object(
                'timestamp', bucket,
                'orders_received', orders_received,
                'suits_delivered', suits_delivered,
                'on_time_deliveries', on_time_deliveries,
                'avg_production_time_minutes', avg_production_time,
                'avg_delivery_time_hours', avg_delivery_time,
                'qc_pass_rate', qc_pass_rate
            )
            ORDER BY bucket
        )
        FROM (
            SELECT 
                time_bucket(p_interval::interval, t.timestamp) AS bucket,
                
                -- Orders received (from orders table)
                COUNT(DISTINCT o.id) FILTER (
                    WHERE o.ordered_at >= time_bucket(p_interval::interval, t.timestamp)
                    AND o.ordered_at < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                ) AS orders_received,
                
                -- Suits delivered
                COUNT(DISTINCT s.id) FILTER (
                    WHERE s.actual_delivery >= time_bucket(p_interval::interval, t.timestamp)
                    AND s.actual_delivery < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                ) AS suits_delivered,
                
                -- On-time deliveries
                COUNT(DISTINCT s.id) FILTER (
                    WHERE s.actual_delivery >= time_bucket(p_interval::interval, t.timestamp)
                    AND s.actual_delivery < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                    AND s.actual_delivery <= s.deadline
                ) AS on_time_deliveries,
                
                -- Average production time
                AVG(
                    EXTRACT(EPOCH FROM (ta.production_completed_at - ta.production_started_at)) / 60
                ) FILTER (
                    WHERE ta.production_completed_at >= time_bucket(p_interval::interval, t.timestamp)
                    AND ta.production_completed_at < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                ) AS avg_production_time,
                
                -- Average delivery time
                AVG(
                    EXTRACT(EPOCH FROM (s.actual_delivery - o.ordered_at)) / 3600
                ) FILTER (
                    WHERE s.actual_delivery >= time_bucket(p_interval::interval, t.timestamp)
                    AND s.actual_delivery < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                ) AS avg_delivery_time,
                
                -- QC pass rate
                COUNT(*) FILTER (
                    WHERE qc.result = 'pass'
                    AND qc.completed_at >= time_bucket(p_interval::interval, t.timestamp)
                    AND qc.completed_at < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                )::float / NULLIF(COUNT(*) FILTER (
                    WHERE qc.completed_at >= time_bucket(p_interval::interval, t.timestamp)
                    AND qc.completed_at < time_bucket(p_interval::interval, t.timestamp) + p_interval::interval
                ), 0) AS qc_pass_rate
                
            FROM generate_series(p_start_time, p_end_time, p_interval::interval) t(timestamp)
            LEFT JOIN orders o ON true
            LEFT JOIN suits s ON s.order_id = o.id
            LEFT JOIN tailor_assignments ta ON ta.suit_id = s.id AND ta.assignment_type = 'primary'
            LEFT JOIN qc_inspections qc ON qc.suit_id = s.id
            GROUP BY bucket
        ) metrics
    );
END;
$$ LANGUAGE plpgsql;
```

#### 8. Geographic Heatmap Data

```sql
-- Get delivery heatmap data
CREATE OR REPLACE FUNCTION get_delivery_heatmap(
    p_date DATE DEFAULT CURRENT_DATE
)
RETURNS JSON AS $$
BEGIN
    RETURN (
        SELECT json_build_object(
            'deliveries', (
                SELECT json_agg(
                    json_build_object(
                        'lat', ST_Y(h.coordinates::geometry),
                        'lng', ST_X(h.coordinates::geometry),
                        'weight', delivery_count,
                        'hotel', h.name,
                        'zone', z.code
                    )
                )
                FROM (
                    SELECT 
                        o.destination_hotel_id,
                        COUNT(*) AS delivery_count
                    FROM suits s
                    JOIN orders o ON s.order_id = o.id
                    WHERE DATE(s.actual_delivery) = p_date
                    AND o.destination_hotel_id IS NOT NULL
                    GROUP BY o.destination_hotel_id
                ) delivery_counts
                JOIN hotels h ON delivery_counts.destination_hotel_id = h.id
                JOIN zones z ON h.zone_id = z.id
            ),
            'pending', (
                SELECT json_agg(
                    json_build_object(
                        'lat', ST_Y(h.coordinates::geometry),
                        'lng', ST_X(h.coordinates::geometry),
                        'count', pending_count,
                        'hotel', h.name
                    )
                )
                FROM (
                    SELECT 
                        o.destination_hotel_id,
                        COUNT(*) AS pending_count
                    FROM suits s
                    JOIN orders o ON s.order_id = o.id
                    WHERE s.status = 'out_for_delivery'
                    AND o.destination_hotel_id IS NOT NULL
                    GROUP BY o.destination_hotel_id
                ) pending_counts
                JOIN hotels h ON pending_counts.destination_hotel_id = h.id
            ),
            'vans', (
                SELECT json_agg(
                    json_build_object(
                        'id', v.id,
                        'van_number', v.van_number,
                        'lat', v.current_coordinates[0],
                        'lng', v.current_coordinates[1],
                        'suits', v.current_suit_count,
                        'status', v.status
                    )
                )
                FROM vans v
                WHERE v.status IN ('in_transit', 'delivering')
                AND v.current_coordinates IS NOT NULL
            )
        )
    );
END;
$$ LANGUAGE plpgsql;
```

### React Query Hooks

```typescript
// hooks/useDashboard.ts

import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useRealtime } from './useRealtime';
import { useEffect } from 'react';

// Pipeline Summary
export function usePipelineSummary() {
  const queryClient = useQueryClient();
  const { subscribe } = useRealtime();
  
  // Initial data fetch
  const query = useQuery({
    queryKey: ['pipeline', 'summary'],
    queryFn: () => fetch('/api/admin/dashboard/summary').then(r => r.json()),
    refetchInterval: 30000,  // Refetch every 30 seconds as fallback
  });
  
  // Real-time updates
  useEffect(() => {
    const unsub = subscribe('suit.status.changed', (event) => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['pipeline', 'summary'] });
    });
    
    return unsub;
  }, [subscribe, queryClient]);
  
  return query;
}

// Active Suits with Risk
export function useActiveSuits(filters?: {
  riskSeverity?: string[];
  status?: string[];
  limit?: number;
}) {
  const queryClient = useQueryClient();
  const { subscribe } = useRealtime();
  
  const query = useQuery({
    queryKey: ['suits', 'active', filters],
    queryFn: () => fetch('/api/admin/suits/active?' + new URLSearchParams({
      risk_severity: filters?.riskSeverity?.join(',') || '',
      status: filters?.status?.join(',') || '',
      limit: String(filters?.limit || 100)
    })).then(r => r.json()),
  });
  
  // Real-time risk updates
  useEffect(() => {
    const unsub = subscribe('suit.risk.changed', (event) => {
      queryClient.setQueryData(
        ['suits', 'active', filters],
        (old: any) => {
          if (!old?.suits) return old;
          
          return {
            ...old,
            suits: old.suits.map((suit: any) =>
              suit.id === event.payload.suit_id
                ? { ...suit, risk_score: event.payload.new_score, risk_severity: event.payload.new_severity }
                : suit
            )
          };
        }
      );
    });
    
    return unsub;
  }, [subscribe, queryClient, filters]);
  
  return query;
}

// Flights Dashboard
export function useFlightsDashboard(date?: string) {
  const queryClient = useQueryClient();
  const { subscribe } = useRealtime();
  
  const query = useQuery({
    queryKey: ['flights', 'dashboard', date],
    queryFn: () => fetch(`/api/admin/flights?date=${date || ''}`).then(r => r.json()),
  });
  
  // Real-time flight updates
  useEffect(() => {
    const unsub1 = subscribe('flight.status.changed', (event) => {
      queryClient.setQueryData(
        ['flights', 'dashboard', date],
        (old: any) => {
          if (!old?.flights) return old;
          
          return {
            ...old,
            flights: old.flights.map((flight: any) =>
              flight.id === event.payload.flight_id
                ? { ...flight, status: event.payload.new_status }
                : flight
            )
          };
        }
      );
    });
    
    const unsub2 = subscribe('flight.delayed', (event) => {
      queryClient.invalidateQueries({ queryKey: ['flights', 'dashboard'] });
    });
    
    return () => {
      unsub1();
      unsub2();
    };
  }, [subscribe, queryClient, date]);
  
  return query;
}

// Ground Fleet
export function useGroundFleet() {
  const queryClient = useQueryClient();
  const { subscribe } = useRealtime();
  
  const query = useQuery({
    queryKey: ['fleet', 'ground'],
    queryFn: () => fetch('/api/admin/fleet/ground').then(r => r.json()),
    refetchInterval: 10000,  // More frequent for vehicle positions
  });
  
  // Real-time van location updates
  useEffect(() => {
    const unsub = subscribe('delivery.van.location', (event) => {
      queryClient.setQueryData(
        ['fleet', 'ground'],
        (old: any) => {
          if (!old?.vans) return old;
          
          return {
            ...old,
            vans: old.vans.map((van: any) =>
              van.id === event.payload.van_id
                ? {
                    ...van,
                    lat: event.payload.coordinates[0],
                    lng: event.payload.coordinates[1],
                    current_stop_index: event.payload.current_stop_index
                  }
                : van
            )
          };
        }
      );
    });
    
    return unsub;
  }, [subscribe, queryClient]);
  
  return query;
}

// Alerts
export function useAlerts(filters?: {
  status?: string[];
  severity?: string[];
}) {
  const queryClient = useQueryClient();
  const { subscribe } = useRealtime();
  
  const query = useQuery({
    queryKey: ['alerts', filters],
    queryFn: () => fetch('/api/admin/alerts?' + new URLSearchParams({
      status: filters?.status?.join(',') || 'open,acknowledged',
      severity: filters?.severity?.join(',') || 'warning,critical'
    })).then(r => r.json()),
  });
  
  // Real-time alert updates
  useEffect(() => {
    const unsub1 = subscribe('alert.created', (event) => {
      queryClient.invalidateQueries({ queryKey: ['alerts'] });
    });
    
    const unsub2 = subscribe('alert.resolved', (event) => {
      queryClient.invalidateQueries({ queryKey: ['alerts'] });
    });
    
    return () => {
      unsub1();
      unsub2();
    };
  }, [subscribe, queryClient]);
  
  return query;
}

// Suit Tracking (for customer)
export function useSuitTracking(suitNumber: string) {
  const queryClient = useQueryClient();
  const { subscribe, client } = useRealtime();
  
  const query = useQuery({
    queryKey: ['tracking', suitNumber],
    queryFn: () => fetch(`/api/tracking/${suitNumber}`).then(r => r.json()),
  });
  
  // Subscribe to this specific suit's updates
  useEffect(() => {
    if (!client) return;
    
    // Subscribe to suit-specific channel
    client.subscribe([`suit:${suitNumber}:tracking`]);
    
    const unsub1 = subscribe('suit.status.changed', (event) => {
      if (event.payload.suit_number === suitNumber) {
        queryClient.setQueryData(
          ['tracking', suitNumber],
          (old: any) => ({
            ...old,
            status: event.payload.new_status
          })
        );
      }
    });
    
    const unsub2 = subscribe('suit.location.updated', (event) => {
      if (event.payload.suit_number === suitNumber) {
        queryClient.setQueryData(
          ['tracking', suitNumber],
          (old: any) => ({
            ...old,
            current_location: {
              type: event.payload.location_type,
              coordinates: event.payload.coordinates
            }
          })
        );
      }
    });
    
    return () => {
      unsub1();
      unsub2();
      client.unsubscribe([`suit:${suitNumber}:tracking`]);
    };
  }, [subscribe, client, queryClient, suitNumber]);
  
  return query;
}

// Performance Time Series
export function usePerformanceTimeSeries(
  startTime: string,
  endTime: string,
  interval: string = '1 hour'
) {
  return useQuery({
    queryKey: ['performance', 'timeseries', startTime, endTime, interval],
    queryFn: () => fetch('/api/admin/analytics/timeseries?' + new URLSearchParams({
      start_time: startTime,
      end_time: endTime,
      interval
    })).then(r => r.json()),
    staleTime: 60000,  // Consider fresh for 1 minute
  });
}
```

---

This completes the specification for:

1. **API Endpoints** - All REST endpoints for customers, tailors, QC inspectors, drivers, and admin operations
2. **Real-Time Event System** - Redis Streams-based event publishing, WebSocket server for live updates, and client-side subscription handling
3. **Dashboard Queries** - SQL functions and views for all dashboard components, plus React Query hooks for real-time data binding

Shall I detail the notification system (SMS/WhatsApp/Push), the VAPI integration for automated calls, or the mobile app specifications?



## Prompt:
1/19/2026, 7:52:59 PM

detail the notification system (SMS/WhatsApp/Push), the VAPI integration for automated calls, and then  the mobile app specifications for each of the staff, featuring their need to know information and use case, with a staff management dashboard and admin controls for accounts



## Response:
1/19/2026, 7:59:28 PM

````plaintext
Thought process: Architected comprehensive specification spanning notifications, voice integration, and tiered mobile applications.

The user wants me to detail three major components:

1. Notification System (SMS/WhatsApp/Push)
2. VAPI Integration for automated calls
3. Mobile App Specifications for each staff type with:
   - Need-to-know information
   - Use cases
   - Staff management dashboard
   - Admin controls for accounts

This is a substantial specification document. Let me structure it comprehensively.
````

## Part 1: Notification System

### Architecture Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    Notification Orchestrator                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   Event     │  │  Template   │  │  Preference │             │
│  │   Triggers  │  │   Engine    │  │   Manager   │             │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
│         │                │                │                     │
│         └────────────────┼────────────────┘                     │
│                          ▼                                      │
│              ┌───────────────────────┐                          │
│              │   Channel Router      │                          │
│              └───────────┬───────────┘                          │
│                          │                                      │
│         ┌────────────────┼────────────────┐                     │
│         ▼                ▼                ▼                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │    SMS      │  │  WhatsApp   │  │    Push     │             │
│  │  (Twilio)   │  │  (Meta)     │  │   (FCM)     │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### Database Schema

```sql
-- Notification preferences per user
CREATE TABLE notification_preferences (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- User reference (polymorphic)
    user_type TEXT NOT NULL, -- 'customer', 'tailor', 'driver', 'inspector', 'admin'
    user_id UUID NOT NULL,
    
    -- Channel preferences
    sms_enabled BOOLEAN DEFAULT true,
    whatsapp_enabled BOOLEAN DEFAULT true,
    push_enabled BOOLEAN DEFAULT true,
    email_enabled BOOLEAN DEFAULT true,
    
    -- Contact details
    phone_number TEXT,
    phone_country_code TEXT DEFAULT '+971',
    whatsapp_number TEXT,
    email TEXT,
    
    -- Device tokens for push
    fcm_tokens JSONB DEFAULT '[]', -- Array of {token, device_id, platform, last_used}
    
    -- Quiet hours
    quiet_hours_enabled BOOLEAN DEFAULT false,
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    quiet_hours_timezone TEXT DEFAULT 'Asia/Dubai',
    
    -- Category preferences
    category_preferences JSONB DEFAULT '{}', -- {category: {sms, whatsapp, push, email}}
    
    -- Language
    preferred_language TEXT DEFAULT 'en',
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT unique_user_prefs UNIQUE (user_type, user_id)
);

-- Notification templates
CREATE TABLE notification_templates (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Identity
    code TEXT UNIQUE NOT NULL, -- 'order_confirmed', 'suit_dispatched', etc.
    category TEXT NOT NULL, -- 'order', 'production', 'delivery', 'alert'
    
    -- Target audience
    target_user_type TEXT NOT NULL, -- 'customer', 'tailor', 'driver', etc.
    
    -- Channel templates
    sms_template JSONB, -- {en: "...", ar: "...", hi: "..."}
    whatsapp_template JSONB, -- {template_name, components}
    push_template JSONB, -- {title, body, data}
    email_template JSONB, -- {subject, body_html, body_text}
    
    -- Priority
    priority TEXT DEFAULT 'normal', -- 'low', 'normal', 'high', 'critical'
    
    -- Settings
    channels TEXT[] DEFAULT ARRAY['sms', 'whatsapp', 'push'],
    bypass_quiet_hours BOOLEAN DEFAULT false,
    
    -- Metadata
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notification log
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Reference
    template_id UUID REFERENCES notification_templates(id),
    template_code TEXT NOT NULL,
    
    -- Recipient
    user_type TEXT NOT NULL,
    user_id UUID NOT NULL,
    
    -- Content
    channel TEXT NOT NULL, -- 'sms', 'whatsapp', 'push', 'email'
    content JSONB NOT NULL, -- Rendered content
    
    -- Context
    context_type TEXT, -- 'suit', 'order', 'flight', etc.
    context_id UUID,
    
    -- Status
    status TEXT DEFAULT 'pending', -- 'pending', 'sent', 'delivered', 'failed', 'read'
    
    -- Provider response
    provider_message_id TEXT,
    provider_response JSONB,
    
    -- Timing
    scheduled_at TIMESTAMPTZ,
    sent_at TIMESTAMPTZ,
    delivered_at TIMESTAMPTZ,
    read_at TIMESTAMPTZ,
    failed_at TIMESTAMPTZ,
    failure_reason TEXT,
    
    -- Retry
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    next_retry_at TIMESTAMPTZ,
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    
    CONSTRAINT valid_status CHECK (status IN ('pending', 'sent', 'delivered', 'failed', 'read'))
);

CREATE INDEX idx_notifications_user ON notifications(user_type, user_id);
CREATE INDEX idx_notifications_status ON notifications(status);
CREATE INDEX idx_notifications_context ON notifications(context_type, context_id);
CREATE INDEX idx_notifications_scheduled ON notifications(scheduled_at) WHERE status = 'pending';
```

---

### Notification Templates

```typescript
// notification-templates.ts

export const NOTIFICATION_TEMPLATES = {
  
  // ============================================
  // CUSTOMER NOTIFICATIONS
  // ============================================
  
  // Order lifecycle
  ORDER_CONFIRMED: {
    code: 'order_confirmed',
    category: 'order',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'sms', 'push'],
    templates: {
      sms: {
        en: 'SUIT AI: Your order {{order_number}} is confirmed! Your bespoke suit will be ready within 24 hours. Track: {{tracking_url}}',
        ar: 'SUIT AI: تم تأكيد طلبك {{order_number}}! ستكون بدلتك المخصصة جاهزة خلال 24 ساعة. تتبع: {{tracking_url}}'
      },
      whatsapp: {
        template_name: 'order_confirmation_v2',
        components: [
          { type: 'header', parameters: [{ type: 'image', image: { link: '{{suit_preview_url}}' } }] },
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{order_number}}' },
            { type: 'text', text: '{{delivery_time}}' },
            { type: 'text', text: '{{hotel_name}}' }
          ]},
          { type: 'button', sub_type: 'url', parameters: [{ type: 'text', text: '{{order_id}}' }] }
        ]
      },
      push: {
        title: 'Order Confirmed!',
        body: 'Your bespoke suit is now in production. Delivery by {{delivery_time}}.',
        data: { screen: 'order_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  PRODUCTION_STARTED: {
    code: 'production_started',
    category: 'production',
    target: 'customer',
    priority: 'normal',
    channels: ['whatsapp', 'push'],
    templates: {
      whatsapp: {
        template_name: 'production_update_v1',
        components: [
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{tailor_name}}' }
          ]}
        ]
      },
      push: {
        title: 'Your Suit is Being Crafted',
        body: 'Master tailor {{tailor_name}} has started work on your suit.',
        data: { screen: 'order_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  QC_PASSED: {
    code: 'qc_passed',
    category: 'production',
    target: 'customer',
    priority: 'normal',
    channels: ['whatsapp', 'push'],
    templates: {
      whatsapp: {
        template_name: 'quality_check_passed_v1',
        components: [
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' }
          ]}
        ]
      },
      push: {
        title: 'Quality Check Passed',
        body: 'Your suit passed our rigorous quality inspection and is being packed.',
        data: { screen: 'order_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  SUIT_SHIPPED: {
    code: 'suit_shipped',
    category: 'delivery',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'sms', 'push'],
    templates: {
      sms: {
        en: 'SUIT AI: Your suit is on its way to UAE! Flight {{flight_number}}. ETA: {{arrival_time}}. Track: {{tracking_url}}',
        ar: 'SUIT AI: بدلتك في طريقها إلى الإمارات! رحلة {{flight_number}}. الوصول: {{arrival_time}}. تتبع: {{tracking_url}}'
      },
      whatsapp: {
        template_name: 'suit_shipped_v2',
        components: [
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{arrival_time}}' },
            { type: 'text', text: '{{hotel_name}}' }
          ]},
          { type: 'button', sub_type: 'url', parameters: [{ type: 'text', text: '{{suit_number}}' }] }
        ]
      },
      push: {
        title: 'Your Suit is Flying to You!',
        body: 'Expected arrival: {{arrival_time}}',
        data: { screen: 'order_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  OUT_FOR_DELIVERY: {
    code: 'out_for_delivery',
    category: 'delivery',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'sms', 'push'],
    templates: {
      sms: {
        en: 'SUIT AI: Your suit is out for delivery! Driver {{driver_name}} will arrive at {{hotel_name}} in ~{{eta_minutes}} mins. Track live: {{tracking_url}}',
        ar: 'SUIT AI: بدلتك في طريقها للتوصيل! السائق {{driver_name}} سيصل إلى {{hotel_name}} خلال ~{{eta_minutes}} دقيقة.'
      },
      whatsapp: {
        template_name: 'out_for_delivery_v2',
        components: [
          { type: 'header', parameters: [{ type: 'location', location: { latitude: '{{driver_lat}}', longitude: '{{driver_lng}}', name: 'Your Driver', address: 'Live location' } }] },
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{driver_name}}' },
            { type: 'text', text: '{{eta_minutes}}' },
            { type: 'text', text: '{{hotel_name}}' }
          ]},
          { type: 'button', sub_type: 'url', parameters: [{ type: 'text', text: '{{suit_number}}' }] }
        ]
      },
      push: {
        title: 'Your Suit is Almost There!',
        body: '{{driver_name}} will arrive in ~{{eta_minutes}} minutes',
        data: { screen: 'live_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  ARRIVING_SOON: {
    code: 'arriving_soon',
    category: 'delivery',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'push'],
    bypass_quiet_hours: true,
    templates: {
      whatsapp: {
        template_name: 'arriving_soon_v1',
        components: [
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '5' }
          ]}
        ]
      },
      push: {
        title: 'Driver Arriving in 5 Minutes',
        body: '{{driver_name}} is almost at {{hotel_name}}',
        data: { screen: 'live_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  DELIVERED: {
    code: 'delivered',
    category: 'delivery',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'sms', 'push'],
    templates: {
      sms: {
        en: 'SUIT AI: Your suit has been delivered to {{delivered_to}} at {{hotel_name}}. Enjoy! Questions? Reply to this message.',
        ar: 'SUIT AI: تم توصيل بدلتك إلى {{delivered_to}} في {{hotel_name}}. استمتع!'
      },
      whatsapp: {
        template_name: 'delivery_complete_v2',
        components: [
          { type: 'header', parameters: [{ type: 'image', image: { link: '{{delivery_photo_url}}' } }] },
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{delivered_to}}' },
            { type: 'text', text: '{{delivery_time}}' }
          ]}
        ]
      },
      push: {
        title: 'Suit Delivered!',
        body: 'Your bespoke suit has arrived. Enjoy!',
        data: { screen: 'order_complete', order_id: '{{order_id}}' }
      }
    }
  },
  
  DELIVERY_DELAYED: {
    code: 'delivery_delayed',
    category: 'delivery',
    target: 'customer',
    priority: 'high',
    channels: ['whatsapp', 'sms', 'push'],
    bypass_quiet_hours: true,
    templates: {
      sms: {
        en: 'SUIT AI: We apologize - your delivery is delayed by ~{{delay_minutes}} mins due to {{reason}}. New ETA: {{new_eta}}. Track: {{tracking_url}}',
        ar: 'SUIT AI: نعتذر - تأخر التوصيل ~{{delay_minutes}} دقيقة بسبب {{reason}}. الموعد الجديد: {{new_eta}}'
      },
      whatsapp: {
        template_name: 'delivery_delayed_v1',
        components: [
          { type: 'body', parameters: [
            { type: 'text', text: '{{customer_name}}' },
            { type: 'text', text: '{{delay_minutes}}' },
            { type: 'text', text: '{{reason}}' },
            { type: 'text', text: '{{new_eta}}' }
          ]}
        ]
      },
      push: {
        title: 'Delivery Update',
        body: 'Slight delay of {{delay_minutes}} mins. New ETA: {{new_eta}}',
        data: { screen: 'order_tracking', order_id: '{{order_id}}' }
      }
    }
  },
  
  // ============================================
  // TAILOR NOTIFICATIONS
  // ============================================
  
  JOB_AVAILABLE: {
    code: 'job_available',
    category: 'job',
    target: 'tailor',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: New job available! {{job_type}} - {{fabric_name}}. Payout: ₹{{payout}}. Deadline: {{deadline}}. Claim now in app.',
        hi: 'SUIT AI: नया काम उपलब्ध! {{job_type}} - {{fabric_name}}। भुगतान: ₹{{payout}}। समय सीमा: {{deadline}}। अभी ऐप में claim करें।'
      },
      push: {
        title: 'New Job Available - ₹{{payout}}',
        body: '{{job_type}} | {{fabric_name}} | Deadline: {{deadline}}',
        data: { screen: 'job_details', job_id: '{{job_id}}' }
      }
    }
  },
  
  JOB_CLAIMED_CONFIRMATION: {
    code: 'job_claimed',
    category: 'job',
    target: 'tailor',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: Job {{suit_number}} claimed! Pattern arriving in ~{{pattern_eta}} mins. Deadline: {{deadline}}. Open app for tech pack.',
        hi: 'SUIT AI: काम {{suit_number}} claim हुआ! Pattern ~{{pattern_eta}} मिनट में आएगा। समय सीमा: {{deadline}}।'
      },
      push: {
        title: 'Job Claimed Successfully',
        body: 'Pattern arriving in {{pattern_eta}} mins. Start preparing workspace.',
        data: { screen: 'active_job', assignment_id: '{{assignment_id}}' }
      }
    }
  },
  
  PATTERN_DISPATCHED: {
    code: 'pattern_dispatched',
    category: 'job',
    target: 'tailor',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: Pattern for {{suit_number}} dispatched! Courier: {{courier_name}}, ETA: {{eta}}. Track: {{tracking_url}}',
        hi: 'SUIT AI: {{suit_number}} का Pattern भेजा गया! कूरियर: {{courier_name}}, ETA: {{eta}}।'
      },
      push: {
        title: 'Pattern On The Way',
        body: 'Courier {{courier_name}} arriving in {{eta_minutes}} mins',
        data: { screen: 'active_job', assignment_id: '{{assignment_id}}' }
      }
    }
  },
  
  SLA_WARNING: {
    code: 'sla_warning',
    category: 'job',
    target: 'tailor',
    priority: 'critical',
    channels: ['push', 'sms'],
    bypass_quiet_hours: true,
    templates: {
      sms: {
        en: 'SUIT AI URGENT: Job {{suit_number}} deadline in {{time_remaining}}! Please update status or contact support immediately.',
        hi: 'SUIT AI जरूरी: काम {{suit_number}} की समय सीमा {{time_remaining}} में! कृपया तुरंत स्थिति अपडेट करें।'
      },
      push: {
        title: '⚠️ Deadline Approaching',
        body: 'Only {{time_remaining}} left for {{suit_number}}. Update status now.',
        data: { screen: 'active_job', assignment_id: '{{assignment_id}}', urgent: true }
      }
    }
  },
  
  QC_RESULT: {
    code: 'qc_result',
    category: 'job',
    target: 'tailor',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: QC {{result}} for {{suit_number}}. {{result_message}} Payout: {{payout_status}}.',
        hi: 'SUIT AI: {{suit_number}} का QC {{result}}। {{result_message}} भुगतान: {{payout_status}}।'
      },
      push: {
        title: 'QC Result: {{result}}',
        body: '{{result_message}}',
        data: { screen: 'job_history', assignment_id: '{{assignment_id}}' }
      }
    }
  },
  
  PAYOUT_SENT: {
    code: 'payout_sent',
    category: 'payment',
    target: 'tailor',
    priority: 'normal',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: ₹{{amount}} paid for {{suit_number}}! Transaction ID: {{transaction_id}}. Check your bank account.',
        hi: 'SUIT AI: {{suit_number}} के लिए ₹{{amount}} भुगतान हुआ! Transaction ID: {{transaction_id}}।'
      },
      push: {
        title: 'Payment Received - ₹{{amount}}',
        body: 'For job {{suit_number}}. Check your earnings.',
        data: { screen: 'earnings', transaction_id: '{{transaction_id}}' }
      }
    }
  },
  
  // ============================================
  // DRIVER NOTIFICATIONS
  // ============================================
  
  ROUTE_ASSIGNED: {
    code: 'route_assigned',
    category: 'route',
    target: 'driver',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: New route assigned! {{stops_count}} stops, {{suits_count}} suits. Start: {{start_time}} at {{airport}}. Open app for details.',
        ar: 'SUIT AI: تم تعيين مسار جديد! {{stops_count}} محطات، {{suits_count}} بدلات. البداية: {{start_time}} في {{airport}}.'
      },
      push: {
        title: 'New Route Assigned',
        body: '{{stops_count}} stops | {{suits_count}} suits | Start: {{start_time}}',
        data: { screen: 'route_details', route_id: '{{route_id}}' }
      }
    }
  },
  
  CUSTOMS_CLEARED: {
    code: 'customs_cleared_driver',
    category: 'route',
    target: 'driver',
    priority: 'high',
    channels: ['push', 'sms'],
    bypass_quiet_hours: true,
    templates: {
      sms: {
        en: 'SUIT AI: Customs cleared at {{airport}}! {{suits_count}} suits ready for collection. Proceed to cargo area.',
        ar: 'SUIT AI: تم التخليص الجمركي في {{airport}}! {{suits_count}} بدلات جاهزة. توجه إلى منطقة الشحن.'
      },
      push: {
        title: 'Customs Cleared - Ready for Collection',
        body: '{{suits_count}} suits at {{airport}} cargo. Proceed now.',
        data: { screen: 'route_details', route_id: '{{route_id}}', action: 'collect' }
      }
    }
  },
  
  ROUTE_UPDATE: {
    code: 'route_update',
    category: 'route',
    target: 'driver',
    priority: 'high',
    channels: ['push'],
    templates: {
      push: {
        title: 'Route Updated',
        body: '{{update_reason}}. Check updated stops.',
        data: { screen: 'route_details', route_id: '{{route_id}}', refresh: true }
      }
    }
  },
  
  // ============================================
  // INSPECTOR NOTIFICATIONS
  // ============================================
  
  INSPECTION_ASSIGNED: {
    code: 'inspection_assigned',
    category: 'inspection',
    target: 'inspector',
    priority: 'high',
    channels: ['push', 'sms'],
    templates: {
      sms: {
        en: 'SUIT AI: New inspection assigned! Tailor: {{tailor_name}} at {{address}}. Scheduled: {{scheduled_time}}. Open app for details.',
        hi: 'SUIT AI: नया निरीक्षण! दर्जी: {{tailor_name}}, {{address}}। समय: {{scheduled_time}}।'
      },
      push: {
        title: 'New Inspection Assigned',
        body: '{{tailor_name}} | {{scheduled_time}}',
        data: { screen: 'inspection_details', inspection_id: '{{inspection_id}}' }
      }
    }
  },
  
  INSPECTION_URGENT: {
    code: 'inspection_urgent',
    category: 'inspection',
    target: 'inspector',
    priority: 'critical',
    channels: ['push', 'sms'],
    bypass_quiet_hours: true,
    templates: {
      sms: {
        en: 'SUIT AI URGENT: Priority inspection needed! Tailor: {{tailor_name}}. Suit at risk - deadline {{deadline}}. Go now.',
        hi: 'SUIT AI जरूरी: प्राथमिकता निरीक्षण! दर्जी: {{tailor_name}}। तुरंत जाएं।'
      },
      push: {
        title: '🚨 Urgent Inspection Required',
        body: '{{tailor_name}} - Suit deadline at risk. Proceed immediately.',
        data: { screen: 'inspection_details', inspection_id: '{{inspection_id}}', urgent: true }
      }
    }
  },
  
  // ============================================
  // ADMIN NOTIFICATIONS
  // ============================================
  
  ALERT_CRITICAL: {
    code: 'alert_critical',
    category: 'alert',
    target: 'admin',
    priority: 'critical',
    channels: ['push', 'sms'],
    bypass_quiet_hours: true,
    templates: {
      sms: {
        en: 'SUIT AI CRITICAL: {{alert_title}}. {{alert_description}}. Immediate action required. Open dashboard.',
      },
      push: {
        title: '🚨 CRITICAL: {{alert_title}}',
        body: '{{alert_description}}',
        data: { screen: 'alert_details', alert_id: '{{alert_id}}' }
      }
    }
  },
  
  DAILY_SUMMARY: {
    code: 'daily_summary',
    category: 'report',
    target: 'admin',
    priority: 'normal',
    channels: ['push'],
    templates: {
      push: {
        title: 'Daily Summary - {{date}}',
        body: '{{delivered_count}} delivered | {{on_time_rate}}% on-time | {{revenue}}',
        data: { screen: 'dashboard', tab: 'summary' }
      }
    }
  }
};
```

---

### Notification Service

```typescript
// notification-service.ts

import Twilio from 'twilio';
import { WhatsAppClient } from './whatsapp-client';
import { FCMClient } from './fcm-client';
import { db } from './database';
import { Redis } from 'ioredis';
import Handlebars from 'handlebars';

interface NotificationPayload {
  templateCode: string;
  userId: string;
  userType: 'customer' | 'tailor' | 'driver' | 'inspector' | 'admin';
  variables: Record<string, any>;
  contextType?: string;
  contextId?: string;
  scheduledAt?: Date;
  overrideChannels?: string[];
}

interface NotificationResult {
  notificationId: string;
  channels: {
    channel: string;
    status: 'sent' | 'failed' | 'skipped';
    messageId?: string;
    error?: string;
  }[];
}

class NotificationService {
  private twilio: Twilio.Twilio;
  private whatsapp: WhatsAppClient;
  private fcm: FCMClient;
  private redis: Redis;
  
  constructor() {
    this.twilio = Twilio(
      process.env.TWILIO_ACCOUNT_SID!,
      process.env.TWILIO_AUTH_TOKEN!
    );
    this.whatsapp = new WhatsAppClient({
      accessToken: process.env.WHATSAPP_ACCESS_TOKEN!,
      phoneNumberId: process.env.WHATSAPP_PHONE_NUMBER_ID!
    });
    this.fcm = new FCMClient({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      credentials: JSON.parse(process.env.FIREBASE_CREDENTIALS!)
    });
    this.redis = new Redis(process.env.REDIS_URL!);
  }
  
  async send(payload: NotificationPayload): Promise<NotificationResult> {
    // Get template
    const template = await db.notificationTemplates.findByCode(payload.templateCode);
    
    if (!template || !template.active) {
      throw new Error(`Template not found or inactive: ${payload.templateCode}`);
    }
    
    // Get user preferences
    const preferences = await db.notificationPreferences.findByUser(
      payload.userType,
      payload.userId
    );
    
    if (!preferences) {
      throw new Error(`No notification preferences for user: ${payload.userId}`);
    }
    
    // Determine channels to use
    const channels = this.determineChannels(
      template,
      preferences,
      payload.overrideChannels
    );
    
    // Check quiet hours
    if (!template.bypass_quiet_hours && this.isQuietHours(preferences)) {
      // Schedule for after quiet hours
      const sendAt = this.getNextActiveTime(preferences);
      return this.schedule({ ...payload, scheduledAt: sendAt });
    }
    
    // Render templates
    const renderedContent = this.renderTemplates(template, payload.variables, preferences.preferred_language);
    
    // Send to each channel
    const results: NotificationResult = {
      notificationId: '',
      channels: []
    };
    
    for (const channel of channels) {
      try {
        const result = await this.sendToChannel(
          channel,
          preferences,
          renderedContent[channel],
          template.priority
        );
        
        results.channels.push({
          channel,
          status: 'sent',
          messageId: result.messageId
        });
        
        // Log notification
        const notificationId = await this.logNotification({
          templateId: template.id,
          templateCode: template.code,
          userType: payload.userType,
          userId: payload.userId,
          channel,
          content: renderedContent[channel],
          contextType: payload.contextType,
          contextId: payload.contextId,
          status: 'sent',
          providerMessageId: result.messageId
        });
        
        if (!results.notificationId) {
          results.notificationId = notificationId;
        }
        
      } catch (error: any) {
        results.channels.push({
          channel,
          status: 'failed',
          error: error.message
        });
        
        // Log failed notification for retry
        await this.logNotification({
          templateId: template.id,
          templateCode: template.code,
          userType: payload.userType,
          userId: payload.userId,
          channel,
          content: renderedContent[channel],
          contextType: payload.contextType,
          contextId: payload.contextId,
          status: 'failed',
          failureReason: error.message
        });
      }
    }
    
    return results;
  }
  
  private determineChannels(
    template: any,
    preferences: any,
    overrideChannels?: string[]
  ): string[] {
    if (overrideChannels) {
      return overrideChannels;
    }
    
    const templateChannels = template.channels;
    const enabledChannels: string[] = [];
    
    // Check each channel against user preferences
    for (const channel of templateChannels) {
      const categoryPref = preferences.category_preferences?.[template.category];
      
      // Check category-specific preference first
      if (categoryPref && categoryPref[channel] === false) {
        continue;
      }
      
      // Check global channel preference
      switch (channel) {
        case 'sms':
          if (preferences.sms_enabled && preferences.phone_number) {
            enabledChannels.push('sms');
          }
          break;
        case 'whatsapp':
          if (preferences.whatsapp_enabled && preferences.whatsapp_number) {
            enabledChannels.push('whatsapp');
          }
          break;
        case 'push':
          if (preferences.push_enabled && preferences.fcm_tokens?.length > 0) {
            enabledChannels.push('push');
          }
          break;
        case 'email':
          if (preferences.email_enabled && preferences.email) {
            enabledChannels.push('email');
          }
          break;
      }
    }
    
    return enabledChannels;
  }
  
  private isQuietHours(preferences: any): boolean {
    if (!preferences.quiet_hours_enabled) {
      return false;
    }
    
    const now = new Date();
    const userTime = new Date(now.toLocaleString('en-US', { 
      timeZone: preferences.quiet_hours_timezone 
    }));
    
    const currentMinutes = userTime.getHours() * 60 + userTime.getMinutes();
    
    const [startHour, startMin] = preferences.quiet_hours_start.split(':').map(Number);
    const [endHour, endMin] = preferences.quiet_hours_end.split(':').map(Number);
    
    const startMinutes = startHour * 60 + startMin;
    const endMinutes = endHour * 60 + endMin;
    
    if (startMinutes < endMinutes) {
      // Same day quiet hours (e.g., 22:00 - 08:00 next day won't match this)
      return currentMinutes >= startMinutes && currentMinutes < endMinutes;
    } else {
      // Overnight quiet hours (e.g., 22:00 - 08:00)
      return currentMinutes >= startMinutes || currentMinutes < endMinutes;
    }
  }
  
  private renderTemplates(
    template: any,
    variables: Record<string, any>,
    language: string
  ): Record<string, any> {
    const rendered: Record<string, any> = {};
    
    // SMS
    if (template.sms_template) {
      const smsTemplate = template.sms_template[language] || template.sms_template['en'];
      rendered.sms = Handlebars.compile(smsTemplate)(variables);
    }
    
    // WhatsApp
    if (template.whatsapp_template) {
      rendered.whatsapp = this.renderWhatsAppTemplate(template.whatsapp_template, variables);
    }
    
    // Push
    if (template.push_template) {
      rendered.push = {
        title: Handlebars.compile(template.push_template.title)(variables),
        body: Handlebars.compile(template.push_template.body)(variables),
        data: this.renderObject(template.push_template.data, variables)
      };
    }
    
    return rendered;
  }
  
  private renderWhatsAppTemplate(template: any, variables: Record<string, any>): any {
    return {
      template_name: template.template_name,
      components: template.components.map((comp: any) => ({
        ...comp,
        parameters: comp.parameters?.map((param: any) => {
          if (param.type === 'text' && param.text.includes('{{')) {
            return {
              ...param,
              text: Handlebars.compile(param.text)(variables)
            };
          }
          if (param.type === 'image' && param.image?.link?.includes('{{')) {
            return {
              ...param,
              image: { link: Handlebars.compile(param.image.link)(variables) }
            };
          }
          return param;
        })
      }))
    };
  }
  
  private renderObject(obj: any, variables: Record<string, any>): any {
    if (typeof obj === 'string') {
      return Handlebars.compile(obj)(variables);
    }
    if (Array.isArray(obj)) {
      return obj.map(item => this.renderObject(item, variables));
    }
    if (typeof obj === 'object' && obj !== null) {
      const result: any = {};
      for (const key of Object.keys(obj)) {
        result[key] = this.renderObject(obj[key], variables);
      }
      return result;
    }
    return obj;
  }
  
  private async sendToChannel(
    channel: string,
    preferences: any,
    content: any,
    priority: string
  ): Promise<{ messageId: string }> {
    switch (channel) {
      case 'sms':
        return this.sendSMS(preferences.phone_number, content, priority);
      case 'whatsapp':
        return this.sendWhatsApp(preferences.whatsapp_number, content);
      case 'push':
        return this.sendPush(preferences.fcm_tokens, content, priority);
      default:
        throw new Error(`Unknown channel: ${channel}`);
    }
  }
  
  private async sendSMS(
    phoneNumber: string,
    content: string,
    priority: string
  ): Promise<{ messageId: string }> {
    const message = await this.twilio.messages.create({
      body: content,
      to: phoneNumber,
      from: process.env.TWILIO_PHONE_NUMBER,
      ...(priority === 'critical' && { 
        statusCallback: `${process.env.API_URL}/webhooks/twilio/status` 
      })
    });
    
    return { messageId: message.sid };
  }
  
  private async sendWhatsApp(
    phoneNumber: string,
    content: any
  ): Promise<{ messageId: string }> {
    const response = await this.whatsapp.sendTemplate({
      to: phoneNumber,
      template: content.template_name,
      components: content.components,
      language: { code: 'en' }
    });
    
    return { messageId: response.messages[0].id };
  }
  
  private async sendPush(
    tokens: any[],
    content: any,
    priority: string
  ): Promise<{ messageId: string }> {
    // Filter to active tokens only
    const activeTokens = tokens
      .filter(t => t.active !== false)
      .map(t => t.token);
    
    if (activeTokens.length === 0) {
      throw new Error('No active push tokens');
    }
    
    const response = await this.fcm.sendMulticast({
      tokens: activeTokens,
      notification: {
        title: content.title,
        body: content.body
      },
      data: content.data,
      android: {
        priority: priority === 'critical' ? 'high' : 'normal',
        notification: {
          channelId: priority === 'critical' ? 'urgent' : 'default',
          sound: priority === 'critical' ? 'urgent.mp3' : 'default'
        }
      },
      apns: {
        payload: {
          aps: {
            sound: priority === 'critical' ? 'urgent.caf' : 'default',
            badge: 1
          }
        }
      }
    });
    
    // Update token status for failed tokens
    for (let i = 0; i < response.responses.length; i++) {
      if (!response.responses[i].success) {
        const error = response.responses[i].error;
        if (error?.code === 'messaging/registration-token-not-registered') {
          await this.deactivateToken(activeTokens[i]);
        }
      }
    }
    
    return { messageId: response.successCount > 0 ? 'multicast' : '' };
  }
  
  private async logNotification(data: any): Promise<string> {
    const notification = await db.notifications.create(data);
    return notification.id;
  }
  
  private async deactivateToken(token: string): Promise<void> {
    await db.query(`
      UPDATE notification_preferences
      SET fcm_tokens = (
        SELECT jsonb_agg(
          CASE WHEN t->>'token' = $1 
          THEN jsonb_set(t, '{active}', 'false')
          ELSE t END
        )
        FROM jsonb_array_elements(fcm_tokens) t
      )
      WHERE fcm_tokens @> $2::jsonb
    `, [token, JSON.stringify([{ token }])]);
  }
  
  // Schedule notification for later
  async schedule(payload: NotificationPayload): Promise<NotificationResult> {
    const scheduledAt = payload.scheduledAt || new Date();
    
    // Store in Redis sorted set by scheduled time
    await this.redis.zadd(
      'scheduled_notifications',
      scheduledAt.getTime(),
      JSON.stringify(payload)
    );
    
    return {
      notificationId: 'scheduled',
      channels: [{ channel: 'all', status: 'skipped', error: 'Scheduled for later' }]
    };
  }
  
  // Process scheduled notifications (called by cron)
  async processScheduled(): Promise<void> {
    const now = Date.now();
    
    // Get all notifications due
    const notifications = await this.redis.zrangebyscore(
      'scheduled_notifications',
      0,
      now
    );
    
    for (const notificationJson of notifications) {
      const payload = JSON.parse(notificationJson);
      
      try {
        await this.send(payload);
      } catch (error) {
        console.error('Failed to send scheduled notification:', error);
      }
      
      // Remove from queue
      await this.redis.zrem('scheduled_notifications', notificationJson);
    }
  }
  
  // Retry failed notifications
  async retryFailed(): Promise<void> {
    const failedNotifications = await db.notifications.findMany({
      where: {
        status: 'failed',
        retry_count: { lt: db.raw('max_retries') },
        next_retry_at: { lte: new Date() }
      },
      limit: 100
    });
    
    for (const notification of failedNotifications) {
      try {
        const template = await db.notificationTemplates.findById(notification.template_id);
        const preferences = await db.notificationPreferences.findByUser(
          notification.user_type,
          notification.user_id
        );
        
        const result = await this.sendToChannel(
          notification.channel,
          preferences,
          notification.content,
          template.priority
        );
        
        await db.notifications.update(notification.id, {
          status: 'sent',
          provider_message_id: result.messageId,
          sent_at: new Date()
        });
        
      } catch (error: any) {
        const nextRetry = new Date(Date.now() + Math.pow(2, notification.retry_count) * 60000);
        
        await db.notifications.update(notification.id, {
          retry_count: notification.retry_count + 1,
          next_retry_at: nextRetry,
          failure_reason: error.message
        });
      }
    }
  }
}

export default NotificationService;
```

---

### WhatsApp Business API Client

```typescript
// whatsapp-client.ts

import axios, { AxiosInstance } from 'axios';

interface WhatsAppConfig {
  accessToken: string;
  phoneNumberId: string;
  apiVersion?: string;
}

interface SendTemplateParams {
  to: string;
  template: string;
  language: { code: string };
  components?: any[];
}

interface SendMessageParams {
  to: string;
  type: 'text' | 'image' | 'document' | 'location';
  content: any;
}

class WhatsAppClient {
  private client: AxiosInstance;
  private phoneNumberId: string;
  
  constructor(config: WhatsAppConfig) {
    this.phoneNumberId = config.phoneNumberId;
    this.client = axios.create({
      baseURL: `https://graph.facebook.com/${config.apiVersion || 'v18.0'}`,
      headers: {
        'Authorization': `Bearer ${config.accessToken}`,
        'Content-Type': 'application/json'
      }
    });
  }
  
  async sendTemplate(params: SendTemplateParams): Promise<any> {
    const response = await this.client.post(
      `/${this.phoneNumberId}/messages`,
      {
        messaging_product: 'whatsapp',
        recipient_type: 'individual',
        to: this.formatPhoneNumber(params.to),
        type: 'template',
        template: {
          name: params.template,
          language: params.language,
          components: params.components
        }
      }
    );
    
    return response.data;
  }
  
  async sendMessage(params: SendMessageParams): Promise<any> {
    const payload: any = {
      messaging_product: 'whatsapp',
      recipient_type: 'individual',
      to: this.formatPhoneNumber(params.to),
      type: params.type
    };
    
    switch (params.type) {
      case 'text':
        payload.text = { body: params.content.text };
        break;
      case 'image':
        payload.image = { link: params.content.url, caption: params.content.caption };
        break;
      case 'location':
        payload.location = params.content;
        break;
    }
    
    const response = await this.client.post(
      `/${this.phoneNumberId}/messages`,
      payload
    );
    
    return response.data;
  }
  
  async sendInteractiveButtons(
    to: string,
    body: string,
    buttons: { id: string; title: string }[]
  ): Promise<any> {
    const response = await this.client.post(
      `/${this.phoneNumberId}/messages`,
      {
        messaging_product: 'whatsapp',
        recipient_type: 'individual',
        to: this.formatPhoneNumber(to),
        type: 'interactive',
        interactive: {
          type: 'button',
          body: { text: body },
          action: {
            buttons: buttons.map(btn => ({
              type: 'reply',
              reply: { id: btn.id, title: btn.title }
            }))
          }
        }
      }
    );
    
    return response.data;
  }
  
  async sendLiveLocation(
    to: string,
    latitude: number,
    longitude: number,
    name: string
  ): Promise<any> {
    return this.sendMessage({
      to,
      type: 'location',
      content: { latitude, longitude, name }
    });
  }
  
  private formatPhoneNumber(phone: string): string {
    // Remove any non-digit characters except leading +
    let formatted = phone.replace(/[^\d+]/g, '');
    
    // Ensure it starts with country code
    if (!formatted.startsWith('+')) {
      formatted = '+' + formatted;
    }
    
    // Remove the + for the API
    return formatted.replace('+', '');
  }
  
  // Webhook verification
  verifyWebhook(mode: string, token: string, challenge: string): string | null {
    if (mode === 'subscribe' && token === process.env.WHATSAPP_VERIFY_TOKEN) {
      return challenge;
    }
    return null;
  }
  
  // Process incoming webhook
  async processWebhook(body: any): Promise<void> {
    const entries = body.entry || [];
    
    for (const entry of entries) {
      const changes = entry.changes || [];
      
      for (const change of changes) {
        if (change.field !== 'messages') continue;
        
        const value = change.value;
        
        // Status updates
        if (value.statuses) {
          for (const status of value.statuses) {
            await this.handleStatusUpdate(status);
          }
        }
        
        // Incoming messages
        if (value.messages) {
          for (const message of value.messages) {
            await this.handleIncomingMessage(message, value.contacts?.[0]);
          }
        }
      }
    }
  }
  
  private async handleStatusUpdate(status: any): Promise<void> {
    // Update notification status in database
    const statusMap: Record<string, string> = {
      'sent': 'sent',
      'delivered': 'delivered',
      'read': 'read',
      'failed': 'failed'
    };
    
    await db.notifications.updateByProviderMessageId(status.id, {
      status: statusMap[status.status] || status.status,
      [`${status.status}_at`]: new Date(parseInt(status.timestamp) * 1000)
    });
  }
  
  private async handleIncomingMessage(message: any, contact: any): Promise<void> {
    // Handle customer replies
    // This could trigger customer service workflows
    console.log('Incoming WhatsApp message:', {
      from: message.from,
      type: message.type,
      text: message.text?.body,
      contact: contact?.profile?.name
    });
    
    // Emit event for processing
    await eventBus.publish('whatsapp.message.received', {
      from: message.from,
      type: message.type,
      content: message.text?.body || message.button?.text,
      timestamp: message.timestamp,
      contactName: contact?.profile?.name
    });
  }
}

export { WhatsAppClient };
```

---

## Part 2: VAPI Integration for Automated Calls

### VAPI Configuration

```typescript
// vapi-client.ts

import axios, { AxiosInstance } from 'axios';

interface VAPIConfig {
  apiKey: string;
  assistantId: string;
  phoneNumberId: string;
}

interface CallParams {
  to: string;
  assistantOverrides?: {
    firstMessage?: string;
    model?: {
      messages?: { role: string; content: string }[];
    };
    variableValues?: Record<string, any>;
  };
  metadata?: Record<string, any>;
}

interface BulkCallParams {
  recipients: {
    phoneNumber: string;
    variables: Record<string, any>;
  }[];
  assistantOverrides?: any;
  maxConcurrent?: number;
  delayBetweenCalls?: number;
}

class VAPIClient {
  private client: AxiosInstance;
  private config: VAPIConfig;
  
  constructor(config: VAPIConfig) {
    this.config = config;
    this.client = axios.create({
      baseURL: 'https://api.vapi.ai',
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
  }
  
  // Initiate a single call
  async call(params: CallParams): Promise<any> {
    const response = await this.client.post('/call/phone', {
      assistantId: this.config.assistantId,
      phoneNumberId: this.config.phoneNumberId,
      customer: {
        number: params.to
      },
      assistantOverrides: params.assistantOverrides,
      metadata: params.metadata
    });
    
    return response.data;
  }
  
  // Bulk call multiple recipients
  async bulkCall(params: BulkCallParams): Promise<any[]> {
    const results: any[] = [];
    const maxConcurrent = params.maxConcurrent || 5;
    const delay = params.delayBetweenCalls || 2000;
    
    // Process in batches
    for (let i = 0; i < params.recipients.length; i += maxConcurrent) {
      const batch = params.recipients.slice(i, i + maxConcurrent);
      
      const batchPromises = batch.map(recipient =>
        this.call({
          to: recipient.phoneNumber,
          assistantOverrides: {
            ...params.assistantOverrides,
            variableValues: recipient.variables
          },
          metadata: { recipientIndex: i }
        })
      );
      
      const batchResults = await Promise.allSettled(batchPromises);
      results.push(...batchResults);
      
      // Delay between batches
      if (i + maxConcurrent < params.recipients.length) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    
    return results;
  }
  
  // Get call status
  async getCall(callId: string): Promise<any> {
    const response = await this.client.get(`/call/${callId}`);
    return response.data;
  }
  
  // End an active call
  async endCall(callId: string): Promise<any> {
    const response = await this.client.post(`/call/${callId}/end`);
    return response.data;
  }
  
  // Get call transcript
  async getTranscript(callId: string): Promise<any> {
    const response = await this.client.get(`/call/${callId}/transcript`);
    return response.data;
  }
}

export { VAPIClient };
```

### VAPI Assistants Configuration

```typescript
// vapi-assistants.ts

export const VAPI_ASSISTANTS = {
  
  // ============================================
  // TAILOR JOB ESCALATION ASSISTANT
  // ============================================
  
  TAILOR_JOB_ESCALATION: {
    name: 'Tailor Job Escalation',
    model: {
      provider: 'openai',
      model: 'gpt-4-turbo',
      temperature: 0.7,
      systemPrompt: `You are a professional assistant for SUIT AI, a luxury bespoke tailoring service. 

Your task is to contact tailors about urgent job opportunities. Be professional, respectful, and efficient.

Context provided in variables:
- tailor_name: The tailor's name
- job_type: Type of garment (e.g., "Two-Piece Suit")
- fabric_name: Fabric description
- payout: Payment amount in INR
- deadline: When the job must be complete
- job_id: Reference number

Your goals:
1. Greet the tailor by name
2. Explain there's an urgent job available
3. Provide key details (type, fabric, payout, deadline)
4. Ask if they can accept the job
5. If yes, confirm and let them know to check the app
6. If no, thank them and end politely

Keep the call under 90 seconds. Speak clearly and at a moderate pace.
Be prepared for the tailor to speak Hindi - you can respond in Hindi if they prefer.`
    },
    voice: {
      provider: 'elevenlabs',
      voiceId: 'pNInz6obpgDQGcFmaJgB', // Professional male voice
      stability: 0.7,
      similarityBoost: 0.8
    },
    firstMessage: 'Hello {{tailor_name}}, this is SUIT AI calling. I have an urgent job opportunity for you. Do you have a moment to discuss?',
    transcriber: {
      provider: 'deepgram',
      language: 'hi-en', // Hindi-English code-switching
      model: 'nova-2'
    },
    endCallPhrases: [
      'goodbye',
      'thank you goodbye',
      'no thank you',
      'I will check the app'
    ],
    silenceTimeoutSeconds: 10,
    maxDurationSeconds: 120,
    
    // Function definitions for structured responses
    functions: [
      {
        name: 'record_response',
        description: 'Record the tailor response to the job offer',
        parameters: {
          type: 'object',
          properties: {
            accepted: {
              type: 'boolean',
              description: 'Whether the tailor accepted the job'
            },
            reason: {
              type: 'string',
              description: 'Reason for declining if applicable'
            },
            callback_requested: {
              type: 'boolean',
              description: 'If they asked to be called back later'
            }
          },
          required: ['accepted']
        }
      }
    ]
  },
  
  // ============================================
  // TAILOR SLA WARNING ASSISTANT
  // ============================================
  
  TAILOR_SLA_WARNING: {
    name: 'Tailor SLA Warning',
    model: {
      provider: 'openai',
      model: 'gpt-4-turbo',
      temperature: 0.5,
      systemPrompt: `You are calling on behalf of SUIT AI regarding an urgent production deadline.

Context provided:
- tailor_name: The tailor's name
- suit_number: The suit reference number
- time_remaining: Time until deadline
- current_stage: Current production stage

Your goals:
1. Greet professionally
2. Reference the specific job by suit number
3. Inform them of the approaching deadline
4. Ask for a status update
5. If they're having issues, note them and offer support
6. Confirm they understand the urgency
7. Thank them and end

Be firm but supportive. This is urgent but we want to help them succeed.`
    },
    voice: {
      provider: 'elevenlabs',
      voiceId: 'pNInz6obpgDQGcFmaJgB',
      stability: 0.8,
      similarityBoost: 0.7
    },
    firstMessage: 'Hello {{tailor_name}}, this is SUIT AI operations calling about job {{suit_number}}. This is an urgent call regarding your deadline.',
    maxDurationSeconds: 180,
    
    functions: [
      {
        name: 'record_status_update',
        description: 'Record the production status update from tailor',
        parameters: {
          type: 'object',
          properties: {
            current_stage: {
              type: 'string',
              description: 'Current stage of production'
            },
            estimated_completion: {
              type: 'string',
              description: 'Estimated completion time'
            },
            issues: {
              type: 'array',
              items: { type: 'string' },
              description: 'Any issues reported'
            },
            needs_support: {
              type: 'boolean',
              description: 'Whether they need operational support'
            }
          },
          required: ['current_stage']
        }
      }
    ]
  },
  
  // ============================================
  // CUSTOMER DELIVERY NOTIFICATION ASSISTANT
  // ============================================
  
  CUSTOMER_DELIVERY_CALL: {
    name: 'Customer Delivery Notification',
    model: {
      provider: 'openai',
      model: 'gpt-4-turbo',
      temperature: 0.7,
      systemPrompt: `You are a luxury concierge assistant for SUIT AI.

Context provided:
- customer_name: Customer's name
- suit_description: Description of their suit
- driver_name: Delivery driver's name
- eta_minutes: Minutes until arrival
- hotel_name: Their hotel

Your task:
1. Greet the customer warmly by name
2. Inform them their bespoke suit is arriving soon
3. Provide the ETA and driver's name
4. Confirm they're available to receive it
5. If not available, ask where to leave it (concierge, front desk)
6. Thank them for choosing SUIT AI

Be warm, professional, and luxurious in tone. This is a premium service.`
    },
    voice: {
      provider: 'elevenlabs',
      voiceId: '21m00Tcm4TlvDq8ikWAM', // Warm professional voice
      stability: 0.75,
      similarityBoost: 0.85
    },
    firstMessage: 'Good {{time_of_day}} {{customer_name}}, this is SUIT AI concierge calling with wonderful news about your bespoke suit.',
    maxDurationSeconds: 120,
    
    functions: [
      {
        name: 'record_delivery_preference',
        description: 'Record customer delivery preference',
        parameters: {
          type: 'object',
          properties: {
            available: {
              type: 'boolean',
              description: 'Whether customer will be available'
            },
            alternate_recipient: {
              type: 'string',
              enum: ['concierge', 'front_desk', 'room_service', 'other'],
              description: 'Alternate delivery location if unavailable'
            },
            special_instructions: {
              type: 'string',
              description: 'Any special delivery instructions'
            }
          },
          required: ['available']
        }
      }
    ]
  },
  
  // ============================================
  // INSPECTOR DISPATCH ASSISTANT
  // ============================================
  
  INSPECTOR_DISPATCH: {
    name: 'Inspector Dispatch',
    model: {
      provider: 'openai',
      model: 'gpt-4-turbo',
      temperature: 0.5,
      systemPrompt: `You are dispatching QC inspectors for SUIT AI.

Context provided:
- inspector_name: Inspector's name
- tailor_name: Tailor to visit
- tailor_address: Location
- suit_number: Suit reference
- urgency: Normal or urgent
- scheduled_time: Suggested inspection time

Your goals:
1. Greet the inspector
2. Inform them of a new inspection assignment
3. Provide location and tailor details
4. Confirm they can attend at the suggested time
5. If not, find out when they can go
6. Confirm the assignment

Keep it professional and efficient.`
    },
    voice: {
      provider: 'elevenlabs',
      voiceId: 'pNInz6obpgDQGcFmaJgB',
      stability: 0.7,
      similarityBoost: 0.7
    },
    firstMessage: 'Hello {{inspector_name}}, this is SUIT AI dispatch. I have a {{urgency}} inspection assignment for you.',
    maxDurationSeconds: 120,
    
    functions: [
      {
        name: 'record_assignment_response',
        description: 'Record inspector response to assignment',
        parameters: {
          type: 'object',
          properties: {
            accepted: {
              type: 'boolean',
              description: 'Whether inspector accepted'
            },
            available_time: {
              type: 'string',
              description: 'When they can attend if different from suggested'
            },
            reason_declined: {
              type: 'string',
              description: 'Reason if declined'
            }
          },
          required: ['accepted']
        }
      }
    ]
  }
};
```

### VAPI Service Integration

```typescript
// vapi-service.ts

import { VAPIClient } from './vapi-client';
import { VAPI_ASSISTANTS } from './vapi-assistants';
import { db } from './database';
import { eventBus } from './event-bus';

interface TailorEscalationParams {
  jobId: string;
  tailors: {
    tailorId: string;
    name: string;
    phone: string;
  }[];
  jobDetails: {
    suitNumber: string;
    jobType: string;
    fabricName: string;
    payout: number;
    deadline: string;
  };
}

interface CallResult {
  callId: string;
  tailorId: string;
  status: 'completed' | 'no_answer' | 'busy' | 'failed';
  accepted?: boolean;
  transcript?: string;
  duration?: number;
}

class VAPIService {
  private client: VAPIClient;
  
  constructor() {
    this.client = new VAPIClient({
      apiKey: process.env.VAPI_API_KEY!,
      assistantId: process.env.VAPI_ASSISTANT_ID!,
      phoneNumberId: process.env.VAPI_PHONE_NUMBER_ID!
    });
  }
  
  // ============================================
  // TAILOR JOB ESCALATION
  // ============================================
  
  async escalateJobToTailors(params: TailorEscalationParams): Promise<{
    assignedTo?: string;
    results: CallResult[];
  }> {
    const results: CallResult[] = [];
    let assignedTo: string | undefined;
    
    // Log escalation start
    await db.vapiCalls.createEscalation({
      jobId: params.jobId,
      type: 'job_escalation',
      tailorsCount: params.tailors.length,
      status: 'in_progress'
    });
    
    // Call tailors in parallel batches of 5
    const batchSize = 5;
    
    for (let i = 0; i < params.tailors.length && !assignedTo; i += batchSize) {
      const batch = params.tailors.slice(i, i + batchSize);
      
      const callPromises = batch.map(tailor =>
        this.callTailorForJob(tailor, params.jobDetails)
      );
      
      const batchResults = await Promise.allSettled(callPromises);
      
      for (let j = 0; j < batchResults.length; j++) {
        const result = batchResults[j];
        const tailor = batch[j];
        
        if (result.status === 'fulfilled') {
          results.push(result.value);
          
          if (result.value.accepted) {
            assignedTo = tailor.tailorId;
            
            // Assign job to this tailor
            await db.tailorAssignments.create({
              suitId: params.jobDetails.suitNumber,
              tailorId: tailor.tailorId,
              status: 'claimed',
              claimedAt: new Date(),
              claimMethod: 'vapi_call'
            });
            
            // Cancel remaining calls
            // (They may have already started)
            break;
          }
        } else {
          results.push({
            callId: '',
            tailorId: tailor.tailorId,
            status: 'failed'
          });
        }
      }
      
      // Brief delay between batches if job still unassigned
      if (!assignedTo && i + batchSize < params.tailors.length) {
        await new Promise(resolve => setTimeout(resolve, 3000));
      }
    }
    
    // Log escalation result
    await db.vapiCalls.updateEscalation(params.jobId, {
      status: assignedTo ? 'assigned' : 'exhausted',
      assignedTo,
      callResults: results
    });
    
    // Emit event
    await eventBus.publish('vapi.escalation.completed', {
      jobId: params.jobId,
      assigned: !!assignedTo,
      assignedTo,
      tailorsCalled: results.length,
      acceptedCount: results.filter(r => r.accepted).length
    });
    
    return { assignedTo, results };
  }
  
  private async callTailorForJob(
    tailor: { tailorId: string; name: string; phone: string },
    jobDetails: any
  ): Promise<CallResult> {
    try {
      const call = await this.client.call({
        to: tailor.phone,
        assistantOverrides: {
          firstMessage: VAPI_ASSISTANTS.TAILOR_JOB_ESCALATION.firstMessage
            .replace('{{tailor_name}}', tailor.name),
          variableValues: {
            tailor_name: tailor.name,
            job_type: jobDetails.jobType,
            fabric_name: jobDetails.fabricName,
            payout: jobDetails.payout.toLocaleString(),
            deadline: jobDetails.deadline,
            job_id: jobDetails.suitNumber
          }
        },
        metadata: {
          type: 'job_escalation',
          tailorId: tailor.tailorId,
          jobId: jobDetails.suitNumber
        }
      });
      
      // Wait for call to complete (with timeout)
      const result = await this.waitForCallCompletion(call.id, 180000);
      
      // Get function call results
      const functionResults = result.functionCalls?.find(
        (fc: any) => fc.name === 'record_response'
      );
      
      return {
        callId: call.id,
        tailorId: tailor.tailorId,
        status: result.endedReason === 'customer-ended-call' ? 'completed' : 
                result.endedReason === 'no-answer' ? 'no_answer' :
                result.endedReason === 'busy' ? 'busy' : 'completed',
        accepted: functionResults?.parameters?.accepted || false,
        transcript: result.transcript,
        duration: result.duration
      };
      
    } catch (error: any) {
      console.error(`VAPI call failed for tailor ${tailor.tailorId}:`, error);
      return {
        callId: '',
        tailorId: tailor.tailorId,
        status: 'failed'
      };
    }
  }
  
  // ============================================
  // SLA WARNING CALLS
  // ============================================
  
  async callTailorSLAWarning(
    tailor: { id: string; name: string; phone: string },
    job: { suitNumber: string; timeRemaining: string; currentStage: string }
  ): Promise<any> {
    const call = await this.client.call({
      to: tailor.phone,
      assistantOverrides: {
        model: VAPI_ASSISTANTS.TAILOR_SLA_WARNING.model,
        voice: VAPI_ASSISTANTS.TAILOR_SLA_WARNING.voice,
        firstMessage: VAPI_ASSISTANTS.TAILOR_SLA_WARNING.firstMessage
          .replace('{{tailor_name}}', tailor.name)
          .replace('{{suit_number}}', job.suitNumber),
        variableValues: {
          tailor_name: tailor.name,
          suit_number: job.suitNumber,
          time_remaining: job.timeRemaining,
          current_stage: job.currentStage
        }
      },
      metadata: {
        type: 'sla_warning',
        tailorId: tailor.id,
        suitNumber: job.suitNumber
      }
    });
    
    const result = await this.waitForCallCompletion(call.id, 200000);
    
    // Process function results
    const statusUpdate = result.functionCalls?.find(
      (fc: any) => fc.name === 'record_status_update'
    );
    
    if (statusUpdate) {
      // Update production status based on call
      await db.tailorAssignments.updateStatus(job.suitNumber, {
        lastStatusUpdate: new Date(),
        reportedStage: statusUpdate.parameters.current_stage,
        estimatedCompletion: statusUpdate.parameters.estimated_completion,
        issues: statusUpdate.parameters.issues
      });
      
      if (statusUpdate.parameters.needs_support) {
        await eventBus.publish('tailor.support.requested', {
          tailorId: tailor.id,
          suitNumber: job.suitNumber,
          issues: statusUpdate.parameters.issues
        });
      }
    }
    
    return result;
  }
  
  // ============================================
  // CUSTOMER DELIVERY CALLS
  // ============================================
  
  async callCustomerDeliveryNotification(
    customer: { name: string; phone: string },
    delivery: {
      suitDescription: string;
      driverName: string;
      etaMinutes: number;
      hotelName: string;
    }
  ): Promise<any> {
    const hour = new Date().getHours();
    const timeOfDay = hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : 'evening';
    
    const call = await this.client.call({
      to: customer.phone,
      assistantOverrides: {
        model: VAPI_ASSISTANTS.CUSTOMER_DELIVERY_CALL.model,
        voice: VAPI_ASSISTANTS.CUSTOMER_DELIVERY_CALL.voice,
        firstMessage: VAPI_ASSISTANTS.CUSTOMER_DELIVERY_CALL.firstMessage
          .replace('{{time_of_day}}', timeOfDay)
          .replace('{{customer_name}}', customer.name),
        variableValues: {
          customer_name: customer.name,
          time_of_day: timeOfDay,
          suit_description: delivery.suitDescription,
          driver_name: delivery.driverName,
          eta_minutes: delivery.etaMinutes.toString(),
          hotel_name: delivery.hotelName
        }
      },
      metadata: {
        type: 'delivery_notification',
        customerPhone: customer.phone
      }
    });
    
    const result = await this.waitForCallCompletion(call.id, 150000);
    
    // Process delivery preferences
    const preference = result.functionCalls?.find(
      (fc: any) => fc.name === 'record_delivery_preference'
    );
    
    if (preference && !preference.parameters.available) {
      // Update delivery instructions
      await eventBus.publish('delivery.preference.updated', {
        customerPhone: customer.phone,
        alternateRecipient: preference.parameters.alternate_recipient,
        instructions: preference.parameters.special_instructions
      });
    }
    
    return result;
  }
  
  // ============================================
  // UTILITY METHODS
  // ============================================
  
  private async waitForCallCompletion(
    callId: string,
    timeoutMs: number
  ): Promise<any> {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeoutMs) {
      const call = await this.client.getCall(callId);
      
      if (call.status === 'ended') {
        return call;
      }
      
      // Poll every 2 seconds
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
    
    // Timeout - end the call
    await this.client.endCall(callId);
    return this.client.getCall(callId);
  }
  
  // Webhook handler for VAPI events
  async handleWebhook(event: any): Promise<void> {
    switch (event.type) {
      case 'call-started':
        await db.vapiCalls.updateCallStatus(event.call.id, 'in_progress');
        break;
        
      case 'call-ended':
        await db.vapiCalls.updateCallStatus(event.call.id, 'completed', {
          duration: event.call.duration,
          endedReason: event.call.endedReason,
          transcript: event.call.transcript
        });
        break;
        
      case 'function-call':
        // Function was called during conversation
        await this.handleFunctionCall(event.call.id, event.functionCall);
        break;
        
      case 'transcript':
        // Real-time transcript update
        await db.vapiCalls.appendTranscript(event.call.id, event.transcript);
        break;
    }
  }
  
  private async handleFunctionCall(callId: string, functionCall: any): Promise<void> {
    // Log function call
    await db.vapiCalls.logFunctionCall(callId, functionCall);
    
    // Emit event for processing
    await eventBus.publish('vapi.function.called', {
      callId,
      functionName: functionCall.name,
      parameters: functionCall.parameters
    });
  }
}

export { VAPIService };
```

---

## Part 3: Mobile App Specifications

### App Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    SUIT AI Mobile Apps                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │  Customer   │  │   Tailor    │  │   Driver    │             │
│  │    App      │  │    App      │  │    App      │             │
│  │             │  │             │  │             │             │
│  │ Order       │  │ Job Board   │  │ Route Nav   │             │
│  │ Tracking    │  │ Production  │  │ Deliveries  │             │
│  │ 3D Scan     │  │ Earnings    │  │ Collections │             │
│  └─────────────┘  └─────────────┘  └─────────────┘             │
│                                                                  │
│  ┌─────────────┐  ┌─────────────┐                               │
│  │  Inspector  │  │    Admin    │                               │
│  │    App      │  │    App      │                               │
│  │             │  │             │                               │
│  │ QC Checks   │  │ Dashboard   │                               │
│  │ Routing     │  │ Staff Mgmt  │                               │
│  │ Results     │  │ Alerts      │                               │
│  └─────────────┘  └─────────────┘                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 1. Tailor App

#### User Profile & Permissions

```typescript
interface TailorUser {
  id: string;
  name: string;
  phone: string;
  email?: string;
  
  // Professional details
  skill_level: 'standard' | 'advanced' | 'master';
  specializations: string[]; // ['jacket', 'trousers', 'waistcoat']
  years_experience: number;
  
  // Workshop
  workshop_address: string;
  workshop_coordinates: [number, number];
  distance_to_qc_station: number;
  
  // Capacity
  max_concurrent_jobs: number;
  
  // Inventory
  fabric_variants_in_stock: string[];
  
  // Banking
  stripe_connect_id: string;
  bank_account_last4: string;
  
  // Status
  status: 'active' | 'inactive' | 'suspended';
  available_from?: Date;
  
  // Performance
  stats: {
    total_jobs: number;
    qc_pass_rate: number;
    avg_production_time_hours: number;
    total_earnings: number;
    rating: number;
  };
}
```

#### Screens & Features

```typescript
const TAILOR_APP_SCREENS = {
  
  // ============================================
  // HOME / DASHBOARD
  // ============================================
  
  HOME: {
    name: 'Home',
    need_to_know: [
      'Active jobs count and status',
      'Earnings today/this week',
      'Upcoming deadlines',
      'Available jobs count',
      'Performance score'
    ],
    components: [
      {
        type: 'stats_row',
        items: ['active_jobs', 'todays_earnings', 'qc_rate']
      },
      {
        type: 'active_jobs_list',
        shows: 'Current jobs with countdown timers'
      },
      {
        type: 'quick_actions',
        items: ['view_job_board', 'update_status', 'mark_complete']
      },
      {
        type: 'notifications_preview',
        shows: 'Latest 3 notifications'
      }
    ]
  },
  
  // ============================================
  // JOB BOARD
  // ============================================
  
  JOB_BOARD: {
    name: 'Available Jobs',
    need_to_know: [
      'Jobs matching their fabric inventory',
      'Jobs matching their skill level',
      'Payout for each job',
      'Deadline urgency',
      'Distance for pattern delivery'
    ],
    components: [
      {
        type: 'filter_bar',
        filters: ['fabric_type', 'complexity', 'payout_range', 'deadline']
      },
      {
        type: 'job_list',
        card_shows: [
          'Job type (2-piece, 3-piece)',
          'Fabric name and color',
          'Payout amount',
          'Deadline countdown',
          'Complexity indicator',
          'Rush bonus indicator'
        ]
      }
    ],
    actions: {
      tap_job: 'Open job details',
      pull_refresh: 'Refresh available jobs'
    }
  },
  
  JOB_DETAILS: {
    name: 'Job Details',
    need_to_know: [
      'Complete job specifications',
      'Payout breakdown',
      'Deadline with countdown',
      'Tech pack preview'
    ],
    components: [
      {
        type: 'job_header',
        shows: ['suit_number', 'job_type', 'fabric_swatch']
      },
      {
        type: 'payout_breakdown',
        shows: ['fabric_allowance', 'labor_fee', 'rush_bonus', 'total']
      },
      {
        type: 'deadline_countdown',
        shows: 'Visual countdown with urgency color'
      },
      {
        type: 'requirements_list',
        shows: ['style_details', 'fabric_requirements', 'special_instructions']
      },
      {
        type: 'tech_pack_preview',
        shows: 'Thumbnail of pattern pieces'
      }
    ],
    actions: {
      claim_job: {
        requires: ['confirm_fabric_stock', 'accept_deadline'],
        result: 'Job claimed, pattern dispatch begins'
      },
      view_tech_pack: 'Open full tech pack PDF'
    }
  },
  
  // ============================================
  // ACTIVE JOB MANAGEMENT
  // ============================================
  
  ACTIVE_JOB: {
    name: 'Active Job',
    need_to_know: [
      'Current stage of production',
      'Time remaining on SLA',
      'Tech pack access',
      'Pattern delivery status',
      'Photo documentation requirements'
    ],
    components: [
      {
        type: 'sla_timer',
        shows: 'Large countdown, changes color as deadline approaches'
      },
      {
        type: 'stage_tracker',
        stages: [
          'fabric_cutting',
          'canvas_fusing',
          'body_assembly',
          'sleeve_setting',
          'collar_lapel',
          'trouser_construction',
          'hand_finishing',
          'final_press'
        ],
        interaction: 'Tap to mark stage complete'
      },
      {
        type: 'pattern_status',
        shows: 'Delivery tracking for pattern tube'
      },
      {
        type: 'tech_pack_button',
        action: 'Open full tech pack'
      },
      {
        type: 'photo_requirements',
        shows: 'Required photos for each stage'
      }
    ],
    actions: {
      update_stage: {
        requires: 'Photo upload for current stage',
        result: 'Stage marked complete, moves to next'
      },
      report_issue: 'Open issue reporting form',
      mark_complete: 'Submit for QC'
    }
  },
  
  STAGE_UPDATE: {
    name: 'Update Stage',
    need_to_know: [
      'What photo is needed',
      'Quality requirements for photo',
      'Option to add notes'
    ],
    components: [
      {
        type: 'photo_capture',
        requirements: ['Good lighting', 'Full garment visible', 'Flat surface']
      },
      {
        type: 'notes_input',
        optional: true
      },
      {
        type: 'submit_button'
      }
    ]
  },
  
  MARK_COMPLETE: {
    name: 'Submit for QC',
    need_to_know: [
      'Final photos required',
      'Self-check checklist',
      'What happens next'
    ],
    components: [
      {
        type: 'final_photos',
        required: ['front_view', 'back_view', 'lapel_detail', 'trouser_detail']
      },
      {
        type: 'self_check_checklist',
        items: [
          'All buttons secure',
          'Buttonholes clean',
          'Seams pressed',
          'Lining attached properly',
          'No loose threads'
        ]
      },
      {
        type: 'submit_button',
        action: 'Triggers QC inspector dispatch'
      }
    ]
  },
  
  // ============================================
  // EARNINGS
  // ============================================
  
  EARNINGS: {
    name: 'Earnings',
    need_to_know: [
      'Total earnings by period',
      'Pending payouts',
      'Completed payouts',
      'Breakdown by job'
    ],
    components: [
      {
        type: 'period_selector',
        options: ['Today', 'This Week', 'This Month', 'All Time']
      },
      {
        type: 'earnings_summary',
        shows: ['total_earned', 'pending', 'paid_out']
      },
      {
        type: 'earnings_chart',
        shows: 'Daily earnings bar chart'
      },
      {
        type: 'transaction_list',
        shows: 'List of payouts with job references'
      }
    ],
    actions: {
      tap_transaction: 'View payout details',
      download_statement: 'Export earnings statement'
    }
  },
  
  // ============================================
  // INVENTORY
  // ============================================
  
  INVENTORY: {
    name: 'Fabric Inventory',
    need_to_know: [
      'Which fabrics they have in stock',
      'Which fabrics are needed for available jobs',
      'Low stock warnings'
    ],
    components: [
      {
        type: 'fabric_list',
        shows: 'All Saffire fabric variants with stock status'
      },
      {
        type: 'in_demand_section',
        shows: 'Fabrics needed for current jobs they could take'
      }
    ],
    actions: {
      toggle_stock: 'Mark fabric as in/out of stock',
      add_fabric: 'Add new fabric variant'
    }
  },
  
  // ============================================
  // PROFILE & SETTINGS
  // ============================================
  
  PROFILE: {
    name: 'Profile',
    need_to_know: [
      'Their performance metrics',
      'Account status',
      'Banking details',
      'Support contact'
    ],
    components: [
      {
        type: 'profile_header',
        shows: ['name', 'skill_level', 'rating', 'member_since']
      },
      {
        type: 'stats_cards',
        shows: ['total_jobs', 'qc_pass_rate', 'avg_time', 'total_earned']
      },
      {
        type: 'settings_list',
        items: [
          'notification_preferences',
          'availability_schedule',
          'banking_details',
          'language',
          'help_support'
        ]
      }
    ]
  }
};
```

---

### 2. Driver App

#### User Profile & Permissions

```typescript
interface DriverUser {
  id: string;
  name: string;
  phone: string;
  email?: string;
  
  // License
  license_number: string;
  license_expiry: Date;
  
  // Vehicle
  assigned_van_id?: string;
  assigned_van_number?: string;
  
  // Work
  base_airport: string; // 'SHJ', 'AUH'
  shift_preference: 'morning' | 'evening' | 'flexible';
  
  // Status
  status: 'available' | 'on_route' | 'on_break' | 'off_duty';
  current_route_id?: string;
  
  // Performance
  stats: {
    total_deliveries: number;
    on_time_rate: number;
    customer_rating: number;
    total_distance_km: number;
  };
}
```

#### Screens & Features

```typescript
const DRIVER_APP_SCREENS = {
  
  // ============================================
  // HOME / DASHBOARD
  // ============================================
  
  HOME: {
    name: 'Home',
    need_to_know: [
      'Current route status',
      'Next pickup/delivery',
      'Shift hours remaining',
      'Today\'s stats'
    ],
    components: [
      {
        type: 'status_banner',
        shows: 'Current status (Available / On Route / On Break)'
      },
      {
        type: 'current_route_card',
        shows: [
          'Route summary if active',
          'Next stop details',
          'Suits remaining'
        ]
      },
      {
        type: 'quick_stats',
        shows: ['deliveries_today', 'on_time_rate', 'hours_worked']
      },
      {
        type: 'upcoming_routes',
        shows: 'Scheduled routes for today'
      }
    ],
    actions: {
      start_route: 'Begin active route',
      go_available: 'Mark as available for routes',
      take_break: 'Start break timer'
    }
  },
  
  // ============================================
  // ACTIVE ROUTE
  // ============================================
  
  ACTIVE_ROUTE: {
    name: 'Active Route',
    need_to_know: [
      'Current destination',
      'Full stop sequence',
      'Suits for each stop',
      'ETAs',
      'Navigation'
    ],
    components: [
      {
        type: 'map_view',
        shows: [
          'Current location',
          'Route path',
          'All stop markers',
          'Traffic overlay'
        ]
      },
      {
        type: 'current_stop_card',
        shows: [
          'Hotel name and address',
          'Suits count',
          'ETA',
          'Special instructions',
          'Concierge contact'
        ]
      },
      {
        type: 'progress_bar',
        shows: 'Stops completed / total'
      },
      {
        type: 'navigate_button',
        action: 'Open in Google Maps / Waze'
      }
    ],
    actions: {
      arrived: 'Mark arrived at stop',
      navigate: 'Open navigation',
      view_all_stops: 'Expand stop list',
      report_issue: 'Report delay/problem'
    }
  },
  
  STOP_DETAILS: {
    name: 'Stop Details',
    need_to_know: [
      'Hotel information',
      'Delivery entrance',
      'Suits to deliver',
      'Customer details for each suit',
      'Verification codes'
    ],
    components: [
      {
        type: 'hotel_header',
        shows: ['name', 'address', 'photo']
      },
      {
        type: 'delivery_instructions',
        shows: ['entrance', 'parking', 'special_notes']
      },
      {
        type: 'concierge_contact',
        shows: ['name', 'phone'],
        action: 'Tap to call'
      },
      {
        type: 'suits_list',
        shows: [
          'Suit number',
          'Customer name',
          'Room number',
          'Verification code'
        ]
      }
    ],
    actions: {
      call_concierge: 'Direct call',
      mark_arrived: 'Begin delivery process'
    }
  },
  
  DELIVERY_CONFIRMATION: {
    name: 'Confirm Delivery',
    need_to_know: [
      'Which suits being delivered',
      'Who received them',
      'Proof of delivery requirements'
    ],
    components: [
      {
        type: 'suits_checklist',
        shows: 'Each suit with checkbox'
      },
      {
        type: 'recipient_selector',
        options: ['Customer', 'Concierge', 'Front Desk', 'Room Service']
      },
      {
        type: 'recipient_name_input'
      },
      {
        type: 'signature_capture',
        optional_for: ['concierge', 'front_desk']
      },
      {
        type: 'photo_capture',
        required: true,
        instruction: 'Photo of handover'
      }
    ],
    actions: {
      confirm_delivery: 'Complete delivery and move to next stop'
    }
  },
  
  DELIVERY_ISSUE: {
    name: 'Report Issue',
    need_to_know: [
      'Issue types',
      'Impact on delivery',
      'Next steps'
    ],
    components: [
      {
        type: 'issue_type_selector',
        options: [
          'Customer not available',
          'Wrong address',
          'Access denied',
          'Traffic delay',
          'Vehicle issue',
          'Other'
        ]
      },
      {
        type: 'description_input'
      },
      {
        type: 'photo_capture',
        optional: true
      }
    ],
    actions: {
      submit_issue: 'Report and get guidance'
    },
    response: {
      shows: 'System recommendation (retry, skip, hold, etc.)'
    }
  },
  
  // ============================================
  // COLLECTION (FROM AIRPORT)
  // ============================================
  
  COLLECTION: {
    name: 'Cargo Collection',
    need_to_know: [
      'Airport and cargo area',
      'Number of suits to collect',
      'Customs clearance status',
      'Loading checklist'
    ],
    components: [
      {
        type: 'collection_header',
        shows: ['airport', 'cargo_area', 'flight_number']
      },
      {
        type: 'clearance_status',
        shows: 'Customs status with timestamp'
      },
      {
        type: 'manifest_list',
        shows: 'All suits to collect with checkboxes'
      },
      {
        type: 'scan_button',
        action: 'Scan suit barcodes'
      }
    ],
    actions: {
      scan_suit: 'Scan barcode to confirm collection',
      confirm_all_loaded: 'Begin route'
    }
  },
  
  // ============================================
  // HISTORY & STATS
  // ============================================
  
  HISTORY: {
    name: 'Delivery History',
    need_to_know: [
      'Past deliveries',
      'Performance metrics',
      'Any issues flagged'
    ],
    components: [
      {
        type: 'period_filter',
        options: ['Today', 'This Week', 'This Month']
      },
      {
        type: 'stats_summary',
        shows: ['total_deliveries', 'on_time_rate', 'distance_covered']
      },
      {
        type: 'delivery_list',
        shows: 'List of completed deliveries'
      }
    ]
  },
  
  // ============================================
  // PROFILE
  // ============================================
  
  PROFILE: {
    name: 'Profile',
    need_to_know: [
      'Account status',
      'Vehicle assignment',
      'Performance rating',
      'Documents status'
    ],
    components: [
      {
        type: 'profile_header',
        shows: ['name', 'rating', 'badge_level']
      },
      {
        type: 'vehicle_info',
        shows: ['van_number', 'license_plate']
      },
      {
        type: 'documents',
        shows: ['license_status', 'license_expiry']
      },
      {
        type: 'settings',
        items: ['notifications', 'language', 'support']
      }
    ]
  }
};
```

---

### 3. Inspector App

#### User Profile & Permissions

```typescript
interface InspectorUser {
  id: string;
  name: string;
  phone: string;
  email?: string;
  
  // Work area
  assigned_zone: string;
  base_location: [number, number];
  
  // Status
  status: 'available' | 'on_inspection' | 'in_transit' | 'off_duty';
  current_inspection_id?: string;
  
  // Performance
  stats: {
    total_inspections: number;
    inspections_today: number;
    avg_inspection_time_minutes: number;
    accuracy_rate: number; // Correlation with final customer feedback
  };
}
```

#### Screens & Features

```typescript
const INSPECTOR_APP_SCREENS = {
  
  // ============================================
  // HOME
  // ============================================
  
  HOME: {
    name: 'Home',
    need_to_know: [
      'Assigned inspections',
      'Priority indicators',
      'Location of each',
      'Schedule overview'
    ],
    components: [
      {
        type: 'status_toggle',
        options: ['Available', 'Busy', 'Off Duty']
      },
      {
        type: 'today_schedule',
        shows: 'Timeline of assigned inspections'
      },
      {
        type: 'inspection_list',
        shows: [
          'Tailor name and location',
          'Scheduled time',
          'Priority level',
          'Distance from current location'
        ]
      },
      {
        type: 'stats_summary',
        shows: ['inspections_today', 'pass_rate_today']
      }
    ]
  },
  
  // ============================================
  // INSPECTION DETAILS
  // ============================================
  
  INSPECTION_DETAILS: {
    name: 'Inspection Details',
    need_to_know: [
      'Tailor location',
      'Suit specifications',
      'Key measurements to check',
      'Tech pack reference'
    ],
    components: [
      {
        type: 'tailor_info',
        shows: ['name', 'address', 'phone', 'distance']
      },
      {
        type: 'suit_summary',
        shows: ['suit_number', 'style', 'fabric']
      },
      {
        type: 'key_measurements',
        shows: 'Critical measurements with tolerances'
      },
      {
        type: 'tech_pack_button',
        action: 'View full specifications'
      },
      {
        type: 'map_preview',
        shows: 'Location with navigate button'
      }
    ],
    actions: {
      navigate: 'Open navigation',
      call_tailor: 'Direct call',
      start_inspection: 'Begin QC process'
    }
  },
  
  // ============================================
  // QC CHECKLIST
  // ============================================
  
  QC_CHECKLIST: {
    name: 'Quality Checklist',
    need_to_know: [
      'All check items',
      'Scoring criteria',
      'Photo requirements',
      'Tolerance ranges'
    ],
    components: [
      {
        type: 'section_tabs',
        sections: ['Visual', 'Measurements', 'Construction', 'Finishing']
      },
      {
        type: 'visual_checks',
        items: [
          { name: 'Overall appearance', type: 'score_1_5' },
          { name: 'Symmetry', type: 'score_1_5' },
          { name: 'Fabric condition', type: 'pass_fail' },
          { name: 'Color consistency', type: 'pass_fail' },
          { name: 'Pattern alignment', type: 'pass_fail' }
        ]
      },
      {
        type: 'measurement_checks',
        items: [
          { name: 'Chest', target: 102.5, tolerance: 1.0 },
          { name: 'Waist', target: 86.0, tolerance: 1.0 },
          { name: 'Jacket length', target: 74.0, tolerance: 0.5 },
          // ... more measurements
        ],
        input: 'Numeric with +/- indicator'
      },
      {
        type: 'construction_checks',
        items: [
          { name: 'Seam quality', type: 'score_1_5' },
          { name: 'Canvas attachment', type: 'pass_fail' },
          { name: 'Shoulder padding', type: 'pass_fail' },
          { name: 'Sleeve roll', type: 'pass_fail' }
        ]
      },
      {
        type: 'finishing_checks',
        items: [
          { name: 'Buttonholes', type: 'score_1_5' },
          { name: 'Hand stitching', type: 'score_1_5' },
          { name: 'Pressing', type: 'pass_fail' },
          { name: 'Lining', type: 'pass_fail' }
        ]
      },
      {
        type: 'photo_requirements',
        required: ['front', 'back', 'lapel', 'inside', 'trouser']
      }
    ],
    actions: {
      save_progress: 'Save and continue later',
      submit_result: 'Complete inspection'
    }
  },
  
  // ============================================
  // SUBMIT RESULT
  // ============================================
  
  SUBMIT_RESULT: {
    name: 'Submit Result',
    need_to_know: [
      'Overall score calculation',
      'Pass/fail threshold',
      'Consequence of each result',
      'Feedback to tailor'
    ],
    components: [
      {
        type: 'score_summary',
        shows: [
          'Visual score',
          'Measurement score',
          'Construction score',
          'Finishing score',
          'Overall score'
        ]
      },
      {
        type: 'result_selector',
        options: [
          { value: 'pass', label: 'PASS', condition: 'All criteria met' },
          { value: 'conditional_pass', label: 'CONDITIONAL PASS', condition: 'Minor issues, can ship' },
          { value: 'fail', label: 'FAIL', condition: 'Rework required' }
        ]
      },
      {
        type: 'issues_list',
        condition: 'If fail or conditional',
        shows: 'List of failed items with severity'
      },
      {
        type: 'rework_instructions',
        condition: 'If fail',
        input: 'Text field for specific instructions'
      },
      {
        type: 'notes_input',
        optional: true
      }
    ],
    actions: {
      submit: {
        pass: 'Triggers payout, suit moves to packing',
        conditional_pass: 'Triggers payout, notes flagged',
        fail: 'Triggers rework assignment, backup activation'
      }
    }
  },
  
  // ============================================
  // HISTORY
  // ============================================
  
  HISTORY: {
    name: 'Inspection History',
    need_to_know: [
      'Past inspections',
      'Results breakdown',
      'Performance trends'
    ],
    components: [
      {
        type: 'stats_cards',
        shows: ['total', 'pass_rate', 'avg_time']
      },
      {
        type: 'inspection_list',
        shows: 'Past inspections with results'
      }
    ]
  }
};
```

---

### 4. Admin App

#### User Profile & Permissions

```typescript
interface AdminUser {
  id: string;
  name: string;
  email: string;
  phone: string;
  
  // Role
  role: 'super_admin' | 'operations_manager' | 'shift_supervisor' | 'support';
  
  // Permissions
  permissions: {
    view_dashboard: boolean;
    manage_orders: boolean;
    manage_staff: boolean;
    manage_flights: boolean;
    manage_alerts: boolean;
    view_financials: boolean;
    system_settings: boolean;
  };
  
  // Notifications
  alert_categories: string[]; // Which alert types they receive
}

// Permission matrix
const ROLE_PERMISSIONS = {
  super_admin: {
    view_dashboard: true,
    manage_orders: true,
    manage_staff: true,
    manage_flights: true,
    manage_alerts: true,
    view_financials: true,
    system_settings: true
  },
  operations_manager: {
    view_dashboard: true,
    manage_orders: true,
    manage_staff: true,
    manage_flights: true,
    manage_alerts: true,
    view_financials: true,
    system_settings: false
  },
  shift_supervisor: {
    view_dashboard: true,
    manage_orders: true,
    manage_staff: false,
    manage_flights: false,
    manage_alerts: true,
    view_financials: false,
    system_settings: false
  },
  support: {
    view_dashboard: true,
    manage_orders: false,
    manage_staff: false,
    manage_flights: false,
    manage_alerts: false,
    view_financials: false,
    system_settings: false
  }
};
```

#### Screens & Features

```typescript
const ADMIN_APP_SCREENS = {
  
  // ============================================
  // DASHBOARD
  // ============================================
  
  DASHBOARD: {
    name: 'Dashboard',
    need_to_know: [
      'Pipeline status at a glance',
      'Risk alerts',
      'Flight status',
      'Ground fleet status',
      'Key metrics'
    ],
    components: [
      {
        type: 'pipeline_funnel',
        shows: [
          'Orders received',
          'In production',
          'In QC',
          'Packed',
          'In transit',
          'Delivered'
        ]
      },
      {
        type: 'risk_summary',
        shows: ['green', 'amber', 'red', 'critical'],
        action: 'Tap to see at-risk suits'
      },
      {
        type: 'alerts_preview',
        shows: 'Top 3 critical/red alerts',
        action: 'Tap to manage'
      },
      {
        type: 'flights_status',
        shows: 'Today\'s flights with status'
      },
      {
        type: 'fleet_map_preview',
        shows: 'Van locations on map'
      },
      {
        type: 'kpis',
        shows: ['on_time_rate', 'qc_pass_rate', 'avg_delivery_time']
      }
    ]
  },
  
  // ============================================
  // ALERTS
  // ============================================
  
  ALERTS: {
    name: 'Alerts',
    need_to_know: [
      'All active alerts',
      'Severity and age',
      'Affected entity',
      'Recommended action'
    ],
    components: [
      {
        type: 'filter_tabs',
        options: ['Critical', 'Red', 'Amber', 'All']
      },
      {
        type: 'alert_list',
        card_shows: [
          'Severity indicator',
          'Title',
          'Affected entity (suit/flight/van)',
          'Time since created',
          'Status (open/acknowledged)'
        ]
      }
    ],
    actions: {
      tap_alert: 'Open alert details',
      swipe_acknowledge: 'Quick acknowledge'
    }
  },
  
  ALERT_DETAILS: {
    name: 'Alert Details',
    need_to_know: [
      'Full alert context',
      'Entity details',
      'Timeline of events',
      'Recommended actions'
    ],
    components: [
      {
        type: 'alert_header',
        shows: ['severity', 'title', 'created_at']
      },
      {
        type: 'entity_card',
        shows: 'Details of affected suit/flight/van'
      },
      {
        type: 'risk_factors',
        shows: 'Contributing factors with weights'
      },
      {
        type: 'recommended_action',
        shows: 'System recommendation'
      },
      {
        type: 'action_history',
        shows: 'What\'s been done so far'
      }
    ],
    actions: {
      acknowledge: 'Mark as being handled',
      resolve: 'Mark as resolved with notes',
      escalate: 'Escalate to higher level',
      intervene: 'Take manual action (reassign, etc.)'
    }
  },
  
  // ============================================
  // SUITS TRACKING
  // ============================================
  
  SUITS: {
    name: 'Suit Tracking',
    need_to_know: [
      'All active suits',
      'Status and location',
      'Risk level',
      'Time to deadline'
    ],
    components: [
      {
        type: 'search_bar',
        searches: ['suit_number', 'customer_name', 'hotel']
      },
      {
        type: 'filter_bar',
        filters: ['status', 'risk_level', 'destination']
      },
      {
        type: 'suit_list',
        card_shows: [
          'Suit number',
          'Status',
          'Risk indicator',
          'Deadline countdown',
          'Current location'
        ]
      }
    ]
  },
  
  SUIT_DETAILS: {
    name: 'Suit Details',
    need_to_know: [
      'Complete suit journey',
      'All assignments',
      'Timeline of events',
      'Current risk factors'
    ],
    components: [
      {
        type: 'suit_header',
        shows: ['suit_number', 'status', 'risk_score']
      },
      {
        type: 'customer_info',
        shows: ['name', 'hotel', 'deadline']
      },
      {
        type: 'timeline',
        shows: 'Full event history'
      },
      {
        type: 'assignments',
        shows: ['tailor', 'inspector', 'flight', 'van']
      },
      {
        type: 'location_map',
        shows: 'Current location if in transit'
      }
    ],
    actions: {
      contact_customer: 'Call or message',
      reassign: 'Change tailor/driver',
      expedite: 'Mark as priority',
      cancel: 'Cancel order (with confirmation)'
    }
  },
  
  // ============================================
  // STAFF MANAGEMENT
  // ============================================
  
  STAFF: {
    name: 'Staff Management',
    need_to_know: [
      'All staff by category',
      'Active/inactive status',
      'Performance metrics',
      'Current assignments'
    ],
    components: [
      {
        type: 'category_tabs',
        options: ['Tailors', 'Drivers', 'Inspectors', 'Admins']
      },
      {
        type: 'staff_list',
        card_shows: [
          'Name and photo',
          'Status indicator',
          'Current workload',
          'Performance score'
        ]
      },
      {
        type: 'add_staff_button'
      }
    ]
  },
  
  STAFF_PROFILE: {
    name: 'Staff Profile',
    need_to_know: [
      'Complete profile',
      'Performance history',
      'Current assignments',
      'Account status'
    ],
    components: [
      {
        type: 'profile_header',
        shows: ['name', 'photo', 'role', 'status']
      },
      {
        type: 'contact_info',
        shows: ['phone', 'email', 'address']
      },
      {
        type: 'performance_stats',
        shows: 'Role-specific metrics'
      },
      {
        type: 'current_work',
        shows: 'Active assignments'
      },
      {
        type: 'history',
        shows: 'Recent completed work'
      },
      {
        type: 'account_actions',
        shows: ['status_toggle', 'edit_profile', 'reset_password']
      }
    ],
    actions: {
      edit: 'Edit profile details',
      suspend: 'Temporarily suspend account',
      deactivate: 'Fully deactivate',
      message: 'Send notification',
      call: 'Direct call'
    }
  },
  
  ADD_STAFF: {
    name: 'Add Staff Member',
    need_to_know: [
      'Required fields by role',
      'Verification requirements',
      'Initial setup steps'
    ],
    components: [
      {
        type: 'role_selector',
        options: ['Tailor', 'Driver', 'Inspector', 'Admin']
      },
      {
        type: 'basic_info_form',
        fields: ['name', 'phone', 'email']
      },
      {
        type: 'role_specific_form',
        tailor: ['skill_level', 'workshop_address', 'bank_details'],
        driver: ['license_number', 'license_expiry', 'base_airport'],
        inspector: ['assigned_zone'],
        admin: ['role', 'permissions']
      },
      {
        type: 'document_upload',
        required_by_role: {
          tailor: ['id_proof', 'address_proof'],
          driver: ['license_copy', 'id_proof'],
          inspector: ['id_proof'],
          admin: []
        }
      }
    ],
    actions: {
      create: 'Create account and send invitation'
    }
  },
  
  // ============================================
  // FLIGHTS
  // ============================================
  
  FLIGHTS: {
    name: 'Flight Operations',
    need_to_know: [
      'Today\'s flights',
      'Status of each',
      'Manifest details',
      'Delays or issues'
    ],
    components: [
      {
        type: 'date_selector'
      },
      {
        type: 'flight_list',
        card_shows: [
          'Flight number',
          'Route (with stops)',
          'Status',
          'Suits loaded',
          'Departure/arrival times'
        ]
      }
    ]
  },
  
  FLIGHT_DETAILS: {
    name: 'Flight Details',
    need_to_know: [
      'Complete flight info',
      'Route legs',
      'Manifest breakdown',
      'At-risk suits on flight'
    ],
    components: [
      {
        type: 'flight_header',
        shows: ['flight_number', 'aircraft', 'status']
      },
      {
        type: 'route_timeline',
        shows: 'All legs with times and status'
      },
      {
        type: 'manifest_summary',
        shows: ['total_suits', 'by_destination', 'at_risk_count']
      },
      {
        type: 'position_map',
        shows: 'Current flight position if in air'
      }
    ],
    actions: {
      modify_route: 'Change routing (if not departed)',
      view_manifest: 'Full suit list',
      report_delay: 'Log delay'
    }
  },
  
  // ============================================
  // SETTINGS
  // ============================================
  
  SETTINGS: {
    name: 'Settings',
    need_to_know: [
      'System configuration',
      'Notification settings',
      'Account management'
    ],
    components: [
      {
        type: 'settings_sections',
        sections: [
          {
            name: 'Notifications',
            items: ['alert_categories', 'channels', 'quiet_hours']
          },
          {
            name: 'System',
            items: ['risk_thresholds', 'auto_interventions'],
            requires_permission: 'system_settings'
          },
          {
            name: 'Account',
            items: ['profile', 'password', 'two_factor']
          }
        ]
      }
    ]
  }
};
```

---

### Staff Management Dashboard (Web)

```typescript
// staff-management-dashboard.tsx

interface StaffDashboardProps {
  userRole: AdminRole;
}

const StaffManagementDashboard: React.FC<StaffDashboardProps> = ({ userRole }) => {
  
  return (
    <DashboardLayout>
      
      {/* ============================================ */}
      {/* OVERVIEW SECTION */}
      {/* ============================================ */}
      
      <Section title="Staff Overview">
        <StatsGrid>
          <StatCard
            title="Tailors"
            stats={{
              total: 127,
              active: 89,
              working_now: 67,
              avg_qc_rate: '91.2%'
            }}
            icon={<TailorIcon />}
          />
          <StatCard
            title="Drivers"
            stats={{
              total: 12,
              on_duty: 8,
              on_route: 6,
              available: 2
            }}
            icon={<DriverIcon />}
          />
          <StatCard
            title="Inspectors"
            stats={{
              total: 21,
              active: 18,
              on_inspection: 5,
              available: 13
            }}
            icon={<InspectorIcon />}
          />
          <StatCard
            title="Admins"
            stats={{
              total: 8,
              online: 4
            }}
            icon={<AdminIcon />}
          />
        </StatsGrid>
      </Section>
      
      {/* ============================================ */}
      {/* TAILOR MANAGEMENT */}
      {/* ============================================ */}
      
      <Section title="Tailor Network">
        <Tabs>
          <Tab label="All Tailors">
            <TailorTable
              columns={[
                { key: 'name', label: 'Name', sortable: true },
                { key: 'skill_level', label: 'Skill', sortable: true },
                { key: 'status', label: 'Status', filterable: true },
                { key: 'current_jobs', label: 'Active Jobs' },
                { key: 'qc_pass_rate', label: 'QC Rate', sortable: true },
                { key: 'avg_time', label: 'Avg Time' },
                { key: 'total_jobs', label: 'Total Jobs', sortable: true },
                { key: 'actions', label: '' }
              ]}
              filters={[
                { key: 'status', options: ['active', 'inactive', 'suspended'] },
                { key: 'skill_level', options: ['standard', 'advanced', 'master'] },
                { key: 'has_capacity', label: 'Has Capacity' }
              ]}
              actions={[
                { label: 'View Profile', action: 'view' },
                { label: 'Send Message', action: 'message' },
                { label: 'Suspend', action: 'suspend', confirm: true }
              ]}
            />
          </Tab>
          
          <Tab label="Performance">
            <PerformanceChart
              metrics={['qc_pass_rate', 'avg_production_time', 'jobs_completed']}
              groupBy="tailor"
              timeRange="last_30_days"
            />
            <TopPerformersTable limit={10} />
            <UnderperformersTable limit={10} threshold={0.85} />
          </Tab>
          
          <Tab label="Capacity">
            <CapacityHeatmap
              rows="tailors"
              columns="hours_of_day"
              metric="availability"
            />
            <FabricInventoryTable />
          </Tab>
          
          <Tab label="Onboarding">
            <OnboardingPipeline
              stages={['applied', 'document_review', 'skill_test', 'approved', 'active']}
            />
            <PendingApplicationsTable />
          </Tab>
        </Tabs>
      </Section>
      
      {/* ============================================ */}
      {/* DRIVER MANAGEMENT */}
      {/* ============================================ */}
      
      <Section title="Delivery Fleet">
        <Tabs>
          <Tab label="All Drivers">
            <DriverTable
              columns={[
                { key: 'name', label: 'Name' },
                { key: 'status', label: 'Status' },
                { key: 'assigned_van', label: 'Van' },
                { key: 'current_route', label: 'Current Route' },
                { key: 'deliveries_today', label: 'Today' },
                { key: 'on_time_rate', label: 'On-Time %' },
                { key: 'hours_worked', label: 'Hours' },
                { key: 'actions', label: '' }
              ]}
            />
          </Tab>
          
          <Tab label="Live Map">
            <FleetMap
              showVans={true}
              showRoutes={true}
              showTraffic={true}
            />
          </Tab>
          
          <Tab label="Schedule">
            <ShiftScheduler
              resources="drivers"
              view="week"
            />
          </Tab>
        </Tabs>
      </Section>
      
      {/* ============================================ */}
      {/* INSPECTOR MANAGEMENT */}
      {/* ============================================ */}
      
      <Section title="QC Inspectors">
        <InspectorTable
          columns={[
            { key: 'name', label: 'Name' },
            { key: 'status', label: 'Status' },
            { key: 'assigned_zone', label: 'Zone' },
            { key: 'inspections_today', label: 'Today' },
            { key: 'avg_time', label: 'Avg Time' },
            { key: 'actions', label: '' }
          ]}
        />
        <InspectorMap showLocations={true} showAssignments={true} />
      </Section>
      
      {/* ============================================ */}
      {/* ADMIN MANAGEMENT (Super Admin Only) */}
      {/* ============================================ */}
      
      {userRole === 'super_admin' && (
        <Section title="Admin Accounts">
          <AdminTable
            columns={[
              { key: 'name', label: 'Name' },
              { key: 'email', label: 'Email' },
              { key: 'role', label: 'Role' },
              { key: 'last_active', label: 'Last Active' },
              { key: 'status', label: 'Status' },
              { key: 'actions', label: '' }
            ]}
            actions={[
              { label: 'Edit Permissions', action: 'edit_permissions' },
              { label: 'Reset Password', action: 'reset_password' },
              { label: 'Deactivate', action: 'deactivate', confirm: true }
            ]}
          />
          <AddAdminButton />
        </Section>
      )}
      
    </DashboardLayout>
  );
};
```

### Account Management API

```typescript
// account-management-api.ts

const ACCOUNT_ENDPOINTS = {
  
  // ============================================
  // TAILOR ACCOUNTS
  // ============================================
  
  // List tailors
  'GET /admin/staff/tailors': {
    query: {
      status: 'active' | 'inactive' | 'suspended',
      skill_level: 'standard' | 'advanced' | 'master',
      has_capacity: boolean,
      search: string,
      sort_by: 'name' | 'qc_pass_rate' | 'total_jobs' | 'created_at',
      sort_order: 'asc' | 'desc',
      limit: number,
      offset: number
    },
    response: {
      tailors: TailorProfile[],
      pagination: { total, limit, offset }
    }
  },
  
  // Get tailor profile
  'GET /admin/staff/tailors/:id': {
    response: {
      profile: TailorProfile,
      stats: TailorStats,
      current_jobs: Assignment[],
      recent_jobs: Assignment[],
      earnings: EarningsSummary
    }
  },
  
  // Create tailor
  'POST /admin/staff/tailors': {
    body: {
      name: string,
      phone: string,
      email?: string,
      skill_level: 'standard' | 'advanced' | 'master',
      workshop_address: string,
      workshop_coordinates: [number, number],
      max_concurrent_jobs: number,
      bank_account: {
        account_number: string,
        ifsc_code: string,
        account_holder_name: string
      }
    },
    response: {
      tailor: TailorProfile,
      invite_sent: boolean,
      stripe_connect_url: string // For completing onboarding
    }
  },
  
  // Update tailor
  'PATCH /admin/staff/tailors/:id': {
    body: {
      name?: string,
      phone?: string,
      skill_level?: string,
      max_concurrent_jobs?: number,
      status?: 'active' | 'inactive' | 'suspended'
    },
    response: { tailor: TailorProfile }
  },
  
  // Suspend tailor
  'POST /admin/staff/tailors/:id/suspend': {
    body: {
      reason: string,
      duration_days?: number // null = indefinite
    },
    response: {
      tailor: TailorProfile,
      active_jobs_reassigned: number
    }
  },
  
  // Reactivate tailor
  'POST /admin/staff/tailors/:id/reactivate': {
    response: { tailor: TailorProfile }
  },
  
  // ============================================
  // DRIVER ACCOUNTS
  // ============================================
  
  'GET /admin/staff/drivers': {
    query: { status, base_airport, search, limit, offset },
    response: { drivers: DriverProfile[], pagination }
  },
  
  'GET /admin/staff/drivers/:id': {
    response: {
      profile: DriverProfile,
      stats: DriverStats,
      current_route?: Route,
      recent_routes: Route[],
      documents: Document[]
    }
  },
  
  'POST /admin/staff/drivers': {
    body: {
      name: string,
      phone: string,
      email?: string,
      license_number: string,
      license_expiry: string,
      base_airport: 'SHJ' | 'AUH',
      documents: {
        license_copy: File,
        id_proof: File
      }
    },
    response: { driver: DriverProfile, invite_sent: boolean }
  },
  
  'PATCH /admin/staff/drivers/:id': {
    body: { name?, phone?, base_airport?, status? },
    response: { driver: DriverProfile }
  },
  
  // Assign van to driver
  'POST /admin/staff/drivers/:id/assign-van': {
    body: { van_id: string },
    response: { driver: DriverProfile, van: Van }
  },
  
  // ============================================
  // INSPECTOR ACCOUNTS
  // ============================================
  
  'GET /admin/staff/inspectors': {
    query: { status, assigned_zone, search, limit, offset },
    response: { inspectors: InspectorProfile[], pagination }
  },
  
  'POST /admin/staff/inspectors': {
    body: {
      name: string,
      phone: string,
      assigned_zone: string,
      base_location: [number, number]
    },
    response: { inspector: InspectorProfile }
  },
  
  // ============================================
  // ADMIN ACCOUNTS
  // ============================================
  
  'GET /admin/staff/admins': {
    requires: 'super_admin',
    response: { admins: AdminProfile[] }
  },
  
  'POST /admin/staff/admins': {
    requires: 'super_admin',
    body: {
      name: string,
      email: string,
      phone: string,
      role: 'operations_manager' | 'shift_supervisor' | 'support',
      permissions?: Partial<Permissions> // Override defaults
    },
    response: { admin: AdminProfile, invite_sent: boolean }
  },
  
  'PATCH /admin/staff/admins/:id/permissions': {
    requires: 'super_admin',
    body: { permissions: Partial<Permissions> },
    response: { admin: AdminProfile }
  },
  
  // ============================================
  // COMMON ACCOUNT ACTIONS
  // ============================================
  
  // Send password reset
  'POST /admin/staff/:type/:id/reset-password': {
    response: { reset_link_sent: boolean }
  },
  
  // Send notification
  'POST /admin/staff/:type/:id/notify': {
    body: {
      channels: ('sms' | 'push' | 'email')[],
      message: string
    },
    response: { sent: boolean }
  },
  
  // Get activity log
  'GET /admin/staff/:type/:id/activity': {
    query: { from_date, to_date, limit },
    response: { activities: ActivityLog[] }
  },
  
  // Bulk actions
  'POST /admin/staff/:type/bulk': {
    body: {
      ids: string[],
      action: 'suspend' | 'reactivate' | 'notify',
      params?: any
    },
    response: { affected: number, results: any[] }
  }
};
```

---

This completes the specification for:

1. **Notification System** - Complete SMS/WhatsApp/Push infrastructure with templates, preferences, and delivery tracking
2. **VAPI Integration** - Automated voice calling for tailor escalation, SLA warnings, customer notifications, and inspector dispatch
3. **Mobile App Specifications** - Detailed screens for Tailor, Driver, Inspector, and Admin apps with need-to-know information and use cases
4. **Staff Management Dashboard** - Web-based admin controls for managing all staff types with full account lifecycle support

Want me to detail the analytics and reporting system, or the testing and QA procedures for this infrastructure?





---
Powered by [Claude Exporter](https://www.ai-chat-exporter.net)